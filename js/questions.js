// ============================================
// QUESTION BANK — iOS Interview Practice
// 23 topics × 6 levels (Intern → Staff)
// 479 questions total
// ============================================
var QUESTION_BANK = [
  {
    "topic": "swift",
    "level": 0,
    "question": "What is the difference between a value type and a reference type in Swift? Give examples of each.",
    "hint": "Think about what happens when you assign a variable to another variable — does it copy or share?",
    "answer": "Value types create a copy when assigned or passed to a function. Each variable holds its own independent copy of the data. Examples include structs, enums, tuples, and all basic types (Int, String, Bool, Array, Dictionary, Set).\n\nReference types share a single instance. When assigned or passed, both variables point to the same object in memory. Classes and closures are reference types.\n\nExample:\nvar a = [1, 2, 3]  // Array is a value type\nvar b = a           // b gets its own copy\nb.append(4)         // only b is modified, a is still [1, 2, 3]\n\nclass Dog { var name: String = \"Rex\" }\nlet dog1 = Dog()\nlet dog2 = dog1     // dog2 points to the same object\ndog2.name = \"Buddy\" // dog1.name is also now \"Buddy\""
  },
  {
    "topic": "swift",
    "level": 0,
    "question": "What are optionals in Swift and why do they exist?",
    "hint": "Think about representing the absence of a value — how does Swift handle nil safely?",
    "answer": "Optionals are a type that can hold either a value or nil (the absence of a value). They exist to provide compile-time safety around nil values, eliminating an entire category of runtime crashes common in languages like Objective-C.\n\nAn optional is declared with a question mark: var name: String?\n\nUnder the hood, Optional is an enum with two cases:\nenum Optional<Wrapped> {\n    case none        // nil\n    case some(Wrapped) // has a value\n}\n\nYou can unwrap optionals safely using:\n- if let / guard let (optional binding)\n- nil coalescing operator (??)\n- optional chaining (?.)\n\nForce unwrapping (!) should be avoided unless you are certain the value exists, as it crashes if the value is nil."
  },
  {
    "topic": "swift",
    "level": 0,
    "question": "What is an enum in Swift and how do you define one with associated values?",
    "hint": "Enums in Swift are more powerful than in most languages — they can carry data with each case.",
    "answer": "An enum (enumeration) defines a group of related values as a common type. In Swift, enums are first-class types that can have methods, computed properties, and conform to protocols.\n\nA basic enum:\nenum Direction {\n    case north, south, east, west\n}\n\nEnums with associated values allow each case to store additional data of specified types:\nenum NetworkResult {\n    case success(data: Data, statusCode: Int)\n    case failure(error: Error)\n}\n\nYou extract associated values using switch or if-case:\nswitch result {\ncase .success(let data, let statusCode):\n    print(\"Got \\(data.count) bytes, status \\(statusCode)\")\ncase .failure(let error):\n    print(\"Error: \\(error)\")\n}\n\nThis makes enums excellent for modeling states, results, and any situation with a fixed set of possibilities that may carry different data."
  },
  {
    "topic": "swift",
    "level": 0,
    "question": "What is the difference between `let` and `var` in Swift?",
    "hint": "One is for things that change, the other for things that stay the same once set.",
    "answer": "let declares a constant — its value cannot be changed after initialization. var declares a variable — its value can be changed.\n\nlet name = \"Alice\"  // constant, cannot reassign\nvar age = 30        // variable, can reassign\nage = 31            // OK\n// name = \"Bob\"     // Compile error\n\nFor reference types (classes), let means you cannot reassign the reference, but you can still mutate the object's properties:\nlet dog = Dog()\ndog.name = \"Buddy\"  // OK — mutating the object, not the reference\n// dog = Dog()      // Error — cannot reassign the reference\n\nBest practice: Always use let by default. Only use var when you actually need to mutate the value. The compiler will suggest changing var to let if you never mutate it."
  },
  {
    "topic": "swift",
    "level": 0,
    "question": "What are closures in Swift? How do you define one?",
    "hint": "Think of closures as unnamed functions that can capture values from their surrounding scope.",
    "answer": "Closures are self-contained blocks of functionality that can be passed around and used in code. They are similar to lambdas or blocks in other languages. Functions are actually a special case of closures.\n\nClosure syntax:\n{ (parameters) -> ReturnType in\n    // body\n}\n\nExample:\nlet greet = { (name: String) -> String in\n    return \"Hello, \\(name)!\"\n}\nprint(greet(\"Alice\")) // Hello, Alice!\n\nClosures can capture and store references to variables from their surrounding context:\nfunc makeCounter() -> () -> Int {\n    var count = 0\n    return {\n        count += 1\n        return count\n    }\n}\nlet counter = makeCounter()\ncounter() // 1\ncounter() // 2\n\nSwift has many shorthand forms: trailing closure syntax, implicit returns, shorthand argument names ($0, $1), and type inference."
  },
  {
    "topic": "swift",
    "level": 0,
    "question": "What are the different access control levels in Swift?",
    "hint": "There are five levels, ranging from completely unrestricted to restricted within a single declaration.",
    "answer": "Swift has five access control levels, from least restrictive to most:\n\n1. open — Accessible from any module. Classes can be subclassed and methods can be overridden outside the defining module. Only applies to classes and class members.\n\n2. public — Accessible from any module, but classes cannot be subclassed and methods cannot be overridden outside the defining module.\n\n3. internal (default) — Accessible within the same module. This is the default if you don't specify an access level.\n\n4. fileprivate — Accessible only within the same source file. Useful when multiple types in the same file need to share implementation details.\n\n5. private — Accessible only within the enclosing declaration and any extensions of that declaration in the same file.\n\nKey rules:\n- A type's access level constrains the access level of its members\n- A public class has internal members by default\n- Subclasses cannot have a higher access level than their parent\n- A function's access level is the minimum of its parameter and return types' access levels"
  },
  {
    "topic": "swift",
    "level": 1,
    "question": "Explain the difference between escaping and non-escaping closures. When would you use each?",
    "hint": "Think about the closure's lifetime — does it outlive the function it was passed to?",
    "answer": "A non-escaping closure (the default) is guaranteed to be called before the function it's passed to returns. The closure does not outlive the function. This allows the compiler to optimize memory management — no need to retain self.\n\nAn escaping closure may be called after the function returns. It must be marked with @escaping. Common uses:\n- Asynchronous completion handlers\n- Storing closures in properties\n- Closures dispatched to different queues\n\nfunc loadData(completion: @escaping (Data) -> Void) {\n    DispatchQueue.global().async {\n        let data = fetchFromNetwork()\n        completion(data)  // called after loadData returns\n    }\n}\n\nKey differences:\n- Non-escaping closures can reference self implicitly\n- Escaping closures require explicit self (self.property) to make capture semantics clear\n- Non-escaping closures are more performant because the compiler can skip retain/release\n- Closures stored in optional properties are implicitly escaping\n\nBest practice: Prefer non-escaping closures when possible for better performance and clearer semantics."
  },
  {
    "topic": "swift",
    "level": 1,
    "question": "What are protocols in Swift and how does protocol-oriented programming differ from object-oriented programming?",
    "hint": "Think about defining capabilities rather than inheritance hierarchies.",
    "answer": "A protocol defines a blueprint of methods, properties, and other requirements for a particular task. Any type (class, struct, enum) can conform to a protocol.\n\nprotocol Drawable {\n    func draw()\n    var color: Color { get set }\n}\n\nProtocol-oriented programming (POP) favors composition over inheritance:\n\n1. Composition over inheritance: Instead of a deep class hierarchy, you compose behavior from multiple protocols.\n\n2. Value type friendly: Structs and enums can conform to protocols but cannot inherit. POP makes value types first-class citizens.\n\n3. Protocol extensions provide default implementations:\nextension Drawable {\n    func draw() { print(\"Default drawing in \\(color)\") }\n}\n\n4. Multiple conformance: A type can conform to many protocols, while it can only inherit from one class.\n\n5. Retroactive conformance: You can extend existing types to conform to new protocols.\n\nOOP focuses on 'what things are' (class hierarchies). POP focuses on 'what things can do' (capabilities). Apple's recommendation since Swift's introduction is to start with protocols and value types, and only use classes when you specifically need reference semantics or inheritance."
  },
  {
    "topic": "swift",
    "level": 1,
    "question": "What are generics in Swift? Provide an example of a generic function and a generic type.",
    "hint": "Generics let you write flexible code that works with any type while preserving type safety.",
    "answer": "Generics allow you to write functions and types that work with any type, subject to constraints you define. They avoid code duplication while maintaining full type safety.\n\nGeneric function:\nfunc swapValues<T>(_ a: inout T, _ b: inout T) {\n    let temp = a\n    a = b\n    b = temp\n}\n\nGeneric type:\nstruct Stack<Element> {\n    private var items: [Element] = []\n    mutating func push(_ item: Element) { items.append(item) }\n    mutating func pop() -> Element? { items.popLast() }\n}\nvar intStack = Stack<Int>()\nintStack.push(42)\n\nYou can constrain generics to require certain capabilities:\nfunc findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {\n    array.firstIndex(of: value)\n}\n\nThe where clause provides more complex constraints:\nfunc allMatch<C: Collection>(_ collection: C, predicate: (C.Element) -> Bool) -> Bool where C.Element: Equatable {\n    collection.allSatisfy(predicate)\n}\n\nSwift's standard library uses generics extensively — Array<Element>, Dictionary<Key, Value>, Optional<Wrapped>, and Result<Success, Failure> are all generic types."
  },
  {
    "topic": "swift",
    "level": 1,
    "question": "Explain Swift's error handling model. What are the different ways to handle errors?",
    "hint": "Swift uses a throwing mechanism — think about throws, do-catch, try, try?, and try!.",
    "answer": "Swift uses a throwing-based error handling model. Errors are values conforming to the Error protocol (typically enums).\n\nDefining errors:\nenum NetworkError: Error {\n    case noConnection\n    case timeout(seconds: Int)\n    case serverError(code: Int)\n}\n\nThrowing errors:\nfunc fetchData() throws -> Data {\n    guard isConnected else { throw NetworkError.noConnection }\n    return data\n}\n\nHandling errors:\n\n1. do-catch:\ndo {\n    let data = try fetchData()\n} catch NetworkError.timeout(let seconds) {\n    print(\"Timed out after \\(seconds)s\")\n} catch {\n    print(\"Error: \\(error)\")  // implicit 'error' binding\n}\n\n2. try? — converts to optional, returns nil on error:\nlet data = try? fetchData()\n\n3. try! — force unwraps, crashes on error:\nlet data = try! fetchData()  // Use only when failure is impossible\n\n4. Result type for async/callback-based error handling:\nfunc fetch(completion: (Result<Data, NetworkError>) -> Void)\n\n5. Typed throws (Swift 6.0): You can specify the exact error type:\nfunc fetch() throws(NetworkError) -> Data\n\nThe rethrows keyword marks functions that only throw if their closure parameter throws, enabling better API ergonomics."
  },
  {
    "topic": "swift",
    "level": 1,
    "question": "What are property wrappers in Swift? Provide an example of creating and using one.",
    "hint": "They let you extract reusable property logic into a separate type using the @-prefixed syntax.",
    "answer": "Property wrappers encapsulate reusable get/set logic for properties. They are defined as a struct, class, or enum with a wrappedValue property, and applied using the @ syntax.\n\nExample — a clamping property wrapper:\n@propertyWrapper\nstruct Clamped {\n    var wrappedValue: Int {\n        didSet { wrappedValue = min(max(wrappedValue, range.lowerBound), range.upperBound) }\n    }\n    let range: ClosedRange<Int>\n    \n    init(wrappedValue: Int, _ range: ClosedRange<Int>) {\n        self.range = range\n        self.wrappedValue = min(max(wrappedValue, range.lowerBound), range.upperBound)\n    }\n}\n\nstruct Player {\n    @Clamped(0...100) var health = 100\n}\n\nvar player = Player()\nplayer.health = 150  // clamped to 100\nplayer.health = -10  // clamped to 0\n\nProperty wrappers can also expose a projected value via $ syntax:\n@propertyWrapper\nstruct Published<Value> {\n    var projectedValue: Publisher<Value> { publisher }\n    // ...\n}\n// Access: $myProperty gives the projected value\n\nCommon built-in property wrappers: @State, @Binding, @Published, @AppStorage, @Environment, @ObservedObject.\n\nLimitations: Property wrappers cannot be used on computed properties, global variables require static initialization, and they add a layer of indirection that can make debugging harder."
  },
  {
    "topic": "swift",
    "level": 1,
    "question": "What is the difference between a struct and a class in Swift? When would you choose one over the other?",
    "hint": "Think about value vs reference semantics, inheritance, and deinitializers.",
    "answer": "Structs and classes share many features (properties, methods, initializers, protocol conformance, subscripts, extensions) but differ in important ways:\n\nStructs (value types):\n- Copied on assignment/passing\n- No inheritance\n- No deinitializers\n- Memberwise initializer generated automatically\n- Thread-safe by default (each copy is independent)\n- Stored on the stack (usually, unless captured)\n\nClasses (reference types):\n- Shared via references on assignment/passing\n- Support inheritance and polymorphism\n- Have deinitializers (deinit)\n- No automatic memberwise initializer\n- Need careful handling for thread safety\n- Stored on the heap with reference counting\n\nWhen to choose struct:\n- Default choice for most data types\n- When you want value semantics (independent copies)\n- For models, configurations, geometric types\n- When thread safety is important\n\nWhen to choose class:\n- When you need shared mutable state\n- When you need inheritance\n- When identity matters (=== operator)\n- For reference-counted resource management (e.g., file handles)\n- When interoperating with Objective-C\n- When used with Observation framework (@Observable requires a class)\n\nApple's guidance: prefer structs by default, use classes only when you need reference semantics."
  },
  {
    "topic": "swift",
    "level": 2,
    "question": "Explain capture lists in closures. How do you prevent retain cycles with closures?",
    "hint": "Think about [weak self] and [unowned self] — when do you use each, and what are the risks?",
    "answer": "Capture lists define how closures capture reference type variables. Without a capture list, closures capture references strongly, which can create retain cycles.\n\nRetain cycle example:\nclass ViewController {\n    var handler: (() -> Void)?\n    func setup() {\n        handler = { self.doSomething() }  // self -> handler -> closure -> self (cycle!)\n    }\n}\n\nSolutions using capture lists:\n\n1. [weak self] — captures self as a weak optional reference. If self is deallocated, the reference becomes nil.\nhandler = { [weak self] in\n    guard let self else { return }\n    self.doSomething()\n}\n\n2. [unowned self] — captures self as an unowned reference. Does NOT become nil — crashes if accessed after deallocation.\nhandler = { [unowned self] in\n    self.doSomething()  // crashes if self is deallocated\n}\n\nWhen to use each:\n- weak: When the closure might outlive the captured object. Safest choice.\n- unowned: When you're certain the captured object will always outlive the closure (e.g., parent-child relationships where the child cannot outlive the parent).\n\nCapture lists can also capture value copies:\nvar x = 10\nlet closure = { [x] in print(x) }  // captures current value of x (10)\nx = 20\nclosure()  // prints 10\n\nMultiple captures: { [weak self, unowned delegate, x] in ... }\n\nBest practice: Default to [weak self] for escaping closures. Use [unowned self] only when the lifecycle guarantee is clear and well-documented."
  },
  {
    "topic": "swift",
    "level": 2,
    "question": "What are opaque types (`some`) and existential types (`any`) in Swift? How do they differ?",
    "hint": "Both work with protocols, but one hides the concrete type from the caller while the other erases it entirely.",
    "answer": "Opaque types (some Protocol) and existential types (any Protocol) are two ways to work with protocol-typed values, with fundamentally different semantics.\n\nOpaque types (some):\n- The concrete type is hidden from the caller but fixed at compile time\n- The compiler knows the exact type — it just hides it from you\n- Preserves type identity: `some Equatable` values of the same origin can be compared\n- Used for return types and, since Swift 5.7, parameters\n- More efficient — no heap allocation or dynamic dispatch overhead\n\nvar body: some View {  // Always returns the same concrete View type\n    Text(\"Hello\")\n}\n\nfunc makeCollection() -> some Collection<Int> {\n    return [1, 2, 3]  // Concrete type is Array<Int>, hidden from caller\n}\n\nExistential types (any):\n- The concrete type is fully erased at runtime\n- Can hold different concrete types at different times\n- Requires heap allocation (existential container)\n- Cannot use Self or associated type requirements directly\n- Uses dynamic dispatch\n\nvar shapes: [any Shape] = [Circle(), Square()]  // Heterogeneous array\n\nKey differences:\n- some = one fixed concrete type, compiler knows it, caller doesn't\n- any = any conforming type, can vary at runtime, boxed in existential container\n- some is more performant (static dispatch, no boxing)\n- any is more flexible (heterogeneous collections)\n\nSince Swift 5.7, the compiler requires `any` for protocol types used as existentials, making the distinction explicit."
  },
  {
    "topic": "swift",
    "level": 2,
    "question": "Explain copy-on-write (CoW) in Swift. Which types use it and how does it work?",
    "hint": "Think about how Swift optimizes value types so copies are cheap until mutation happens.",
    "answer": "Copy-on-write is an optimization that defers the actual copying of value type data until a mutation occurs. This makes passing and assigning value types cheap (O(1)) until you actually modify the copy.\n\nHow it works:\n1. When you assign a value type, both variables share the same underlying storage (a reference to heap-allocated buffer).\n2. When either variable is mutated, Swift checks if the storage is uniquely referenced (reference count == 1).\n3. If shared, it copies the storage first, then mutates the copy.\n4. If uniquely referenced, it mutates in place (no copy needed).\n\nBuilt-in CoW types: Array, Dictionary, Set, String, and other standard library collections.\n\nvar a = [1, 2, 3]  // allocates buffer\nvar b = a           // shares buffer, no copy yet\nb.append(4)         // NOW copies, because buffer is shared\n\nImplementing CoW for custom types:\nfinal class Storage { var data: [Int] = [] }\n\nstruct MyCollection {\n    private var storage = Storage()\n    \n    var data: [Int] {\n        get { storage.data }\n        set {\n            if !isKnownUniquelyReferenced(&storage) {\n                storage = Storage()  // copy on write\n            }\n            storage.data = newValue\n        }\n    }\n}\n\nisKnownUniquelyReferenced() is the key function — it checks the reference count of a class instance. This only works with Swift classes (not Objective-C classes).\n\nImportant: CoW is NOT automatic for custom structs. Only standard library collections implement it. For custom value types with heap-allocated storage, you must implement it manually."
  },
  {
    "topic": "swift",
    "level": 2,
    "question": "What are key paths in Swift and how are they used?",
    "hint": "Key paths are a way to reference properties themselves, not their values — like a function from a root type to a property type.",
    "answer": "Key paths are strongly-typed references to properties that can be stored, passed around, and applied to instances to read or write values. They form a type hierarchy:\n\nKeyPath<Root, Value> — read-only\nWritableKeyPath<Root, Value> — read-write on value types\nReferenceWritableKeyPath<Root, Value> — read-write on reference types\nPartialKeyPath<Root> — type-erased value\nAnyKeyPath — fully type-erased\n\nSyntax: \\Type.property or \\.property when type can be inferred.\n\nBasic usage:\nstruct User { var name: String; var age: Int }\nlet nameKeyPath = \\User.name\nlet user = User(name: \"Alice\", age: 30)\nuser[keyPath: nameKeyPath]  // \"Alice\"\n\nKey paths compose:\n\\User.address.city  // chains through nested properties\n\nPractical uses:\n\n1. Sorting: users.sorted(by: \\.age)\n2. Mapping: users.map(\\.name)  // extracts names\n3. KVO: observation using key paths\n4. SwiftUI bindings: $viewModel.name uses key paths internally\n5. Dynamic member lookup: @dynamicMemberLookup uses key paths\n6. Generic algorithms:\nfunc sort<T, V: Comparable>(_ array: inout [T], by keyPath: KeyPath<T, V>) {\n    array.sort { $0[keyPath: keyPath] < $1[keyPath: keyPath] }\n}\n\nKey paths can also be used with subscripts and optional chaining: \\User.friends[0].name, \\User.address?.city."
  },
  {
    "topic": "swift",
    "level": 2,
    "question": "How does Swift's `Codable` protocol work? What are `CodingKeys` and when do you need custom implementations?",
    "hint": "Codable is actually a type alias for Encodable & Decodable. Think about when auto-synthesis is sufficient and when it is not.",
    "answer": "Codable is a type alias for Encodable & Decodable. It provides automatic JSON/Plist serialization when all properties are themselves Codable.\n\nAuto-synthesis:\nstruct User: Codable {\n    let name: String\n    let age: Int\n}\n// Automatically encodes/decodes {\"name\": \"Alice\", \"age\": 30}\n\nCodingKeys — a nested enum that maps property names to JSON keys:\nstruct User: Codable {\n    let firstName: String\n    enum CodingKeys: String, CodingKey {\n        case firstName = \"first_name\"  // maps snake_case JSON key\n    }\n}\n\nAlternatively, use keyDecodingStrategy on JSONDecoder:\nlet decoder = JSONDecoder()\ndecoder.keyDecodingStrategy = .convertFromSnakeCase\n\nCustom implementations are needed when:\n1. JSON structure differs from your model (nested/flattened)\n2. Conditional decoding (different types based on a key)\n3. Default values for missing keys\n4. Computed or derived properties\n\nCustom decode example:\ninit(from decoder: Decoder) throws {\n    let container = try decoder.container(keyedBy: CodingKeys.self)\n    name = try container.decode(String.self, forKey: .name)\n    age = try container.decodeIfPresent(Int.self, forKey: .age) ?? 0\n}\n\nAdvanced patterns:\n- nestedContainer for flattening nested JSON\n- unkeyedContainer for arrays\n- singleValueContainer for wrapper types\n- superEncoder()/superDecoder() for inheritance\n- Custom date strategies, data strategies\n- Using @propertyWrapper for reusable decode logic (e.g., default values, lossy arrays)"
  },
  {
    "topic": "swift",
    "level": 2,
    "question": "What are extensions in Swift? What can and cannot be done with them?",
    "hint": "Extensions add new functionality to existing types — but there are some important limitations.",
    "answer": "Extensions add new functionality to existing types without subclassing or modifying source code (retroactive modeling).\n\nWhat extensions CAN do:\n- Add computed properties (instance and type)\n- Add methods (instance and type)\n- Add new initializers (convenience initializers for classes)\n- Add subscripts\n- Add nested types\n- Conform to protocols (including retroactive conformance)\n- Add protocol conformance with default implementations\n- Constrained extensions (where clauses)\n\nextension Array where Element: Numeric {\n    var sum: Element { reduce(0, +) }\n}\n\nextension String: Identifiable {\n    public var id: String { self }\n}\n\nWhat extensions CANNOT do:\n- Add stored properties (only computed)\n- Override existing methods (except in class extensions marked @objc)\n- Add designated initializers to classes (only convenience)\n- Add deinitializers\n- Change the access level of existing members\n\nBest practices:\n- Use extensions to organize code with MARK comments\n- One extension per protocol conformance\n- Private extensions for helper methods\n- Constrained extensions for specialized behavior\n\nextension MyView {\n    // MARK: - Setup\n    private func setupUI() { ... }\n}\n\nExtensions are resolved at compile time (static dispatch) unless the method is declared in the protocol itself or marked @objc, which can lead to surprising behavior when calling extension methods on protocol-typed variables."
  },
  {
    "topic": "swift",
    "level": 2,
    "question": "Explain the difference between `self` and `Self` in Swift, and between `.Type` and `.Protocol`.",
    "hint": "Lowercase self is the instance, uppercase Self is the type. .Type and .Protocol deal with metatypes.",
    "answer": "self (lowercase):\n- Refers to the current instance within methods\n- In a type method, self refers to the type itself\n- Used to disambiguate property names from parameter names\n\nSelf (uppercase):\n- Refers to the conforming/inheriting type (not a specific concrete type)\n- In protocols, Self means 'the type that conforms to this protocol'\n- In classes, Self means 'the actual dynamic type' (enables covariant returns)\n\nprotocol Copyable {\n    func copy() -> Self  // Returns the conforming type\n}\n\nclass Base {\n    func clone() -> Self { ... }  // Subclass returns Subclass, not Base\n}\n\n.Type — the metatype of a concrete type or protocol conformer:\n- Int.Type is the type of Int itself (the metatype)\n- Int.self is the metatype value\n- let type: Int.Type = Int.self\n- For protocols: (any MyProtocol).Type represents any concrete type that conforms\n\n.Protocol — the metatype of the protocol itself (not its conformers):\n- MyProtocol.Protocol is the metatype of the protocol\n- MyProtocol.self returns the protocol metatype value\n- let proto: MyProtocol.Protocol = MyProtocol.self\n\nPractical usage:\nfunc create<T: Decodable>(_ type: T.Type) -> T  // Takes a metatype parameter\nlet user = create(User.self)  // Passes User metatype\n\nWith any:\nfunc register(_ type: any Service.Type)  // Accepts any conforming metatype\nregister(NetworkService.self)"
  },
  {
    "topic": "swift",
    "level": 3,
    "question": "Explain method dispatch in Swift. What are static dispatch and dynamic dispatch, and when is each used?",
    "hint": "Think about value types, classes, protocols, and how the compiler decides which method to call at compile time vs runtime.",
    "answer": "Method dispatch determines how Swift finds and calls the correct method implementation.\n\nStatic dispatch (direct dispatch):\n- The compiler knows exactly which function to call at compile time\n- The call is a direct jump to the function address — fastest\n- Used by: value types (structs, enums), final classes/methods, methods in extensions (not declared in protocol), module-internal classes (the compiler may de-virtualize)\n\nTable dispatch (vtable dispatch):\n- Uses a lookup table to find the method at runtime\n- Each class has a vtable; subclasses override entries in the table\n- Used by: class methods (non-final, non-objc)\n- Protocols use a witness table (similar concept)\n\nMessage dispatch (objc_msgSend):\n- Full Objective-C runtime message sending\n- Slowest but most dynamic — supports method swizzling, KVO\n- Used by: @objc methods, dynamic keyword, NSObject subclass methods exposed to ObjC\n\nProtocol dispatch subtleties:\nprotocol P {\n    func required()    // In protocol: witness table dispatch\n}\nextension P {\n    func required() { }  // Default implementation via witness table\n    func notRequired() { }  // NOT in protocol: static dispatch!\n}\n\nlet x: any P = SomeConformingType()\nx.notRequired()  // Calls extension's implementation (static dispatch on protocol type)\n// Even if SomeConformingType provides its own notRequired()!\n\nPerformance hierarchy: static > table > message\n\nThe final keyword, whole module optimization, and private access all help the compiler use static dispatch. @objc dynamic forces message dispatch.\n\nKey gotcha: Protocol extension methods not declared in the protocol requirement use static dispatch based on the declared type, not the runtime type."
  },
  {
    "topic": "swift",
    "level": 3,
    "question": "What are result builders in Swift and how do they work? Explain the transformation rules.",
    "hint": "Think about @ViewBuilder in SwiftUI — it transforms a series of statements into a single result using buildBlock, buildOptional, etc.",
    "answer": "Result builders (formerly function builders) transform a sequence of statements into a single combined result via a DSL-like syntax. SwiftUI's @ViewBuilder is the most prominent example.\n\nDefining a result builder:\n@resultBuilder\nstruct ArrayBuilder<Element> {\n    static func buildBlock(_ components: Element...) -> [Element] {\n        Array(components)\n    }\n    static func buildOptional(_ component: [Element]?) -> [Element] {\n        component ?? []\n    }\n    static func buildEither(first component: [Element]) -> [Element] {\n        component\n    }\n    static func buildEither(second component: [Element]) -> [Element] {\n        component\n    }\n    static func buildArray(_ components: [[Element]]) -> [Element] {\n        components.flatMap { $0 }\n    }\n}\n\nTransformation rules — the compiler transforms your DSL code:\n\n1. buildBlock — combines sequential statements\n2. buildOptional — handles if without else\n3. buildEither(first:/second:) — handles if/else branches\n4. buildArray — handles for...in loops\n5. buildExpression — transforms individual expressions before combining\n6. buildFinalResult — transforms the final output\n7. buildLimitedAvailability — handles #available checks\n\nExample transformation:\n@ViewBuilder var body: some View {\n    Text(\"Hello\")     // expression 1\n    if showImage {     // buildEither\n        Image(\"photo\")\n    } else {\n        EmptyView()\n    }\n}\n// Becomes: ViewBuilder.buildBlock(Text(\"Hello\"), ViewBuilder.buildEither(first/second: ...))\n\nResult builders enable declarative DSLs for HTML builders, test assertions, regex construction, query builders, and more. The key insight is they are a compile-time transformation — no runtime overhead."
  },
  {
    "topic": "swift",
    "level": 3,
    "question": "What is conditional conformance in Swift? Provide examples and explain why it is useful.",
    "hint": "A generic type can conform to a protocol only when its type parameter meets certain conditions.",
    "answer": "Conditional conformance allows a generic type to conform to a protocol only when its type parameters satisfy certain constraints.\n\nExample — Array is Equatable only when its Element is Equatable:\nextension Array: Equatable where Element: Equatable {\n    static func == (lhs: [Element], rhs: [Element]) -> Bool { ... }\n}\n\n[1, 2, 3] == [1, 2, 3]  // Works because Int: Equatable\n// [UIView(), UIView()] == [...]  // Error: UIView is not Equatable\n\nStandard library examples:\n- Array: Equatable when Element: Equatable\n- Array: Hashable when Element: Hashable\n- Optional: Equatable when Wrapped: Equatable\n- Result: Equatable when both Success and Failure are Equatable\n\nCustom example:\nstruct Stack<Element> {\n    var items: [Element]\n}\n\nextension Stack: Equatable where Element: Equatable {}\nextension Stack: Hashable where Element: Hashable {}\nextension Stack: Encodable where Element: Encodable {}\nextension Stack: Decodable where Element: Decodable {}\n\nNested conditional conformance:\nextension Array: CustomStringConvertible where Element: CustomStringConvertible {\n    var description: String {\n        items.map(\\.description).joined(separator: \", \")\n    }\n}\n\nWhy it matters:\n- Enables type-safe generic programming\n- Avoids runtime checks — conformance is verified at compile time\n- Propagates conformances automatically through type composition\n- Makes generic types as capable as their elements allow\n- Fundamental to how Swift's standard library works"
  },
  {
    "topic": "swift",
    "level": 3,
    "question": "What is type erasure in Swift? Why is it needed and what are common patterns for implementing it?",
    "hint": "Think about protocols with associated types — you can't use them as existentials directly, so you need a wrapper type.",
    "answer": "Type erasure is a pattern for hiding a concrete type behind a common interface, typically used when you need to store or pass values of different types that conform to a protocol with associated types.\n\nWhy it's needed:\nProtocols with associated types (PATs) or Self requirements cannot be used as existentials directly (before any keyword):\nprotocol Publisher {\n    associatedtype Output\n    func subscribe(_ subscriber: some Subscriber<Output>)\n}\n// var publishers: [any Publisher]  // What is Output?\n\nClassic type erasure pattern (AnyXxx wrapper):\nstruct AnyPublisher<Output>: Publisher {\n    private let _subscribe: (any Subscriber<Output>) -> Void\n    \n    init<P: Publisher>(_ publisher: P) where P.Output == Output {\n        _subscribe = { publisher.subscribe($0) }\n    }\n    \n    func subscribe(_ subscriber: some Subscriber<Output>) {\n        _subscribe(subscriber)\n    }\n}\n\nStandard library examples: AnySequence, AnyCollection, AnyHashable, AnyCancellable, AnyView.\n\nModern alternatives (Swift 5.7+):\n\n1. Primary associated types with any:\nprotocol Collection<Element>: Sequence { ... }\nvar items: any Collection<Int>  // Constrained existential\n\n2. some for opaque return types:\nfunc makeCollection() -> some Collection<Int> { [1, 2, 3] }\n\n3. Constrained existentials largely eliminate the need for manual type erasure:\nvar publishers: [any Publisher<Int>]  // With primary associated types\n\nWhen you still need manual type erasure:\n- When you need to store heterogeneous conforming types and the protocol has multiple associated types\n- When working with older deployment targets\n- When you need to erase non-primary associated types\n\nPerformance note: Type erasure via closures involves heap allocation. The any existential box has a fixed-size inline buffer (currently 3 words) and spills to heap for larger types."
  },
  {
    "topic": "swift",
    "level": 3,
    "question": "Explain @dynamicMemberLookup and @dynamicCallable in Swift. What are their use cases?",
    "hint": "They make Swift types behave more like dynamic languages — one for property access, the other for function calls.",
    "answer": "@dynamicMemberLookup allows a type to handle arbitrary property access at runtime via subscript(dynamicMember:).\n\n@dynamicMemberLookup\nstruct JSON {\n    let data: [String: Any]\n    \n    subscript(dynamicMember key: String) -> JSON? {\n        (data[key] as? [String: Any]).map(JSON.init)\n    }\n    \n    subscript(dynamicMember key: String) -> String? {\n        data[key] as? String\n    }\n}\n\nlet json = JSON(data: [\"user\": [\"name\": \"Alice\"]])\nlet name: String? = json.user?.name  // \"Alice\" — no actual properties!\n\nKey path variant:\n@dynamicMemberLookup\nstruct Wrapper<Value> {\n    var value: Value\n    subscript<T>(dynamicMember keyPath: KeyPath<Value, T>) -> T {\n        value[keyPath: keyPath]\n    }\n}\n// Forwards all property access to the wrapped value\n\nUse cases: JSON wrappers, scripting bridges (Python interop), proxy objects, SwiftUI's @Bindable uses key-path dynamic member lookup.\n\n@dynamicCallable allows a type to be called like a function.\n\n@dynamicCallable\nstruct PythonFunction {\n    func dynamicallyCall(withArguments args: [Any]) -> Any { ... }\n    func dynamicallyCall(withKeywordArguments args: KeyValuePairs<String, Any>) -> Any { ... }\n}\n\nlet fn = PythonFunction()\nfn(1, 2, 3)  // calls dynamicallyCall(withArguments: [1, 2, 3])\nfn(x: 1, y: 2)  // calls dynamicallyCall(withKeywordArguments: [\"x\": 1, \"y\": 2])\n\nUse cases: Python/Ruby interop, DSLs, scripting engines, function-like objects.\n\nBoth attributes sacrifice compile-time safety for flexibility — use them judiciously for interop or DSL scenarios, not for general Swift code."
  },
  {
    "topic": "swift",
    "level": 3,
    "question": "What are frozen enums in Swift? What is the @unknown default pattern?",
    "hint": "Think about library evolution — what happens when an enum gains a new case in a future SDK version?",
    "answer": "Frozen enums are enums that promise never to add new cases in future versions. This is a concept from Swift's library evolution (ABI stability) model.\n\n@frozen enum — all cases are known and fixed forever:\n@frozen\npublic enum Optional<Wrapped> {\n    case none\n    case some(Wrapped)\n}\n\nBenefits of @frozen:\n- Compiler can optimize aggressively (no need for future-proofing)\n- Switch statements don't need a default case\n- Can be stored inline (size is known at compile time)\n- Enum layout is part of the ABI\n\nNon-frozen enums (default for library code):\nMay gain new cases in future library updates. When you switch over a non-frozen enum, the compiler warns you to add @unknown default:\n\n// In a future OS, new UIUserInterfaceStyle cases could be added\nswitch traitCollection.userInterfaceStyle {\ncase .light: handleLight()\ncase .dark: handleDark()\ncase .unspecified: handleUnspecified()\n@unknown default: handleUnspecified()  // Future-proofing\n}\n\n@unknown default differs from a plain default:\n- It still triggers a compiler warning if you're missing a known case\n- It only silences the 'non-exhaustive switch' warning for future unknown cases\n- It communicates intent: 'I've handled all current cases but want to be safe'\n\nPlain default swallows all unmatched cases silently — you won't be warned when new cases are added.\n\nWhen to use @frozen:\n- Only in libraries/frameworks with ABI stability concerns\n- When you guarantee the enum will never gain cases\n- Most app code doesn't need this — it's primarily for the Swift standard library and Apple's frameworks"
  },
  {
    "topic": "swift",
    "level": 4,
    "question": "Explain primary associated types in Swift protocols. How do they relate to `some` and `any`?",
    "hint": "Primary associated types allow you to constrain existentials and opaque types with angle-bracket syntax on protocols.",
    "answer": "Primary associated types (introduced in Swift 5.7) allow protocols to declare which associated types are most important, enabling angle-bracket constraint syntax similar to generic types.\n\nDeclaration:\nprotocol Collection<Element>: Sequence {\n    associatedtype Element\n    associatedtype Index\n    // Element is primary, Index is not\n}\n\nThis enables constrained usage with some and any:\n\nOpaque types:\nfunc numbers() -> some Collection<Int> { [1, 2, 3] }\n// Caller knows Element == Int, concrete type is hidden\n\nExistential types:\nvar items: any Collection<Int> = [1, 2, 3]\nitems = Set<Int>([4, 5, 6])  // Can hold different concrete types\n\nFunction parameters:\nfunc process(_ items: some Collection<String>) { ... }\n// Equivalent to: func process<C: Collection>(_ items: C) where C.Element == String\n\nMultiple primary associated types:\nprotocol MyProtocol<Input, Output> {\n    associatedtype Input\n    associatedtype Output\n    associatedtype InternalState  // Not primary\n}\nvar handler: any MyProtocol<String, Int>\n\nWhy they matter:\n1. Before primary associated types, you couldn't write `any Collection<Int>` — you needed AnyCollection<Int> (manual type erasure)\n2. They make protocols as ergonomic as generic types for common constraints\n3. Non-primary associated types remain hidden/erased\n4. They're the foundation for Swift's move toward eliminating manual type erasure\n\nStandard library adoptions: Collection<Element>, Sequence<Element>, IteratorProtocol<Element>, AsyncSequence<Element>, Identifiable<ID>, and many more."
  },
  {
    "topic": "swift",
    "level": 4,
    "question": "How do variadic generics (parameter packs) work in Swift? Explain `each`, `repeat`, and pack expansion.",
    "hint": "Swift 5.9 introduced the ability to abstract over a variable number of type parameters using parameter packs.",
    "answer": "Variadic generics (Swift 5.9) allow functions and types to accept an arbitrary number of type parameters, eliminating the need for overloads like (T1), (T1, T2), (T1, T2, T3), etc.\n\nKey syntax:\n- `each T` declares a type parameter pack\n- `repeat each T` expands the pack\n- Pack expansion applies a pattern to each element\n\nBasic example:\nfunc allEqual<each T: Equatable>(_ values: repeat (each T, each T)) -> Bool {\n    for pair in repeat each values {\n        guard pair.0 == pair.1 else { return false }\n    }\n    return true\n}\n\nallEqual((1, 1), (\"a\", \"a\"), (true, true))  // true\n// T pack is: Int, String, Bool\n\nReturn type packs:\nfunc transform<each Input, each Output>(\n    _ input: repeat each Input,\n    using transforms: repeat (each Input) -> each Output\n) -> (repeat each Output) {\n    (repeat (each transforms)(each input))\n}\n\nType-level packs:\nstruct TupleStruct<each T> {\n    var values: (repeat each T)\n    \n    func map<each U>(_ transforms: repeat (each T) -> each U) -> TupleStruct<repeat each U> {\n        TupleStruct<repeat each U>(values: (repeat (each transforms)(each values)))\n    }\n}\n\nPack expansion rules:\n- `repeat each T` expands to T1, T2, T3, ... for each element\n- `repeat [each T]` expands to [T1], [T2], [T3], ...\n- `repeat (each T) -> Bool` expands to (T1) -> Bool, (T2) -> Bool, ...\n\nReal-world use cases:\n- SwiftUI's ViewBuilder uses packs internally for TupleView\n- The swift-testing framework uses packs for parameterized tests\n- Generic tuple transformations\n- Heterogeneous zip operations\n\nLimitations: No conditional logic within pack iteration, limited pattern matching on packs, and pack conformance checking is still evolving."
  },
  {
    "topic": "swift",
    "level": 4,
    "question": "Explain Swift's literal protocols (ExpressibleByStringLiteral, etc.). How would you create a type that can be initialized from multiple literal types?",
    "hint": "Swift has a hierarchy of literal protocols that types can conform to for initialization from literal values.",
    "answer": "Literal protocols allow custom types to be initialized from literal syntax. When you write let x: MyType = 42, the compiler uses ExpressibleByIntegerLiteral conformance.\n\nLiteral protocol hierarchy:\n- ExpressibleByNilLiteral — nil\n- ExpressibleByBooleanLiteral — true, false\n- ExpressibleByIntegerLiteral — 42\n- ExpressibleByFloatLiteral — 3.14\n- ExpressibleByStringLiteral — \"hello\"\n  - ExpressibleByExtendedGraphemeClusterLiteral\n    - ExpressibleByUnicodeScalarLiteral\n- ExpressibleByStringInterpolation — \"Hello \\(name)\"\n- ExpressibleByArrayLiteral — [1, 2, 3]\n- ExpressibleByDictionaryLiteral — [\"key\": \"value\"]\n\nMulti-literal type example:\nstruct Identifier: ExpressibleByStringLiteral, ExpressibleByIntegerLiteral, Hashable {\n    let rawValue: String\n    \n    init(stringLiteral value: String) {\n        rawValue = value\n    }\n    \n    init(integerLiteral value: Int) {\n        rawValue = String(value)\n    }\n}\n\nlet id1: Identifier = \"user-abc\"  // String literal\nlet id2: Identifier = 12345        // Integer literal\n\nAdvanced — custom string interpolation:\nstruct Query: ExpressibleByStringInterpolation {\n    let sql: String\n    let parameters: [Any]\n    \n    struct StringInterpolation: StringInterpolationProtocol {\n        var sql = \"\"\n        var parameters: [Any] = []\n        \n        mutating func appendLiteral(_ literal: String) {\n            sql += literal\n        }\n        \n        mutating func appendInterpolation(param value: Any) {\n            sql += \"?\"\n            parameters.append(value)\n        }\n    }\n}\n\nlet query: Query = \"SELECT * FROM users WHERE name = \\(param: \"Alice\") AND age > \\(param: 18)\"\n// query.sql == \"SELECT * FROM users WHERE name = ? AND age > ?\"\n// query.parameters == [\"Alice\", 18]\n\nImportant details:\n- Default literal types: IntegerLiteralType = Int, FloatLiteralType = Double, StringLiteralType = String, BooleanLiteralType = Bool\n- The compiler infers the literal type from context; without context, it uses the default\n- Custom literal conformance enables powerful DSLs while maintaining type safety"
  },
  {
    "topic": "swift",
    "level": 4,
    "question": "What are typed throws in Swift? How do they differ from untyped throws and what impact do they have on error handling?",
    "hint": "Swift 6.0 introduced the ability to specify the exact error type in a throws clause, bringing precision to error handling.",
    "answer": "Typed throws (Swift 6.0) allow functions to declare the specific error type they throw, using throws(ErrorType) syntax.\n\nBefore (untyped throws):\nfunc parse(_ data: Data) throws -> Model {\n    // throws any Error — caller must handle generic Error\n}\n\nWith typed throws:\nenum ParseError: Error {\n    case invalidFormat\n    case missingField(String)\n}\n\nfunc parse(_ data: Data) throws(ParseError) -> Model {\n    throw ParseError.invalidFormat\n    // Can ONLY throw ParseError, not arbitrary errors\n}\n\nCaller benefits:\ndo {\n    let model = try parse(data)\n} catch .invalidFormat {\n    // Exhaustive matching on ParseError cases\n} catch .missingField(let name) {\n    // No need for a generic catch — compiler knows all cases\n}\n\nType inference with rethrows-like behavior:\nfunc map<T, E>(_ transform: (Element) throws(E) -> T) throws(E) -> [T]\n// Error type is inferred from the closure\n\nSpecial types:\n- throws(Never) — equivalent to non-throwing (guaranteed no error)\n- throws(any Error) — equivalent to plain throws\n\nImpact on Result:\nfunc fetch() throws(NetworkError) -> Data\n// Compiler can bridge to Result<Data, NetworkError> automatically\nlet result: Result<Data, NetworkError> = Result { try fetch() }\n\nKey differences from untyped throws:\n1. Exhaustive catch — no need for generic catch block\n2. Precise error propagation — callers know exactly what errors to expect\n3. Better for library APIs — explicit error contract\n4. Works with generics — throws(E) where E: Error\n5. Backward compatible — plain throws is equivalent to throws(any Error)\n\nLimitations:\n- A function can only declare one error type (use an enum with cases for multiple errors)\n- try? still erases the error type to nil\n- Adding new cases to the error enum is a source-breaking change (consider @frozen or careful evolution)"
  },
  {
    "topic": "swift",
    "level": 4,
    "question": "Explain how subscripts work in Swift, including static subscripts and type subscripts with generic parameters.",
    "hint": "Subscripts provide shortcut access using bracket syntax, and they are more powerful than most developers realize.",
    "answer": "Subscripts provide shorthand access to elements using bracket syntax. They can be defined on classes, structs, enums, and even protocols.\n\nBasic subscript:\nstruct Matrix {\n    var data: [[Double]]\n    \n    subscript(row: Int, col: Int) -> Double {\n        get { data[row][col] }\n        set { data[row][col] = newValue }\n    }\n}\nvar m = Matrix(data: [[1, 2], [3, 4]])\nm[0, 1] = 5  // Sets row 0, col 1\n\nRead-only subscript (omit set, use implicit get):\nsubscript(index: Int) -> Element {\n    storage[index]\n}\n\nStatic subscripts:\nenum Settings {\n    static var values: [String: Any] = [:]\n    \n    static subscript(key: String) -> Any? {\n        get { values[key] }\n        set { values[key] = newValue }\n    }\n}\nSettings[\"theme\"] = \"dark\"\n\nGeneric subscripts:\nextension Collection {\n    subscript<Indices: Sequence>(indices: Indices) -> [Element]\n        where Indices.Element == Index\n    {\n        indices.map { self[$0] }\n    }\n}\nlet array = [\"a\", \"b\", \"c\", \"d\"]\narray[[0, 2, 3]]  // [\"a\", \"c\", \"d\"]\n\nSubscripts with default values:\nsubscript(key: String, default defaultValue: @autoclosure () -> Value) -> Value {\n    get { storage[key] ?? defaultValue() }\n}\ndict[\"missing\", default: 0] += 1\n\nKey details:\n- Subscripts can take any number of parameters of any type\n- Can be overloaded (same type, different parameter types)\n- Can be throwing: subscript(i: Int) throws -> Element\n- Can be async (Swift 5.5+)\n- Participate in key paths: \\Array<Int>.[0]\n- Protocol requirements can include subscripts\n- @dynamicMemberLookup is syntactic sugar for a special subscript\n\nSubscripts use the same dispatch rules as methods — static dispatch for value types, virtual dispatch for classes."
  },
  {
    "topic": "swift",
    "level": 5,
    "question": "Explain the internal memory layout of Swift existential containers. How does the value witness table work?",
    "hint": "Think about how Swift stores a value of type `any Protocol` — there is an inline buffer, a value witness table, and a protocol witness table.",
    "answer": "When you store a value as `any Protocol`, Swift uses an existential container — a fixed-size structure that can hold any conforming value.\n\nMemory layout of an existential container (any Protocol):\n- 3 words (24 bytes on 64-bit) inline value buffer\n- 1 word: pointer to the value witness table (VWT)\n- 1 word: pointer to the protocol witness table (PWT)\nTotal: 5 words (40 bytes) for a single-protocol existential\n\nFor each additional protocol conformance, add 1 word for another PWT pointer.\n\nInline buffer optimization:\n- If the concrete value fits in 3 words (24 bytes), it is stored inline in the buffer\n- If larger, a heap allocation is made, and the buffer stores a pointer to the heap\n- Most simple types (Int, Bool, small structs) fit inline\n\nValue Witness Table (VWT):\nA table of function pointers that describe how to manage values of the concrete type:\n- initializeWithCopy — copy constructor\n- assignWithCopy — copy assignment\n- initializeWithTake — move constructor (takes ownership)\n- assignWithTake — move assignment\n- destroy — destructor\n- size, alignment, stride — layout information\n- flags — indicates whether the type is trivially copyable, etc.\n\nThe VWT enables Swift to manipulate values of unknown concrete type — copy, move, destroy — without knowing the type at compile time.\n\nProtocol Witness Table (PWT):\nMaps protocol requirements to concrete implementations:\n- One entry per protocol method/property/subscript requirement\n- Contains function pointers to the concrete type's implementations\n- Associated type entries (type metadata pointers)\n- Conditional conformance entries when applicable\n\nExample flow for `(value as any Equatable) == other`:\n1. Look up PWT for Equatable\n2. Find the `==` entry in the PWT\n3. Use the VWT to project the value from the existential buffer\n4. Call the concrete `==` implementation via the PWT function pointer\n\nPerformance implications:\n- Existentials require indirect calls (dynamic dispatch via PWT)\n- Values > 24 bytes cause heap allocation\n- No specialization possible — generic code using `some` is much more efficient\n- Copy/move operations go through VWT indirection\n\nClass existentials are simpler: the inline buffer stores the class reference (1 word), and the class's vtable provides dispatch. The existential still needs PWT pointers for protocol dispatch."
  },
  {
    "topic": "swift",
    "level": 5,
    "question": "How does Swift's ABI stability work? Explain library evolution, resilience, and the implications of @frozen, @inlinable, and @usableFromInline.",
    "hint": "Think about how Swift maintains binary compatibility across framework versions while still allowing optimization.",
    "answer": "Swift achieved ABI stability in Swift 5.0, meaning binaries compiled with different Swift versions can interoperate. Library evolution builds on this to allow frameworks to evolve without recompiling clients.\n\nABI stability guarantees:\n- Fixed calling conventions, type layout, name mangling\n- The Swift runtime ABI is locked and backward compatible\n- Standard library ships with the OS, not with each app\n\nLibrary evolution (resilience):\nWhen a library enables evolution (@_spi or Build Libraries for Distribution), it assumes types may change between versions:\n\nResilient types (default for public library types):\n- Size/layout of structs is NOT known at compile time\n- Enum cases may be added (non-frozen)\n- Classes may add stored properties\n- Access to properties goes through accessor functions, not direct memory offset\n- This enables the library to change internal layout without breaking clients\n\n@frozen:\n- Opts out of resilience for a specific type\n- The compiler can know the exact size/layout at compile time\n- Enables direct field access, inline storage, exhaustive switches\n- Cannot add/remove/reorder stored properties or enum cases ever\n- Used for performance-critical types: Optional, Array.Index, etc.\n\n@inlinable:\n- Makes the function body available to clients at compile time\n- Enables cross-module inlining and specialization\n- The function body becomes part of the ABI — changing it requires recompilation of clients\n- Should only be used for stable, performance-critical code\n\n@usableFromInline:\n- Makes an internal declaration visible to @inlinable code\n- The declaration itself is not public API, but its existence is ABI\n- Allows inlinable functions to reference internal types/methods\n\nPerformance trade-offs:\nWithout @frozen/@inlinable:\n- Struct field access goes through getter/setter accessors (indirect)\n- Function calls go through a thunk (no inlining across modules)\n- Type sizes are looked up at runtime via value witness tables\n\nWith @frozen/@inlinable:\n- Direct memory access, inlining, constant folding\n- But the library cannot change these without breaking binary compatibility\n\nExample:\n@frozen\npublic struct Point {\n    public var x: Double  // Layout is fixed: offset 0\n    public var y: Double  // Layout is fixed: offset 8\n    \n    @inlinable\n    public var magnitude: Double {\n        (x * x + y * y).squareRoot()  // Can be inlined into client code\n    }\n}\n\nIn practice, only the standard library and OS frameworks use library evolution extensively. App code doesn't need to worry about resilience since it compiles everything together (whole-module optimization can see all layouts)."
  },
  {
    "topic": "swift",
    "level": 5,
    "question": "How does the Swift compiler implement generic specialization? What is the difference between specialized and unspecialized generic code, and when does each occur?",
    "hint": "Think about the compile-time and runtime strategies for generics: monomorphization vs witness-table-based polymorphism.",
    "answer": "Swift's generics are compiled using two strategies: specialization (monomorphization) and generic sharing (unspecialized polymorphism).\n\nSpecialized generic code:\n- The compiler creates a separate copy of the function for each concrete type used\n- Similar to C++ templates\n- Enables all value-type optimizations: inlining, constant propagation, stack allocation\n- No runtime overhead — as fast as manually written non-generic code\n\nfunc max<T: Comparable>(_ a: T, _ b: T) -> T { a > b ? a : b }\nmax(1, 2)       // Compiler generates max_Int(Int, Int) -> Int\nmax(3.14, 2.0)  // Compiler generates max_Double(Double, Double) -> Double\n\nUnspecialized (shared) generic code:\n- A single implementation handles all types using value witness tables and protocol witness tables\n- Values are passed as opaque buffers with their VWT\n- Protocol requirements are called through PWT indirection\n- Heap allocation may be needed for types that don't fit the inline buffer (3 words)\n\nWhen specialization occurs:\n1. Same module: Always specialized with whole-module optimization (-O, -Osize)\n2. @inlinable functions: Can be specialized across modules (body is available)\n3. Internal/private generics: Always specializable within the module\n4. Without optimization (-Onone): May not specialize (for faster compilation)\n\nWhen specialization does NOT occur:\n1. Public functions across module boundaries without @inlinable\n2. When the concrete type is not known at compile time (existentials)\n3. When optimization is disabled\n4. Recursive generics that would cause infinite specialization\n\nThe compiler's specialization pipeline:\n1. SIL (Swift Intermediate Language) generation with generic signatures\n2. Mandatory passes (before optimization)\n3. Generic specializer pass: clones function body, substitutes concrete types\n4. Dead code elimination removes unused generic versions\n5. Function signature optimization on specialized versions\n6. LLVM backend further optimizes the specialized code\n\nPerformance difference:\n// Unspecialized: ~5-10x slower due to:\n// - Indirect calls through witness tables\n// - No inlining of protocol methods\n// - Potential heap allocation for large values\n// - No constant folding/propagation across generic boundaries\n\n// Specialized: Zero overhead — equivalent to handwritten code\n\nDesign implications:\n- For library authors: Mark hot-path generic functions @inlinable to enable cross-module specialization\n- For app code: Whole-module optimization handles it automatically\n- Generics with `some` (opaque types) always enable specialization since the concrete type is known\n- Generics with `any` (existentials) are never specialized — they always use dynamic dispatch"
  },
  {
    "topic": "swift",
    "level": 5,
    "question": "Explain how Swift's ownership model works with borrowing, consuming, and the ~Copyable (non-copyable types) feature. What problems do they solve?",
    "hint": "Swift 5.9+ introduced move-only types and explicit ownership annotations for fine-grained control over value lifetimes and copies.",
    "answer": "Swift's ownership model introduces explicit control over how values are passed and when copies happen, culminating in non-copyable types (~Copyable).\n\nOwnership annotations (Swift 5.9+):\n\nborrowing — the function borrows the value (read-only, no copy):\nfunc inspect(_ value: borrowing LargeStruct) {\n    print(value.data)  // Can read, cannot mutate or consume\n}\n\nconsuming — the function takes ownership (caller can no longer use it):\nfunc process(_ value: consuming LargeStruct) {\n    // value is now owned by this function\n    // Caller's copy is invalidated\n}\n\ninout — exclusive mutable access (existing Swift keyword, now part of ownership model):\nfunc modify(_ value: inout LargeStruct) {\n    value.count += 1  // Exclusive mutable borrow\n}\n\nNon-copyable types (~Copyable):\nSuppresses the implicit Copyable conformance that all Swift types normally have.\n\nstruct FileHandle: ~Copyable {\n    private let fd: Int32\n    \n    init(path: String) { fd = open(path, O_RDONLY) }\n    \n    consuming func close() {\n        Darwin.close(fd)\n        discard self  // Explicitly destroy without running deinit\n    }\n    \n    deinit {\n        Darwin.close(fd)  // Structs with ~Copyable can have deinit!\n    }\n}\n\nvar file = FileHandle(path: \"/tmp/data\")\n// let copy = file  // Compile error! Cannot copy a ~Copyable type\nfile.close()        // Consumes file — cannot use after this\n\nProblems solved:\n\n1. Unique ownership: Guarantee exactly one owner of a resource (files, locks, network connections)\n2. Move semantics: Eliminate unnecessary copies for large values\n3. Resource safety: deinit on structs ensures cleanup (RAII pattern)\n4. Compile-time use-after-move detection\n5. Performance: No reference counting overhead for unique resources\n\nGeneric interaction:\nfunc doSomething<T: ~Copyable>(_ value: borrowing T) { ... }\n// Works with both copyable and non-copyable types\n\nfunc needsCopy<T>(_ value: T) { ... }\n// Implicit T: Copyable — won't accept ~Copyable types\n\nCurrent limitations:\n- Non-copyable types cannot conform to most existing protocols (they assume Copyable)\n- Limited standard library support\n- Cannot be used in arrays or other generic collections yet\n- Pattern matching is limited\n- Still evolving — expect more features in future Swift versions\n\nThe ownership model brings Rust-like move semantics to Swift in an incremental, backward-compatible way. Existing code continues to work because all types are implicitly Copyable."
  },
  {
    "topic": "swift",
    "level": 5,
    "question": "How does the Swift runtime implement reference counting? Explain the object header layout, side tables, and weak/unowned reference mechanics.",
    "hint": "Swift objects have an inline refcount field that can be in one of several states, including a pointer to a side table for weak references.",
    "answer": "Swift's reference counting is implemented in the object header with an inline refcount that can optionally spill to a side table.\n\nObject header layout (HeapObject):\n- Word 1: Metadata pointer (isa-like, points to type metadata including vtable)\n- Word 2: InlineRefCounts — a single 64-bit field encoding multiple counters\n\nInlineRefCounts encoding (64 bits):\nThe refcount word can be in one of two states:\n\n1. Inline state (no side table):\n- Bits 0-30: Unowned reference count (strong RC + unowned RC)\n- Bits 31-62: Strong reference count\n- Bit 63: Used/unused flag\n- No support for weak references in this state\n\n2. Side table pointer state:\n- Bit 62: Set to 1 to indicate side table mode\n- Remaining bits: Pointer to HeapObjectSideTableEntry\n\nSide table (HeapObjectSideTableEntry):\nAllocated lazily when the first weak reference is created:\n- Strong reference count\n- Unowned reference count\n- Weak reference count\n- Pointer back to the object\n\nStrong references:\n- Increment/decrement the strong count\n- When strong count reaches 0: object is deinitialized (deinit runs)\n- Object memory is NOT freed yet if unowned count > 0\n\nUnowned references:\n- Point directly to the object (like strong references)\n- Object stays allocated (but deinitialized) until unowned count reaches 0\n- Accessing an unowned reference after deinit triggers a fatal error (not undefined behavior)\n- Cheaper than weak references — no side table needed\n\nWeak references:\n- Point to the side table, not the object directly\n- When strong count reaches 0: all weak references are zeroed (set to nil) atomically by pointing through the side table\n- Side table survives until weak count reaches 0\n- More expensive: requires side table allocation, indirection through side table\n\nLifecycle:\n1. Live: strong > 0. Object is fully usable.\n2. Deiniting: strong == 0, deinit is running. Weak refs already nil. Unowned refs trap on access.\n3. Deinited: deinit complete, strong == 0, but unowned > 0. Object memory still allocated.\n4. Freed: unowned == 0. Object memory deallocated. Side table may persist for weak refs.\n5. Dead: weak == 0. Side table deallocated. Fully cleaned up.\n\nOptimizations:\n- Immortal objects (like type metadata) use a special refcount value that is never incremented/decremented\n- The compiler elides retain/release pairs when it can prove the reference is alive (guaranteed lifetime)\n- Copy-on-write uses isKnownUniquelyReferenced, which checks if strong count == 1\n- Atomic operations are used for thread safety, but the compiler uses non-atomic operations when it can prove single-threaded access\n\nComparison with Objective-C:\n- ObjC uses a global side table (hash map from object pointer to refcount) for extra counts\n- Swift's inline refcount avoids this lookup for the common case\n- Swift's unowned is safer than ObjC's unsafe_unretained (deterministic trap vs undefined behavior)"
  },
  {
    "topic": "observation",
    "level": 0,
    "question": "What is the Observation framework in Swift? How does it differ from Combine's ObservableObject?",
    "hint": "Think about which framework is newer and how it simplifies state observation in SwiftUI.",
    "answer": "The Observation framework (introduced in iOS 17 / Swift 5.9) provides a simpler and more efficient way to observe changes in objects compared to Combine's ObservableObject.\n\nCombine approach (old):\nclass UserModel: ObservableObject {\n    @Published var name: String = \"\"\n    @Published var age: Int = 0\n}\n\nstruct UserView: View {\n    @ObservedObject var model: UserModel\n    var body: some View {\n        Text(model.name)  // View re-evaluates when ANY @Published property changes\n    }\n}\n\nObservation approach (new):\n@Observable\nclass UserModel {\n    var name: String = \"\"\n    var age: Int = 0\n}\n\nstruct UserView: View {\n    var model: UserModel  // No wrapper needed!\n    var body: some View {\n        Text(model.name)  // View ONLY re-evaluates when 'name' changes\n    }\n}\n\nKey differences:\n1. No @Published needed — all stored properties are automatically observed\n2. No @ObservedObject/@StateObject needed in views — just use a plain property\n3. Fine-grained tracking — only properties actually read in body trigger updates (not all published properties)\n4. No Combine dependency — works independently of the Combine framework\n5. Works with SwiftUI's @Environment directly\n6. Simpler mental model — less boilerplate, fewer property wrappers to learn\n\nThe Observation framework is Apple's recommended approach going forward for new code targeting iOS 17+."
  },
  {
    "topic": "observation",
    "level": 0,
    "question": "How do you make a class observable using the @Observable macro? What does it generate?",
    "hint": "The @Observable macro transforms your class at compile time — think about what code it generates behind the scenes.",
    "answer": "@Observable is a macro applied to a class that automatically makes all stored properties observable.\n\nUsage:\n@Observable\nclass UserModel {\n    var name: String = \"Alice\"\n    var age: Int = 30\n}\n\nWhat the macro generates (expanded):\nclass UserModel {\n    @ObservationTracked var name: String = \"Alice\"\n    @ObservationTracked var age: Int = 30\n    \n    @ObservationIgnored private let _$observationRegistrar = ObservationRegistrar()\n    \n    internal nonisolated func access<Member>(\n        keyPath: KeyPath<UserModel, Member>\n    ) {\n        _$observationRegistrar.access(self, keyPath: keyPath)\n    }\n    \n    internal nonisolated func withMutation<Member, MutationResult>(\n        keyPath: KeyPath<UserModel, Member>,\n        _ mutation: () throws -> MutationResult\n    ) rethrows -> MutationResult {\n        try _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)\n    }\n}\nextension UserModel: Observable {}\n\nEach stored property's getter calls access(keyPath:) to register that it was read, and the setter is wrapped in withMutation(keyPath:) to notify observers of changes.\n\nKey points:\n- Only works with classes (not structs or enums)\n- All stored properties are tracked by default\n- Use @ObservationIgnored to exclude properties from tracking\n- Computed properties are tracked through their dependency on stored properties\n- The ObservationRegistrar manages the bookkeeping of observers"
  },
  {
    "topic": "observation",
    "level": 1,
    "question": "What is @Bindable and when do you use it instead of @Binding in SwiftUI with Observable objects?",
    "hint": "Think about how you create two-way bindings to properties of @Observable objects.",
    "answer": "@Bindable is a property wrapper introduced alongside the Observation framework that creates bindings to properties of @Observable objects.\n\nWhen you need two-way binding (e.g., TextField) with an @Observable object:\n\n@Observable\nclass FormModel {\n    var username: String = \"\"\n    var email: String = \"\"\n}\n\nstruct FormView: View {\n    @Bindable var model: FormModel  // Enables $ syntax for bindings\n    \n    var body: some View {\n        TextField(\"Username\", text: $model.username)\n        TextField(\"Email\", text: $model.email)\n    }\n}\n\nWithout @Bindable, you cannot use the $ prefix to get Binding<String> from model.username.\n\n@Bindable vs @Binding:\n- @Bindable: Wraps an entire @Observable object to enable creating bindings to its properties. The view owns or receives the observable object.\n- @Binding: A two-way reference to a single value owned by a parent view. Used for value types or individual properties.\n\nWhere to use each:\n- @Bindable: When you have an @Observable class and need to bind to its properties in the current view\n- @Binding: When a parent passes down a binding to a specific property\n- @State: When you own the @Observable object (SwiftUI manages lifecycle)\n\nExample of @State with Observable:\nstruct ParentView: View {\n    @State private var model = FormModel()  // Owns the object\n    \n    var body: some View {\n        FormView(model: model)  // model is already bindable via @State\n    }\n}\n\nNote: When @Observable objects are stored in @State or @Environment, they are already bindable — you only need @Bindable when receiving an observable object as a plain parameter."
  },
  {
    "topic": "observation",
    "level": 1,
    "question": "How do you use @Observable objects with SwiftUI's @Environment?",
    "hint": "You can inject observable objects into the environment without needing @EnvironmentObject.",
    "answer": "With the Observation framework, you can place @Observable objects directly in SwiftUI's @Environment, replacing the old @EnvironmentObject pattern.\n\nOld approach (Combine):\nclass Settings: ObservableObject {\n    @Published var theme: Theme = .light\n}\n\n// Injection:\n.environmentObject(settings)\n\n// Reading:\n@EnvironmentObject var settings: Settings\n\nNew approach (Observation):\n@Observable\nclass Settings {\n    var theme: Theme = .light\n}\n\n// Injection:\n.environment(settings)\n\n// Reading:\n@Environment(Settings.self) private var settings\n\nThe key differences:\n1. Use .environment(_:) instead of .environmentObject(_:)\n2. Use @Environment(Type.self) instead of @EnvironmentObject\n3. No need for separate ObservableObject conformance\n\nFor two-way bindings from an environment observable:\nstruct SettingsView: View {\n    @Environment(Settings.self) private var settings\n    \n    var body: some View {\n        @Bindable var settings = settings  // Local bindable wrapper\n        Toggle(\"Dark Mode\", isOn: $settings.isDarkMode)\n    }\n}\n\nThe local @Bindable rebinding is needed because @Environment itself doesn't support the $ binding syntax. This is a common pattern when working with Observation and SwiftUI's environment.\n\nBenefits over @EnvironmentObject:\n- Type-safe — crash at view creation if missing, not at runtime\n- Fine-grained updates — only re-renders when accessed properties change\n- Consistent with the rest of the Observation framework\n- No Combine dependency"
  },
  {
    "topic": "observation",
    "level": 2,
    "question": "How does the Observation framework track property access? Explain the mechanism behind fine-grained observation.",
    "hint": "Think about what happens when SwiftUI reads a property inside `body` — how does the framework know which properties were accessed?",
    "answer": "The Observation framework tracks property access at runtime using a registration mechanism that records which properties are read during observation.\n\nThe tracking mechanism:\n\n1. When SwiftUI is about to evaluate a view's body, it calls withObservationTracking:\nwithObservationTracking {\n    // The body closure — any property access here is tracked\n    let view = body  // Reading model.name registers keyPath \\.name\n} onChange: {\n    // Called when ANY tracked property changes\n    // SwiftUI uses this to schedule a view update\n}\n\n2. Inside the tracking closure, each property getter calls access(keyPath:):\nvar name: String {\n    get {\n        _$observationRegistrar.access(self, keyPath: \\.name)\n        return _name  // actual stored value\n    }\n}\n\n3. The ObservationRegistrar records: \"this observation context is tracking \\.name on this object\"\n\n4. When a property is set, withMutation notifies only the observation contexts tracking that specific property:\nvar name: String {\n    set {\n        _$observationRegistrar.withMutation(of: self, keyPath: \\.name) {\n            _name = newValue\n        }\n    }\n}\n\nWhy this is better than Combine:\n- Combine's @Published notifies ALL subscribers when ANY published property changes\n- Observation only notifies when the SPECIFIC properties that were READ change\n\nExample:\n@Observable class Model {\n    var name: String = \"\"     // read in body\n    var counter: Int = 0       // NOT read in body\n}\n\nstruct MyView: View {\n    var model: Model\n    var body: some View {\n        Text(model.name)  // Only 'name' is tracked\n    }\n}\n\nmodel.counter += 1  // Does NOT trigger view update (not tracked)\nmodel.name = \"New\"  // Triggers view update (tracked)\n\nNote: withObservationTracking's onChange fires only ONCE. SwiftUI re-registers tracking each time body is re-evaluated, creating a new tracking scope for the next change."
  },
  {
    "topic": "observation",
    "level": 2,
    "question": "What are the performance benefits of the Observation framework over Combine-based ObservableObject?",
    "hint": "Think about unnecessary view re-evaluations, publisher overhead, and the granularity of change tracking.",
    "answer": "The Observation framework provides several significant performance improvements over Combine's ObservableObject:\n\n1. Fine-grained change tracking:\n- ObservableObject: objectWillChange fires for ANY @Published property change, causing ALL observing views to re-evaluate body\n- Observation: Only views that READ the specific changed property re-evaluate\n\n@Observable class Model {\n    var title: String = \"\"      // 50 views read this\n    var counter: Int = 0        // 1 view reads this\n}\n// Changing counter only re-evaluates 1 view, not 50\n\n2. No publisher overhead:\n- ObservableObject uses Combine publishers (objectWillChange, @Published projections)\n- Each @Published property allocates a CurrentValueSubject\n- Observation uses lightweight registration — no Combine publishers, no subscriptions, no AnyCancellable management\n\n3. Reduced view hierarchy invalidation:\n- With ObservableObject, parent views re-evaluating can cascade to child views\n- With Observation, only views that actually accessed changed properties are invalidated\n- This dramatically reduces the number of view diffs SwiftUI must compute\n\n4. No unnecessary objectWillChange:\n- ObservableObject sends willChange even if the new value equals the old value\n- Observation's mutation tracking can be combined with Equatable checks\n\n5. Memory efficiency:\n- No per-property publisher allocation\n- No subscription bookkeeping (AnyCancellable sets)\n- The ObservationRegistrar is a single lightweight object\n\n6. Less boilerplate means fewer mistakes:\n- Forgetting @Published or using @ObservedObject vs @StateObject incorrectly caused bugs\n- Observation has fewer property wrappers to misuse\n\nReal-world impact: In apps with large observable models (20+ properties) observed by many views, switching from ObservableObject to @Observable can dramatically reduce unnecessary view updates, leading to smoother scrolling, lower CPU usage, and better battery life."
  },
  {
    "topic": "observation",
    "level": 2,
    "question": "How do you migrate from ObservableObject to the @Observable macro? What are the key changes?",
    "hint": "Think about removing Combine-specific property wrappers and adapting view code.",
    "answer": "Migration from ObservableObject to @Observable involves changes in both the model and view layers.\n\nModel changes:\n\nBefore:\nimport Combine\n\nclass UserModel: ObservableObject {\n    @Published var name: String = \"\"\n    @Published var email: String = \"\"\n    let id: UUID = UUID()  // Not published\n    private var cancellables = Set<AnyCancellable>()\n}\n\nAfter:\nimport Observation\n\n@Observable\nclass UserModel {\n    var name: String = \"\"\n    var email: String = \"\"\n    @ObservationIgnored let id: UUID = UUID()  // Excluded from tracking\n    // No cancellables needed\n}\n\nView changes:\n\nBefore:\nstruct UserView: View {\n    @ObservedObject var model: UserModel  // or @StateObject\n    \n    var body: some View {\n        TextField(\"Name\", text: $model.name)\n    }\n}\n\n// Environment:\n.environmentObject(model)\n@EnvironmentObject var model: UserModel\n\nAfter:\nstruct UserView: View {\n    @Bindable var model: UserModel  // For bindings\n    // Or just: var model: UserModel  // For read-only\n    \n    var body: some View {\n        TextField(\"Name\", text: $model.name)\n    }\n}\n\n// Environment:\n.environment(model)\n@Environment(UserModel.self) var model\n\nMigration checklist:\n1. Replace `ObservableObject` conformance with `@Observable` macro\n2. Remove all `@Published` property wrappers\n3. Add `@ObservationIgnored` for properties that should not trigger updates\n4. Remove Combine imports if no longer needed\n5. Replace `@StateObject` with `@State` for owned objects\n6. Replace `@ObservedObject` with `@Bindable` (for bindings) or plain var (read-only)\n7. Replace `@EnvironmentObject` with `@Environment(Type.self)`\n8. Replace `.environmentObject()` with `.environment()`\n9. Update any manual `objectWillChange.send()` calls\n\nGradual migration: You can use both patterns in the same app. @Observable objects and ObservableObject types can coexist during transition. However, a single class should use one approach, not both."
  },
  {
    "topic": "observation",
    "level": 3,
    "question": "What is withObservationTracking and how do you use it outside of SwiftUI? What are its limitations?",
    "hint": "Think about how you can observe changes in non-SwiftUI contexts — and note that the onChange callback fires only once.",
    "answer": "withObservationTracking is the core function that enables observation outside of SwiftUI. It tracks which observable properties are accessed and calls a callback when any of them change.\n\nSignature:\nfunc withObservationTracking<T>(\n    _ apply: () -> T,\n    onChange: @autoclosure () -> @Sendable () -> Void\n) -> T\n\nBasic usage:\n@Observable class Counter {\n    var count = 0\n    var name = \"Main\"\n}\n\nlet counter = Counter()\n\nwithObservationTracking {\n    print(counter.count)  // Tracks 'count'\n    // counter.name is NOT tracked because it's not accessed\n} onChange: {\n    print(\"count changed!\")  // Called on ANY change to 'count'\n}\n\ncounter.count += 1  // Triggers: \"count changed!\"\ncounter.count += 1  // NOT triggered — onChange fires only ONCE\n\nCritical limitation: onChange fires exactly once, then the observation is complete. To continuously observe, you must re-register:\n\nfunc observe() {\n    withObservationTracking {\n        print(counter.count)\n    } onChange: {\n        // Re-register on the next run loop tick\n        DispatchQueue.main.async {\n            observe()  // Re-establish tracking\n        }\n    }\n}\n\nOther limitations:\n1. The onChange callback is called BEFORE the property value updates (willSet semantics)\n2. onChange runs on the thread where the mutation occurs — not necessarily the main thread\n3. No way to know WHICH property changed — just that something tracked did\n4. Cannot get old/new values in onChange\n5. Re-registration creates a new tracking scope — properties accessed may differ\n\nSwiftUI handles these limitations internally by re-calling body (which re-registers tracking) whenever onChange fires. For non-SwiftUI code, you need to implement the re-registration loop yourself.\n\nUse cases outside SwiftUI:\n- Reactive data pipelines\n- Custom UI frameworks\n- Testing observable behavior\n- Logging/debugging property access patterns\n- Building reactive bindings for AppKit/UIKit"
  },
  {
    "topic": "observation",
    "level": 3,
    "question": "Why does @Observable only work with classes, not structs? What are the technical reasons and design trade-offs?",
    "hint": "Think about identity, mutation tracking, and how value types copy on assignment.",
    "answer": "@Observable is restricted to classes for several fundamental technical and design reasons:\n\n1. Identity and shared state:\nClasses have reference semantics — multiple views can observe the SAME instance. When a property changes, all observers see the change because they share the same reference.\n\nStructs are value types — each copy is independent. If a view received a copy of a struct, mutations to the original would not be visible to the view. There's no shared instance to observe.\n\n2. Mutation tracking requires stable identity:\nThe ObservationRegistrar tracks property access per-instance. Classes have stable identity (memory address). Structs can be copied freely, making it unclear which 'instance' is being tracked.\n\nvar model = MyStruct()  // original\nvar copy = model         // independent copy\n// Which one should observers track? They're different values.\n\n3. Property setter interception:\n@Observable works by injecting getter/setter logic via the macro. For classes, the setter mutates the shared instance and notifies observers. For structs, setting a property creates a new value — the observation registrar on the old value doesn't know about the new one.\n\n4. SwiftUI's observation flow:\nSwiftUI holds a reference to the observable object and re-evaluates body when changes occur. This model requires reference semantics. With value types, SwiftUI would need a different mechanism (which is what @State and @Binding already provide for value types).\n\n5. Design philosophy:\n- Value types + @State/@Binding = SwiftUI manages lifecycle and change detection via the view hierarchy\n- Reference types + @Observable = Objects manage their own observation, views subscribe\n\nThese are complementary approaches:\n- Small, view-local state: Use @State with value types\n- Shared state, business logic, services: Use @Observable classes\n\nIf you want observable-like behavior for value types, you would use @State (SwiftUI detects changes through the property wrapper's internal mechanics, not through the Observation framework). The struct's didSet is effectively captured by @State's wrapper."
  },
  {
    "topic": "observation",
    "level": 4,
    "question": "How does ObservationRegistrar work internally? Explain its role in the Observation framework's architecture.",
    "hint": "Think about how registrar tracks observers, manages property-level subscriptions, and coordinates with withObservationTracking.",
    "answer": "ObservationRegistrar is the core bookkeeping type that coordinates between observable objects and their observers.\n\nRole and responsibilities:\n1. Maintains a registry of active observations (which properties are being tracked by which observation contexts)\n2. Receives access notifications when properties are read during tracking\n3. Sends change notifications when properties are mutated\n4. Manages the lifecycle of observations (registration and teardown)\n\nInternal architecture:\n\nThe registrar maintains a storage structure (thread-safe) that maps:\n- Observation ID -> Set of tracked key paths\n- Key path -> Set of observation IDs with callbacks\n\nstruct ObservationRegistrar: Sendable {\n    private let storage: Storage  // Thread-safe internal storage\n    \n    func access<Subject: Observable, Member>(\n        _ subject: Subject,\n        keyPath: KeyPath<Subject, Member>\n    )\n    \n    func withMutation<Subject: Observable, Member, T>(\n        of subject: Subject,\n        keyPath: KeyPath<Subject, Member>,\n        _ mutation: () throws -> T\n    ) rethrows -> T\n}\n\nFlow during observation:\n\n1. withObservationTracking sets up a thread-local tracking context\n2. When a getter calls registrar.access(self, keyPath:):\n   - The registrar checks for an active tracking context (thread-local)\n   - If found, records: \"context X is tracking keyPath Y on this object\"\n   - Stores the onChange callback associated with this context\n3. Tracking closure returns — tracking context is frozen\n\nFlow during mutation:\n\n1. A setter calls registrar.withMutation(of:keyPath:mutation:)\n2. Before mutation (willSet semantics):\n   - Registrar looks up all observation contexts tracking this keyPath\n   - Calls each context's onChange callback\n   - Removes the observation (one-shot)\n3. The actual mutation executes\n\nThread safety:\n- ObservationRegistrar is Sendable\n- Internal storage uses locking (os_unfair_lock or similar) for thread-safe access\n- onChange callbacks may fire on any thread (the thread performing the mutation)\n- This is why SwiftUI must dispatch to the main thread for view updates\n\nThe registrar is stored as an @ObservationIgnored property on each @Observable class, meaning it doesn't trigger observation itself. Each observable instance has its own registrar, keeping the observation scope isolated per-object.\n\nDesign insight: The one-shot nature of observations keeps the registrar lean — no long-lived subscriptions to manage, no cancellation tokens, no memory leak risk from forgotten subscriptions."
  },
  {
    "topic": "observation",
    "level": 4,
    "question": "Compare the Observation framework with Key-Value Observing (KVO). What are the architectural differences and when might you still use KVO?",
    "hint": "Think about the Objective-C runtime, NSObject requirement, string-based vs type-safe observation, and framework interop.",
    "answer": "The Observation framework and KVO are both property observation mechanisms, but they differ fundamentally in architecture and usage.\n\nKVO (Key-Value Observing):\n- Built on the Objective-C runtime\n- Requires NSObject inheritance\n- Properties must be marked @objc dynamic\n- Uses runtime method swizzling (isa-swizzling) to intercept setters\n- Observers receive oldValue, newValue, and change kind\n- Observation is persistent until explicitly removed\n- Can observe nested key paths (e.g., \"address.city\")\n- String-based key paths (legacy) or Swift KeyPath (modern)\n\nclass User: NSObject {\n    @objc dynamic var name: String = \"\"\n}\n\nlet token = user.observe(\\.name, options: [.new, .old]) { user, change in\n    print(\"Changed from \\(change.oldValue) to \\(change.newValue)\")\n}\n\nObservation framework:\n- Pure Swift, no Objective-C runtime dependency\n- Works with any Swift class (no NSObject required)\n- Uses compile-time macro transformation, not runtime swizzling\n- Tracks which properties are READ, not which are observed explicitly\n- One-shot onChange callback (fires once, must re-register)\n- No old/new value in callback\n- Cannot observe specific key paths externally — tracking is automatic\n- Integrated with SwiftUI's rendering pipeline\n\nArchitectural differences:\n\n1. Registration model:\n   - KVO: Explicit — you choose which property to observe\n   - Observation: Implicit — the framework tracks what you read\n\n2. Change notification:\n   - KVO: Provides detailed change info (old, new, kind, indexes for arrays)\n   - Observation: Only signals that something changed, no details\n\n3. Lifetime:\n   - KVO: Persistent until removed (risk of crashes if not removed properly)\n   - Observation: One-shot, auto-cleaned\n\n4. Threading:\n   - KVO: Callback on the thread where mutation occurs\n   - Observation: Same, but SwiftUI handles main-thread dispatch\n\n5. Performance:\n   - KVO: Objective-C message dispatch overhead, isa-swizzling\n   - Observation: Lighter weight, no runtime manipulation\n\nWhen KVO is still needed:\n- Observing UIKit/AppKit properties (UIScrollView.contentOffset, etc.)\n- Observing system framework objects (AVPlayer.status, etc.)\n- When you need old and new values in the callback\n- When working with Objective-C interop\n- Observing CoreData managed objects\n- When persistent (not one-shot) observation is required without SwiftUI\n\nIn modern Swift code, prefer Observation for your own types and KVO only for observing system framework properties that require it."
  },
  {
    "topic": "observation",
    "level": 5,
    "question": "Explain the internals of ObservationTracking. How does the thread-local tracking context work, and how does SwiftUI integrate with it to achieve minimal view invalidation?",
    "hint": "Think about thread-local storage, the tracking closure's execution model, and how SwiftUI re-establishes tracking on each body evaluation.",
    "answer": "ObservationTracking is the internal mechanism that connects property access during body evaluation to SwiftUI's view invalidation system.\n\nThread-local tracking context:\n\nWhen withObservationTracking is called, it sets up a thread-local tracking context:\n\n1. A ThreadLocal<ObservationTracking> (or _ThreadLocal via Swift runtime) is set before the apply closure runs\n2. Every @Observable property getter checks this thread-local for an active context:\n   func access<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>) {\n       if let tracking = _ThreadLocal.currentTracking {\n           tracking.register(subject: subject, keyPath: keyPath)\n       }\n   }\n3. The tracking context accumulates: [(object, keyPath, registrar)] tuples\n4. After the apply closure returns, the thread-local is cleared\n5. For each registered (object, keyPath), the onChange callback is installed in the object's registrar\n\nInternal data structures:\nstruct ObservationTracking {\n    var entries: [ObjectIdentifier: Entry]  // Per-object tracking\n    \n    struct Entry {\n        weak var object: AnyObject?  // The observable object\n        var registrar: ObservationRegistrar\n        var trackedKeyPaths: Set<AnyKeyPath>\n        var onChange: @Sendable () -> Void\n    }\n}\n\nSwiftUI integration:\n\nSwiftUI's rendering engine wraps each view's body evaluation:\n\n// Pseudocode of SwiftUI's internal flow:\nfunc evaluateBody<V: View>(of view: V) -> some View {\n    let result = withObservationTracking {\n        view.body  // All @Observable property accesses are tracked\n    } onChange: {\n        // Schedule this view for re-evaluation\n        MainActor.assumeIsolated {\n            setNeedsUpdate(for: view)  // Marks view dirty\n        }\n    }\n    return result\n}\n\nMinimal invalidation flow:\n\n1. View body is evaluated. Only properties actually READ are tracked.\n   - If body reads model.title but not model.subtitle, only title is tracked\n2. onChange is a one-shot callback installed per-view\n3. When model.title changes:\n   a. The registrar finds onChange callbacks for \\.title\n   b. Fires each callback (on the mutating thread)\n   c. SwiftUI receives the invalidation signal\n   d. SwiftUI schedules a re-render of ONLY this view\n4. On re-render, body is evaluated again inside a new withObservationTracking\n   - New tracking scope may track different properties (conditional UI)\n\nSubtle behaviors:\n\n- Conditional tracking: If body has `if showDetails { Text(model.details) }`, the details keyPath is only tracked when showDetails is true. On next change, if showDetails becomes false, details is no longer tracked.\n\n- Computed property tracking: If model has `var fullName: String { firstName + \" \" + lastName }`, reading fullName tracks both firstName AND lastName (since the computed getter accesses both stored properties).\n\n- Nested observation: If model.address is also @Observable, accessing model.address.city tracks city on the address object, not on model. SwiftUI handles this with separate tracking registrations.\n\n- Transaction batching: Multiple property changes in the same run loop tick are coalesced — SwiftUI only re-evaluates once even if multiple tracked properties changed.\n\nThis architecture gives SwiftUI O(changed properties) invalidation instead of O(total observed objects), which is the fundamental performance win over the ObservableObject approach where objectWillChange invalidated all subscribers regardless of which property changed."
  },
  {
    "topic": "observation",
    "level": 5,
    "question": "How would you implement manual observation without the @Observable macro? Build an observable type using ObservationRegistrar directly.",
    "hint": "Think about what the macro expands to — you need to manually implement the Observable protocol, set up the registrar, and instrument each property's getter and setter.",
    "answer": "You can implement observation manually by conforming to the Observable protocol and using ObservationRegistrar directly. This is exactly what the @Observable macro generates.\n\nimport Observation\n\nclass ManualModel: Observable {\n    // 1. The registrar manages observation bookkeeping\n    private let _$observationRegistrar = ObservationRegistrar()\n    \n    // 2. Actual storage (backing fields)\n    private var _name: String = \"Default\"\n    private var _count: Int = 0\n    private var _items: [String] = []\n    \n    // 3. Instrumented property: name\n    var name: String {\n        get {\n            access(keyPath: \\.name)\n            return _name\n        }\n        set {\n            withMutation(keyPath: \\.name) {\n                _name = newValue\n            }\n        }\n    }\n    \n    // 4. Instrumented property: count\n    var count: Int {\n        get {\n            access(keyPath: \\.count)\n            return _count\n        }\n        set {\n            withMutation(keyPath: \\.count) {\n                _count = newValue\n            }\n        }\n    }\n    \n    // 5. Instrumented property: items\n    var items: [String] {\n        get {\n            access(keyPath: \\.items)\n            return _items\n        }\n        set {\n            withMutation(keyPath: \\.items) {\n                _items = newValue\n            }\n        }\n    }\n    \n    // 6. Non-observed property (equivalent to @ObservationIgnored)\n    var identifier: UUID = UUID()  // No instrumentation\n    \n    // 7. Required protocol methods\n    internal nonisolated func access<Member>(\n        keyPath: KeyPath<ManualModel, Member>\n    ) {\n        _$observationRegistrar.access(self, keyPath: keyPath)\n    }\n    \n    internal nonisolated func withMutation<Member, MutationResult>(\n        keyPath: KeyPath<ManualModel, Member>,\n        _ mutation: () throws -> MutationResult\n    ) rethrows -> MutationResult {\n        try _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)\n    }\n}\n\nUsage — works identically to @Observable:\nlet model = ManualModel()\n\n// In SwiftUI:\nstruct MyView: View {\n    var model: ManualModel\n    var body: some View {\n        Text(model.name)  // Tracked via access(keyPath:)\n    }\n}\n\n// Outside SwiftUI:\nwithObservationTracking {\n    print(model.name)  // Registers tracking for \\.name\n} onChange: {\n    print(\"Name changed\")\n}\n\nmodel.name = \"Updated\"  // Triggers onChange\n\nWhy you might do this manually:\n- Educational understanding of the macro\n- Custom observation behavior (e.g., debouncing, validation in withMutation)\n- Adding observation to types where the macro cannot be applied\n- Fine-grained control over which mutations trigger observation\n- Adding observation to types in Objective-C bridging scenarios\n\nCustom behavior example — debounced observation:\nvar name: String {\n    get {\n        access(keyPath: \\.name)\n        return _name\n    }\n    set {\n        guard _name != newValue else { return }  // Skip if unchanged\n        withMutation(keyPath: \\.name) {\n            _name = newValue\n        }\n    }\n}\n\nThis skip-if-unchanged pattern prevents unnecessary view updates and is something the default @Observable macro does NOT do — it fires observation even for same-value assignments."
  },
  {
    "topic": "observation",
    "level": 3,
    "question": "When exactly does @Observable trigger a SwiftUI view update? What are the precise rules for when body is re-evaluated?",
    "hint": "Think about the timing of mutation notifications, the role of the run loop, and what happens with multiple rapid changes.",
    "answer": "SwiftUI's integration with the Observation framework follows specific rules about when view updates are triggered.\n\nTrigger rules:\n\n1. Only properties READ inside body (or its extracted subviews) are tracked. Properties accessed outside body — in onAppear, button actions, or task closures — are not tracked for view invalidation.\n\n2. The onChange callback fires synchronously on the thread that performs the mutation, using willSet semantics (before the value actually changes). SwiftUI then schedules a view re-evaluation on the main thread.\n\n3. Multiple property changes in the same run loop tick are coalesced into a single view update:\n@Observable class Model {\n    var first = \"\"\n    var last = \"\"\n}\nmodel.first = \"Alice\"  // Schedules update\nmodel.last = \"Smith\"   // Coalesced — still one update\n// body is evaluated ONCE, not twice\n\n4. Same-value assignments DO trigger onChange. The @Observable macro does not perform equality checks:\nmodel.name = \"Alice\"  // onChange fires\nmodel.name = \"Alice\"  // onChange fires AGAIN (same value)\n// This can cause unnecessary re-renders\n\n5. Computed properties trigger through their stored property dependencies:\n@Observable class Model {\n    var first = \"\"\n    var last = \"\"\n    var fullName: String { first + \" \" + last }  // Tracked via first and last\n}\n// Reading fullName in body tracks both 'first' and 'last'\n\n6. Conditional tracking — the set of tracked properties can change between evaluations:\nvar body: some View {\n    if model.showDetails {\n        Text(model.details)  // 'details' only tracked when showDetails is true\n    }\n}\n\n7. After onChange fires (one-shot), SwiftUI re-evaluates body inside a new withObservationTracking call, re-establishing tracking for the next change.\n\n8. Nested @Observable objects: If model.child is also @Observable, accessing model.child.name tracks 'name' on the child object independently. Replacing model.child entirely tracks 'child' on the parent.\n\nCommon pitfalls:\n- Accessing observable properties in closures passed to .task or .onAppear does NOT set up tracking\n- Printing model properties in body for debugging accidentally tracks them\n- Large observable models where body reads many properties lose the fine-grained benefit"
  },
  {
    "topic": "observation",
    "level": 4,
    "question": "How does the Observation framework handle concurrency and Sendability? What are the thread-safety guarantees of ObservationRegistrar and Observable objects?",
    "hint": "Think about @Observable classes being accessed from multiple threads, the Sendable conformance of ObservationRegistrar, and actor isolation.",
    "answer": "The Observation framework has specific concurrency characteristics that developers need to understand for safe multi-threaded usage.\n\nObservationRegistrar thread safety:\n- ObservationRegistrar conforms to Sendable\n- Its internal storage uses locking mechanisms (os_unfair_lock or equivalent) for thread-safe access\n- access() and withMutation() can be called from any thread safely\n- The registrar itself is safe, but the observable object's properties may not be\n\n@Observable class and Sendable:\n- @Observable classes do NOT automatically conform to Sendable\n- The generated access/withMutation methods are marked nonisolated\n- The registrar handles its own locking, but property access is not synchronized\n\nThread-safety scenario:\n@Observable class Counter {\n    var count = 0  // NOT thread-safe!\n}\n\n// Thread 1: counter.count += 1  // Data race!\n// Thread 2: counter.count += 1  // Data race!\n\nSolutions:\n\n1. @MainActor isolation:\n@Observable @MainActor\nclass Counter {\n    var count = 0  // Safe — all access is on main actor\n}\n\n2. Actor-based observable (requires careful design):\n// @Observable cannot be applied to actors directly\n// Instead, use a class with internal synchronization\n\n3. Manual synchronization:\n@Observable class ThreadSafeCounter {\n    @ObservationIgnored private var _count = 0\n    @ObservationIgnored private let lock = NSLock()\n    \n    var count: Int {\n        get {\n            access(keyPath: \\.count)\n            lock.lock()\n            defer { lock.unlock() }\n            return _count\n        }\n        set {\n            lock.lock()\n            let old = _count\n            lock.unlock()\n            guard old != newValue else { return }\n            withMutation(keyPath: \\.count) {\n                lock.lock()\n                _count = newValue\n                lock.unlock()\n            }\n        }\n    }\n}\n\nonChange callback threading:\n- The onChange callback fires on whatever thread the mutation occurs on\n- SwiftUI internally dispatches to the main thread for view updates\n- If you use withObservationTracking outside SwiftUI, your onChange may fire on any thread\n- You must handle main-thread dispatching yourself in non-SwiftUI contexts\n\nSwift 6 strict concurrency:\n- In Swift 6 mode, passing @Observable objects across isolation boundaries requires Sendable conformance\n- Most @Observable objects should be @MainActor-isolated since they typically serve the UI layer\n- For truly shared state, consider actor-mediated access patterns where the actor exposes values that are then set on a @MainActor @Observable model\n\nBest practice: Isolate @Observable objects to @MainActor for SwiftUI usage. For background processing, use actors or structured concurrency and update the observable model on the main actor when results are ready."
  },
  {
    "topic": "swiftui",
    "level": 0,
    "question": "What is the View protocol in SwiftUI and what is the role of the `body` property?",
    "hint": "Think about what every SwiftUI view must provide — a computed property that returns its visual content.",
    "answer": "The View protocol is the fundamental building block of SwiftUI. Every view in SwiftUI conforms to this protocol, which has a single requirement: a computed property called `body` that returns `some View`.\n\nThe `body` property describes the view's content and layout declaratively. SwiftUI calls this property whenever it needs to render or re-render the view. The `some View` return type uses an opaque return type, meaning the compiler knows the exact concrete type but it is hidden from the caller.\n\nKey points:\n- View is a protocol, not a class — SwiftUI views are typically structs, making them lightweight value types.\n- The body property is recomputed whenever the view's state changes.\n- SwiftUI uses a diffing mechanism to efficiently update only the parts of the UI that actually changed.\n- You should never call `body` directly; SwiftUI manages when and how it is invoked."
  },
  {
    "topic": "swiftui",
    "level": 0,
    "question": "What is @State in SwiftUI and when would you use it?",
    "hint": "Consider how a view can own and manage simple, local, mutable data that triggers UI updates when changed.",
    "answer": "@State is a property wrapper in SwiftUI that allows a view to own and manage a piece of mutable state. When a @State property changes, SwiftUI automatically re-renders the view to reflect the new value.\n\nKey characteristics:\n- @State is designed for simple value types (String, Int, Bool, etc.) that are private to a single view.\n- It should be marked `private` because the state is owned by the view and should not be accessed externally.\n- SwiftUI stores @State properties outside the struct's memory so that the value persists across re-renders, even though the struct itself may be recreated.\n- You can pass a binding to a @State property to child views using the `$` prefix (e.g., `$isOn`), which creates a two-way connection.\n\nExample:\n```swift\n@State private var username = \"\"\n```\n\nUse @State for local UI state like toggle values, text field content, or whether a sheet is presented."
  },
  {
    "topic": "swiftui",
    "level": 0,
    "question": "What is @Binding in SwiftUI and how does it differ from @State?",
    "hint": "Think about how a child view can read and write a value that is owned by a parent view.",
    "answer": "@Binding is a property wrapper that creates a two-way connection to a piece of state owned by another view. Unlike @State, which owns the data, @Binding provides a reference to state that lives elsewhere.\n\nKey differences from @State:\n- @State owns the source of truth; @Binding is a derived reference to someone else's source of truth.\n- @State is typically private to the view; @Binding is passed in from a parent.\n- When you modify a @Binding, the change propagates back to the original @State, causing both the parent and child views to re-render.\n\nHow to create a Binding:\n- Use the `$` prefix on a @State property to pass it as a Binding: `ChildView(value: $myState)`\n- You can also create custom bindings using `Binding(get:set:)`.\n\nExample:\n```swift\nstruct ToggleView: View {\n    @Binding var isOn: Bool\n    var body: some View {\n        Toggle(\"Enabled\", isOn: $isOn)\n    }\n}\n```"
  },
  {
    "topic": "swiftui",
    "level": 0,
    "question": "How do you present an alert, confirmation dialog, or sheet in SwiftUI?",
    "hint": "These are view modifiers that take a binding to a Boolean (or an optional item) to control presentation.",
    "answer": "SwiftUI uses view modifiers with Boolean bindings or optional item bindings to present alerts, confirmation dialogs, and sheets.\n\nAlert:\n```swift\n.alert(\"Title\", isPresented: $showAlert) {\n    Button(\"OK\") { }\n} message: {\n    Text(\"Something happened.\")\n}\n```\n\nConfirmation Dialog:\n```swift\n.confirmationDialog(\"Choose Action\", isPresented: $showDialog) {\n    Button(\"Delete\", role: .destructive) { delete() }\n    Button(\"Cancel\", role: .cancel) { }\n}\n```\n\nSheet:\n```swift\n.sheet(isPresented: $showSheet) {\n    DetailView()\n}\n```\n\nKey points:\n- All three use `isPresented: Binding<Bool>` or `item: Binding<Optional<Identifiable>>` to control visibility.\n- When the bound Boolean becomes true, the UI is presented. Dismissing sets it back to false.\n- The item-based variant is useful when you want to pass data to the presented view.\n- `.popover` works similarly but presents content in a popover bubble on iPad.\n- Sheets can be made non-dismissible using `.interactiveDismissDisabled(true)`."
  },
  {
    "topic": "swiftui",
    "level": 0,
    "question": "What is the difference between `.onAppear` and `.task` in SwiftUI?",
    "hint": "Both run code when a view appears, but one of them is specifically designed for async work and has automatic cancellation.",
    "answer": ".onAppear and .task are both view lifecycle modifiers that execute code when a view appears, but they have important differences.\n\n.onAppear:\n- Runs a synchronous closure when the view appears on screen.\n- Does not support async/await natively. You would need to wrap async calls in a Task manually.\n- The closure runs every time the view appears (e.g., when navigating back).\n- No automatic cancellation — any Task you create manually must be cancelled by you.\n\n.task:\n- Runs an async closure when the view appears.\n- Supports async/await directly, making it ideal for network calls and other async work.\n- Automatically cancels the task when the view disappears, preventing work from continuing after the view is gone.\n- Can also take an `id` parameter: `.task(id: searchText)` which restarts the task whenever the id value changes.\n\nWhen to use which:\n- Use .onAppear for simple synchronous setup (e.g., analytics tracking).\n- Use .task for any asynchronous work (e.g., fetching data, observing streams).\n- Prefer .task over manually creating a Task inside .onAppear because of the automatic cancellation behavior."
  },
  {
    "topic": "swiftui",
    "level": 1,
    "question": "What is the difference between @StateObject and @ObservedObject in SwiftUI?",
    "hint": "Consider which one owns the object's lifecycle and which one merely observes an externally-owned object.",
    "answer": "Both @StateObject and @ObservedObject are used with classes conforming to ObservableObject to drive SwiftUI view updates, but they differ in ownership semantics.\n\n@StateObject:\n- The view owns and creates the object.\n- SwiftUI ensures the object is created only once, even if the view struct is recreated during re-renders.\n- The object's lifecycle is tied to the view's identity — it persists as long as the view exists in the hierarchy.\n- Use it in the view that creates the object.\n\n@ObservedObject:\n- The view does not own the object — it is passed in from outside.\n- SwiftUI does not manage the object's lifecycle. If the parent view recreates the object, @ObservedObject will observe the new instance.\n- If used incorrectly to create an object (e.g., `@ObservedObject var vm = ViewModel()`), the object can be recreated unexpectedly when the view re-renders, losing state.\n\nRule of thumb:\n- Use @StateObject when the view is the creator and owner of the object.\n- Use @ObservedObject when the object is injected from a parent view or another source.\n- A common mistake is using @ObservedObject to instantiate an object inline — this leads to subtle bugs where state resets unexpectedly."
  },
  {
    "topic": "swiftui",
    "level": 1,
    "question": "Explain @EnvironmentObject and @Environment in SwiftUI. How do they differ?",
    "hint": "One injects a custom ObservableObject through the view hierarchy, the other reads system-provided or custom environment values.",
    "answer": "@EnvironmentObject and @Environment both read values from the SwiftUI environment, but they serve different purposes.\n\n@EnvironmentObject:\n- Used to inject a custom ObservableObject into the view hierarchy.\n- The object must be provided by an ancestor view using `.environmentObject(_:)`.\n- Any descendant view can read the object without it being passed explicitly through every intermediate view.\n- If the object is not provided, the app crashes at runtime.\n- The view re-renders when any @Published property of the object changes.\n\n@Environment:\n- Used to read built-in environment values provided by SwiftUI (e.g., colorScheme, locale, dismiss, openURL).\n- Accessed via a key path: `@Environment(\\.colorScheme) var colorScheme`.\n- You can define custom EnvironmentKey types to create your own environment values.\n- Environment values are typically lightweight value types, not reference-type objects.\n\nKey differences:\n- @EnvironmentObject works with ObservableObject classes; @Environment works with EnvironmentValues key paths.\n- @EnvironmentObject causes crashes if missing; @Environment values always have defaults.\n- With the Observation framework (iOS 17+), @Environment can also be used with @Observable classes, reducing the need for @EnvironmentObject."
  },
  {
    "topic": "swiftui",
    "level": 1,
    "question": "How do NavigationStack and .navigationDestination work in SwiftUI?",
    "hint": "Think about a data-driven navigation model where destinations are determined by the type of value pushed onto a navigation path.",
    "answer": "NavigationStack (introduced in iOS 16) provides a data-driven navigation model that replaces the older NavigationView.\n\nNavigationStack:\n- Manages a stack of views using an optional NavigationPath or a typed array.\n- You can use `NavigationStack(path: $path)` to bind the navigation state to a variable, enabling programmatic navigation.\n- NavigationPath is a type-erased collection that can hold heterogeneous Hashable values.\n\n.navigationDestination:\n- A modifier that associates a destination view with a data type.\n- When a value of that type is pushed onto the navigation path, SwiftUI presents the corresponding destination.\n\nExample:\n```swift\nNavigationStack(path: $path) {\n    List(items) { item in\n        NavigationLink(value: item) {\n            Text(item.name)\n        }\n    }\n    .navigationDestination(for: Item.self) { item in\n        DetailView(item: item)\n    }\n}\n```\n\nBenefits over NavigationView:\n- Deep linking is straightforward — you can set the entire path programmatically.\n- The navigation state is a plain data structure, making it easy to save and restore.\n- Multiple .navigationDestination modifiers can coexist for different types.\n- NavigationSplitView handles multi-column navigation for iPad and Mac."
  },
  {
    "topic": "swiftui",
    "level": 1,
    "question": "What are custom ViewModifiers in SwiftUI and how do you create one?",
    "hint": "Think about the ViewModifier protocol and how it lets you bundle reusable view transformations into a single modifier.",
    "answer": "A ViewModifier is a protocol that lets you encapsulate reusable view modifications into a single, named modifier. This promotes consistency and reduces code duplication.\n\nCreating a custom ViewModifier:\n```swift\nstruct CardModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(Color.white)\n            .cornerRadius(12)\n            .shadow(radius: 4)\n    }\n}\n```\n\nUsing it:\n```swift\nText(\"Hello\")\n    .modifier(CardModifier())\n```\n\nFor a cleaner API, extend View:\n```swift\nextension View {\n    func cardStyle() -> some View {\n        modifier(CardModifier())\n    }\n}\n\nText(\"Hello\").cardStyle()\n```\n\nKey points:\n- ViewModifiers can have their own properties and @State, allowing them to be configurable and stateful.\n- They receive a `Content` parameter representing the view being modified.\n- ViewModifiers compose well — you can chain multiple custom modifiers together.\n- They are the idiomatic way to create reusable styling in SwiftUI.\n- Unlike View extensions that return `some View`, ViewModifiers can carry state and respond to environment changes."
  },
  {
    "topic": "swiftui",
    "level": 1,
    "question": "What is the difference between List, LazyVStack, and LazyHGrid in SwiftUI?",
    "hint": "Consider the built-in features of List (like swipe actions and separators), the flexibility of LazyVStack for custom layouts, and LazyHGrid for grid-based horizontal layouts.",
    "answer": "List, LazyVStack, and LazyHGrid are all containers for displaying collections of views, but they serve different purposes.\n\nList:\n- A fully-featured component with built-in support for separators, swipe actions, selection, editing mode, section headers/footers, and platform-appropriate styling.\n- Lazily loads its content by default.\n- Provides styles like .plain, .grouped, .insetGrouped, .sidebar.\n- Best for standard data lists where you want system-provided behaviors.\n\nLazyVStack:\n- A vertical stack that lazily creates its children as they scroll into view.\n- Must be placed inside a ScrollView.\n- No built-in separators, swipe actions, or selection — you build everything yourself.\n- Offers maximum flexibility for custom scrollable layouts.\n- Better performance for very large datasets compared to a regular VStack which eagerly creates all views.\n\nLazyHGrid:\n- Creates a horizontally scrolling grid of items.\n- Configured with an array of GridItem values that define the row layout.\n- Must be placed inside a horizontal ScrollView.\n- Useful for horizontally scrolling collections like image galleries or category chips.\n\nWhen to use which:\n- List: standard data presentation with built-in features.\n- LazyVStack: custom vertical scrolling layouts without List's opinions.\n- LazyHGrid: horizontally scrolling grid content.\n- LazyVGrid is the vertical counterpart of LazyHGrid for vertically scrolling grids."
  },
  {
    "topic": "swiftui",
    "level": 2,
    "question": "What is PreferenceKey in SwiftUI and how is it used for child-to-parent communication?",
    "hint": "Think about how a child view can pass data upward through the view hierarchy, the reverse direction of environment values.",
    "answer": "PreferenceKey is a mechanism for passing data from child views up to ancestor views in the SwiftUI hierarchy. It is the reverse of environment values (which flow downward).\n\nHow it works:\n1. Define a PreferenceKey:\n```swift\nstruct HeightPreferenceKey: PreferenceKey {\n    static var defaultValue: CGFloat = 0\n    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {\n        value = max(value, nextValue())\n    }\n}\n```\n\n2. Set the preference from a child:\n```swift\nText(\"Hello\")\n    .background(\n        GeometryReader { geo in\n            Color.clear.preference(\n                key: HeightPreferenceKey.self,\n                value: geo.size.height\n            )\n        }\n    )\n```\n\n3. Read the preference in an ancestor:\n```swift\n.onPreferenceChange(HeightPreferenceKey.self) { height in\n    self.contentHeight = height\n}\n```\n\nKey points:\n- The `reduce` function combines values from multiple children (e.g., taking the max, summing, or collecting into an array).\n- `defaultValue` is used when no child sets the preference.\n- Common use cases: measuring child sizes, coordinating layout across siblings, building custom navigation bars, anchor preferences for positioning.\n- `anchorPreference` is a variant that works with Anchor<T> for geometry-based coordination.\n- Preferences are collected during the layout pass, so they are available after the view tree is resolved."
  },
  {
    "topic": "swiftui",
    "level": 2,
    "question": "How does GeometryReader work and what are its common pitfalls?",
    "hint": "Consider that GeometryReader proposes all available space to its children and how this can cause unexpected layout behavior.",
    "answer": "GeometryReader is a container view that provides its content closure with a GeometryProxy containing information about the available space and coordinate system.\n\nWhat GeometryProxy provides:\n- `size`: the size proposed by the parent.\n- `safeAreaInsets`: the safe area insets.\n- `frame(in:)`: the frame in a given coordinate space (.local, .global, .named).\n\nUsage:\n```swift\nGeometryReader { proxy in\n    Circle()\n        .frame(width: proxy.size.width * 0.5)\n}\n```\n\nCommon pitfalls:\n1. **Greedy sizing**: GeometryReader takes all proposed space (like Color or Spacer), which can unexpectedly expand views. Wrapping a small view in GeometryReader will make it fill all available space.\n2. **Top-left alignment**: Content inside GeometryReader is aligned to the top-leading corner by default, unlike most containers that center content.\n3. **Layout loops**: Reading geometry and then using it to change state that affects layout can create infinite layout loops.\n4. **Performance**: Overusing GeometryReader causes extra layout passes. Prefer built-in modifiers like `.containerRelativeFrame` (iOS 17) when possible.\n5. **Not a layout tool**: GeometryReader should be used for reading geometry, not as a primary layout mechanism.\n\nBest practices:\n- Use it in a background or overlay to measure without affecting layout.\n- Prefer `containerRelativeFrame` for proportional sizing on iOS 17+.\n- Avoid storing GeometryProxy — read values immediately in the closure."
  },
  {
    "topic": "swiftui",
    "level": 2,
    "question": "Explain implicit animations, explicit animations, and matchedGeometryEffect in SwiftUI.",
    "hint": "Consider the difference between `.animation()` modifier, `withAnimation {}`, and how matchedGeometryEffect creates hero transitions between views.",
    "answer": "SwiftUI provides multiple animation mechanisms with different scopes and use cases.\n\nImplicit animations (`.animation` modifier):\n- Applied to a view and automatically animate any changes to the specified value.\n```swift\nCircle()\n    .offset(x: moved ? 100 : 0)\n    .animation(.spring, value: moved)\n```\n- The animation applies to all animatable properties of that view that change when the tracked value changes.\n- Scoped to the view and its subtree.\n\nExplicit animations (`withAnimation`):\n- Wraps a state change, and any view that depends on the changed state animates.\n```swift\nwithAnimation(.easeInOut) {\n    moved.toggle()\n}\n```\n- Gives you precise control over which state changes are animated.\n- Can be applied to multiple state changes simultaneously.\n\nmatchedGeometryEffect:\n- Creates a seamless transition between two views by matching their geometry (position, size).\n- Both views share the same `id` and `@Namespace`.\n```swift\n@Namespace private var animation\n\nif isExpanded {\n    ExpandedView()\n        .matchedGeometryEffect(id: \"card\", in: animation)\n} else {\n    ThumbnailView()\n        .matchedGeometryEffect(id: \"card\", in: animation)\n}\n```\n- Only one view with a given id should be visible at a time (use `isSource: true/false` otherwise).\n- Combined with withAnimation, it creates hero-style transitions.\n- @Namespace must be declared in the view that owns both matched views."
  },
  {
    "topic": "swiftui",
    "level": 2,
    "question": "How does SwiftUI interop with UIKit using UIViewRepresentable and UIViewControllerRepresentable?",
    "hint": "Think about the lifecycle methods: makeUIView/makeUIViewController, updateUIView/updateUIViewController, and the Coordinator pattern.",
    "answer": "SwiftUI provides two protocols for embedding UIKit components: UIViewRepresentable for UIView subclasses and UIViewControllerRepresentable for UIViewControllers.\n\nUIViewRepresentable requires:\n```swift\nstruct MapView: UIViewRepresentable {\n    @Binding var region: MKCoordinateRegion\n\n    func makeUIView(context: Context) -> MKMapView {\n        let map = MKMapView()\n        map.delegate = context.coordinator\n        return map\n    }\n\n    func updateUIView(_ uiView: MKMapView, context: Context) {\n        uiView.setRegion(region, animated: true)\n    }\n\n    func makeCoordinator() -> Coordinator { Coordinator(self) }\n}\n```\n\nLifecycle:\n- `makeUIView(context:)` — called once to create the UIKit view.\n- `updateUIView(_:context:)` — called whenever SwiftUI state changes that the view depends on.\n- `dismantleUIView(_:coordinator:)` — optional cleanup when the view is removed.\n\nCoordinator:\n- Acts as the delegate, data source, or target-action handler for the UIKit view.\n- Created via `makeCoordinator()` and accessible through `context.coordinator`.\n- Bridges UIKit callbacks (delegate methods) back to SwiftUI state.\n\nUIViewControllerRepresentable works the same way but with `makeUIViewController` and `updateUIViewController`.\n\nKey considerations:\n- Avoid recreating expensive objects in `updateUIView` — only apply incremental updates.\n- Use the Coordinator to manage delegate patterns and prevent retain cycles.\n- sizeThatFits (iOS 16+) lets you control how the representable view is sized within SwiftUI layout."
  },
  {
    "topic": "swiftui",
    "level": 2,
    "question": "What is @FocusState and how does focus management work in SwiftUI?",
    "hint": "Think about controlling which text field has keyboard focus and how to programmatically move focus between fields.",
    "answer": "@FocusState is a property wrapper for managing input focus in SwiftUI. It lets you programmatically control which view has focus and respond to focus changes.\n\nBasic usage with a Boolean:\n```swift\n@FocusState private var isNameFocused: Bool\n\nTextField(\"Name\", text: $name)\n    .focused($isNameFocused)\n\nButton(\"Focus Name\") {\n    isNameFocused = true\n}\n```\n\nUsage with an enum for multiple fields:\n```swift\nenum Field: Hashable {\n    case email, password, confirmPassword\n}\n\n@FocusState private var focusedField: Field?\n\nTextField(\"Email\", text: $email)\n    .focused($focusedField, equals: .email)\nSecureField(\"Password\", text: $password)\n    .focused($focusedField, equals: .password)\n```\n\nKey features:\n- Setting the @FocusState value programmatically moves focus to the corresponding field.\n- Setting it to nil (for optional enum) or false (for Boolean) dismisses the keyboard.\n- You can use `.onSubmit` to move focus when the user taps return.\n- `.submitLabel(.next)` or `.submitLabel(.done)` customizes the return key.\n\nFocus management tips:\n- Use the enum pattern when you have multiple fields for clean navigation.\n- Combine with `.onSubmit` for form-like field-to-field navigation.\n- @FocusState only works within the same view hierarchy — it does not cross sheet or navigation boundaries.\n- On macOS, focus management extends to buttons and other focusable controls via `.focusable()`."
  },
  {
    "topic": "swiftui",
    "level": 3,
    "question": "Explain the Layout protocol in SwiftUI and how you create a custom layout container.",
    "hint": "Think about the two required methods: sizeThatFits and placeSubviews, and how they receive proxy objects for each subview.",
    "answer": "The Layout protocol (iOS 16+) lets you create fully custom container views that participate in SwiftUI's layout system. It gives you complete control over how child views are sized and positioned.\n\nRequired methods:\n```swift\nstruct FlowLayout: Layout {\n    var spacing: CGFloat = 8\n\n    func sizeThatFits(\n        proposal: ProposedViewSize,\n        subviews: Subviews,\n        cache: inout ()\n    ) -> CGSize {\n        // Calculate and return the total size needed\n        // by examining each subview's ideal size\n    }\n\n    func placeSubviews(\n        in bounds: CGRect,\n        proposal: ProposedViewSize,\n        subviews: Subviews,\n        cache: inout ()\n    ) -> Void {\n        // Position each subview within bounds\n        // using subview.place(at:proposal:)\n    }\n}\n```\n\nSubviews proxy:\n- `subviews[i].sizeThatFits(.unspecified)` — gets the ideal size.\n- `subviews[i].sizeThatFits(proposal)` — gets the size for a specific proposal.\n- `subviews[i].place(at:anchor:proposal:)` — positions the subview.\n- `subviews[i][CustomLayoutValue.self]` — reads custom layout values from children.\n\nCache:\n- An optional associated type `Cache` allows precomputing layout data to avoid redundant calculations.\n- Implement `makeCache(subviews:)` and `updateCache(_:subviews:)` for performance.\n\nUsage:\n```swift\nFlowLayout(spacing: 10) {\n    ForEach(tags) { tag in\n        TagView(tag: tag)\n    }\n}\n```\n\nThe Layout protocol enables flow layouts, masonry grids, radial layouts, and any custom arrangement that built-in containers cannot express."
  },
  {
    "topic": "swiftui",
    "level": 3,
    "question": "How do PhaseAnimator and KeyframeAnimator work in SwiftUI?",
    "hint": "PhaseAnimator cycles through discrete phases with animations between them, while KeyframeAnimator provides fine-grained control over individual properties along a timeline.",
    "answer": "PhaseAnimator and KeyframeAnimator (iOS 17+) provide advanced animation capabilities beyond simple state-driven animations.\n\nPhaseAnimator:\n- Cycles through a sequence of phases, applying different view modifications at each phase.\n- Each transition between phases uses its own animation curve.\n```swift\nPhaseAnimator([false, true]) { phase in\n    Image(systemName: \"bell\")\n        .rotationEffect(.degrees(phase ? 15 : -15))\n        .scaleEffect(phase ? 1.2 : 1.0)\n} animation: { phase in\n    phase ? .easeInOut(duration: 0.3) : .easeInOut(duration: 0.3)\n}\n```\n- Can be triggered continuously or by a `trigger` value change.\n- Good for simple multi-step animations like pulsing, wiggling, or attention effects.\n\nKeyframeAnimator:\n- Provides timeline-based control over multiple animatable properties simultaneously.\n- Each property has its own keyframe track with precise timing.\n```swift\nKeyframeAnimator(initialValue: AnimationValues()) { values in\n    Image(systemName: \"star\")\n        .scaleEffect(values.scale)\n        .rotationEffect(values.rotation)\n        .offset(y: values.yOffset)\n} keyframes: { _ in\n    KeyframeTrack(\\.scale) {\n        SpringKeyframe(1.5, duration: 0.3)\n        SpringKeyframe(1.0, duration: 0.2)\n    }\n    KeyframeTrack(\\.rotation) {\n        LinearKeyframe(.degrees(360), duration: 0.5)\n    }\n}\n```\n\nKeyframe types: LinearKeyframe, SpringKeyframe, CubicKeyframe, MoveKeyframe.\n\nWhen to use which:\n- PhaseAnimator: simple multi-state animations with discrete phases.\n- KeyframeAnimator: complex, choreographed animations with independent property timelines.\n- Both are declarative and composable, fitting naturally into SwiftUI's paradigm."
  },
  {
    "topic": "swiftui",
    "level": 3,
    "question": "How do ScrollViewReader, scrollPosition, and containerRelativeFrame improve scroll view behavior in SwiftUI?",
    "hint": "Think about programmatic scrolling, tracking scroll position, and sizing views relative to the scroll container.",
    "answer": "SwiftUI provides several tools for advanced scroll view control.\n\nScrollViewReader (iOS 14+):\n- Wraps a ScrollView and provides a `ScrollViewProxy` for programmatic scrolling.\n```swift\nScrollViewReader { proxy in\n    ScrollView {\n        ForEach(messages) { message in\n            MessageRow(message: message)\n                .id(message.id)\n        }\n    }\n    .onAppear {\n        proxy.scrollTo(messages.last?.id, anchor: .bottom)\n    }\n}\n```\n- Uses view identifiers to scroll to specific items.\n\nscrollPosition (iOS 17+):\n- Binds the scroll view's position to a state variable, enabling two-way tracking.\n```swift\n@State private var position: ScrollPosition = .init(idType: Item.ID.self)\n\nScrollView {\n    LazyVStack {\n        ForEach(items) { item in\n            ItemRow(item: item).id(item.id)\n        }\n    }\n}\n.scrollPosition($position)\n```\n- Enables reading which item is currently visible.\n- Supports programmatic scrolling by setting the position.\n\ncontainerRelativeFrame (iOS 17+):\n- Sizes a view relative to its nearest scroll container (or screen).\n```swift\nImage(\"photo\")\n    .containerRelativeFrame(.horizontal) { length, axis in\n        length * 0.8\n    }\n```\n- Replaces many GeometryReader use cases for proportional sizing.\n- Works with both axes and can apply to width, height, or both.\n\nTogether these APIs make it possible to build sophisticated scrolling experiences like carousels, chat interfaces, and paginated content without dropping to UIKit."
  },
  {
    "topic": "swiftui",
    "level": 3,
    "question": "What is the .searchable modifier in SwiftUI and how does it integrate with NavigationStack?",
    "hint": "Consider how .searchable adds a search bar to a navigation view and provides suggestions, tokens, and scopes.",
    "answer": ".searchable is a view modifier that adds a platform-appropriate search interface to a NavigationStack or NavigationSplitView.\n\nBasic usage:\n```swift\nNavigationStack {\n    List(filteredItems) { item in\n        Text(item.name)\n    }\n    .searchable(text: $searchText, prompt: \"Search items\")\n    .navigationTitle(\"Items\")\n}\n```\n\nSearch suggestions:\n```swift\n.searchable(text: $searchText) {\n    ForEach(suggestions) { suggestion in\n        Text(suggestion.name)\n            .searchCompletion(suggestion.name)\n    }\n}\n```\n\nSearch scopes (iOS 16+):\n```swift\n.searchScopes($scope) {\n    Text(\"All\").tag(SearchScope.all)\n    Text(\"Recent\").tag(SearchScope.recent)\n}\n```\n\nSearch tokens (iOS 16+):\n```swift\n.searchable(text: $searchText, tokens: $tokens) { token in\n    Label(token.name, systemImage: token.icon)\n}\n```\n\nKey features:\n- Placement is automatic and platform-appropriate (navigation bar on iOS, toolbar on macOS).\n- `@Environment(\\.isSearching)` tells you if the search bar is active.\n- `@Environment(\\.dismissSearch)` dismisses the search programmatically.\n- `.onSubmit(of: .search)` handles the search button tap.\n- Filtering logic is your responsibility — .searchable only provides the UI.\n- The modifier must be inside a NavigationStack or NavigationSplitView to work correctly.\n- On iOS, it automatically integrates with the navigation bar's scroll behavior."
  },
  {
    "topic": "swiftui",
    "level": 3,
    "question": "How do custom shapes and paths work in SwiftUI?",
    "hint": "Think about the Shape protocol, its `path(in:)` method, and how you can use Path to draw arbitrary shapes with lines, curves, and arcs.",
    "answer": "SwiftUI's Shape protocol lets you create custom drawable shapes that integrate seamlessly with the view system.\n\nThe Shape protocol:\n```swift\nstruct Star: Shape {\n    var points: Int = 5\n    var innerRatio: CGFloat = 0.4\n\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let outerRadius = min(rect.width, rect.height) / 2\n        let innerRadius = outerRadius * innerRatio\n        // Calculate points and draw star\n        return path\n    }\n}\n```\n\nPath drawing primitives:\n- `path.move(to:)` — move the pen without drawing.\n- `path.addLine(to:)` — draw a straight line.\n- `path.addArc(center:radius:startAngle:endAngle:clockwise:)` — draw an arc.\n- `path.addCurve(to:control1:control2:)` — cubic Bezier curve.\n- `path.addQuadCurve(to:control:)` — quadratic Bezier curve.\n- `path.closeSubpath()` — close the current subpath.\n\nUsing shapes:\n```swift\nStar(points: 5)\n    .fill(.yellow)\n    .stroke(.orange, lineWidth: 2)\n    .frame(width: 100, height: 100)\n```\n\nAnimatable shapes:\n- Conform to `Shape` (which inherits from `Animatable`).\n- Implement `var animatableData: AnimatablePair<CGFloat, CGFloat>` to animate shape properties.\n- SwiftUI interpolates the animatableData between old and new values, calling `path(in:)` for each frame.\n\nShapes can be used as clip masks (`.clipShape`), backgrounds, or overlays, and they are resolution-independent because they are vector-based."
  },
  {
    "topic": "swiftui",
    "level": 4,
    "question": "Explain view identity in SwiftUI: structural identity vs explicit identity, and how they affect view lifecycle and state preservation.",
    "hint": "Think about how SwiftUI identifies views in the hierarchy — by their position in the view tree (structural) or by an explicit identifier (.id()) — and what happens to @State when identity changes.",
    "answer": "View identity is one of the most fundamental concepts in SwiftUI and directly affects state preservation, animations, and performance.\n\nStructural identity:\n- SwiftUI identifies views by their position in the view tree (their type and location in the body hierarchy).\n- In a conditional (if/else), the true branch and false branch have different structural identities.\n```swift\nif isLoggedIn {\n    HomeView() // identity A\n} else {\n    LoginView() // identity B\n}\n```\n- Switching between branches destroys one view (and its state) and creates another.\n- Using a single branch with modifiers preserves identity: `ContentView().opacity(isVisible ? 1 : 0)` keeps the same view.\n\nExplicit identity:\n- Assigned via `.id(_:)` modifier or `ForEach`.\n- When the id value changes, SwiftUI treats it as a completely new view — destroying the old one and creating a new one.\n```swift\nDetailView(item: item)\n    .id(item.id) // Forces complete recreation when item changes\n```\n- This resets all @State in the view and its subtree.\n\nImplications:\n- AnyView breaks structural identity because the concrete type is erased, making it harder for SwiftUI to diff efficiently.\n- Using stable, unique identifiers in ForEach (not array indices) is critical for correct animations and state preservation.\n- Changing a view's identity triggers transition animations.\n- @State is tied to identity — when identity changes, state resets to initial values.\n- SwiftUI uses _ViewInputs to propagate identity through the view tree during the attribute graph evaluation.\n\nBest practices:\n- Prefer structural identity (conditional modifiers) over conditional views when possible.\n- Use .id() intentionally when you want to force a view reset.\n- Avoid AnyView — use @ViewBuilder, Group, or generics instead to preserve structural identity."
  },
  {
    "topic": "swiftui",
    "level": 4,
    "question": "What are the performance pitfalls of AnyView and how can you avoid them?",
    "hint": "Consider how type erasure prevents SwiftUI from performing efficient structural diffing, and what alternatives (like @ViewBuilder, generic views, Group) preserve type information.",
    "answer": "AnyView is a type-erased wrapper that hides the concrete type of a view. While it solves type system constraints, it has significant performance implications.\n\nPerformance problems with AnyView:\n1. **Lost structural identity**: SwiftUI relies on compile-time type information to build its attribute graph and efficiently diff views. AnyView erases this information, forcing SwiftUI to fall back to slower comparison strategies.\n2. **Unnecessary view destruction/recreation**: Without type information, SwiftUI may not recognize that two AnyView-wrapped views are the same type, causing it to destroy and recreate views unnecessarily instead of updating them in place.\n3. **Missed diffing optimizations**: SwiftUI can skip diffing subtrees when it knows the type hasn't changed. AnyView prevents this optimization.\n4. **Animation issues**: View transitions and animations depend on identity. AnyView can cause unexpected animation behavior because identity tracking is compromised.\n\nAlternatives to AnyView:\n\n1. **@ViewBuilder**: Allows returning different types from conditionals.\n```swift\n@ViewBuilder\nvar content: some View {\n    if isGrid { GridView() }\n    else { ListView() }\n}\n```\n\n2. **Group**: Wraps heterogeneous views without type erasure.\n\n3. **Generic views**: Pass view types as generic parameters.\n```swift\nstruct Container<Content: View>: View {\n    let content: () -> Content\n}\n```\n\n4. **Separate ViewModifiers**: Instead of conditionally swapping views, use conditional modifiers on a single view.\n\nWhen AnyView is acceptable:\n- Rarely needed since @ViewBuilder supports up to 10 conditional branches.\n- Plugin architectures where view types are truly unknown at compile time.\n- Never in performance-critical paths like list cells or frequently re-rendered views.\n\nThe key insight is that SwiftUI's performance model depends heavily on static type information, and AnyView undermines this by design."
  },
  {
    "topic": "swiftui",
    "level": 4,
    "question": "How does @Namespace work with matchedGeometryEffect and what are the subtleties of using it across different view hierarchies?",
    "hint": "Think about how @Namespace provides a coordinate space for matching views, the isSource parameter, and how to pass namespaces between views.",
    "answer": "@Namespace is a property wrapper that creates a namespace identifier used to coordinate matchedGeometryEffect across views.\n\nHow @Namespace works:\n```swift\n@Namespace private var heroAnimation\n```\n- It creates a unique identifier that connects views sharing the same matchedGeometryEffect id within that namespace.\n- The namespace is scoped to the view that declares it.\n\nThe isSource parameter:\n```swift\n.matchedGeometryEffect(id: \"avatar\", in: namespace, isSource: true)\n```\n- When two views with the same id exist simultaneously, `isSource: true` designates which view defines the geometry (size and position).\n- The non-source view adjusts its frame to match the source.\n- Default is `true`, which works when only one view is visible at a time (if/else pattern).\n- When both views are visible (e.g., during a drag operation), you must explicitly set isSource on one.\n\nPassing namespaces between views:\n- A parent can pass a Namespace.ID to child views.\n```swift\nstruct ParentView: View {\n    @Namespace private var animation\n    var body: some View {\n        ChildA(namespace: animation)\n        ChildB(namespace: animation)\n    }\n}\nstruct ChildA: View {\n    var namespace: Namespace.ID\n}\n```\n\nSubtleties and gotchas:\n- matchedGeometryEffect only works within the same view hierarchy — it cannot match across sheets, popovers, or navigation stacks.\n- The id must be Hashable and consistent — changing the id breaks the match.\n- For list-to-detail hero transitions, you need to ensure the source view is still in the hierarchy when the destination appears (use opacity instead of removing).\n- Combining with `.transition(.asymmetric(...))` can create richer animations.\n- On iOS 18+, NavigationTransition protocol provides more structured hero transitions using matchedGeometryEffect.\n- Performance: each matched pair adds overhead to the layout pass, so avoid matching large numbers of views simultaneously."
  },
  {
    "topic": "swiftui",
    "level": 4,
    "question": "How does SwiftUI avoid unnecessary view redraws, and what techniques can you use to optimize rendering performance?",
    "hint": "Think about the attribute graph, Equatable conformance, dependency tracking on observed objects, and techniques like extracting subviews and using EquatableView.",
    "answer": "SwiftUI uses an internal dependency graph (attribute graph) to track which views depend on which state, minimizing unnecessary re-evaluations of `body`.\n\nHow SwiftUI avoids redraws:\n1. **Dependency tracking**: SwiftUI records which properties each view's body actually reads. When state changes, only views that depend on the changed property have their body re-evaluated.\n2. **Value comparison**: Before re-rendering, SwiftUI compares the view's input values. If they haven't changed, the body evaluation is skipped.\n3. **Structural identity**: SwiftUI uses the type-based view tree to determine which views exist and whether they've changed.\n\nOptimization techniques:\n\n1. **Extract subviews**: Break large bodies into smaller views. Each subview becomes an independent node in the dependency graph.\n```swift\n// Bad: entire body re-evaluates when any state changes\n// Good: only TimerView re-evaluates when time changes\nstruct TimerView: View {\n    let time: Date\n    var body: some View { Text(time.formatted()) }\n}\n```\n\n2. **Equatable conformance**: Conform views to `Equatable` and use `.equatable()` modifier (or EquatableView wrapper) to skip body evaluation when the view's properties haven't changed, even if the parent re-renders.\n\n3. **Minimize @ObservedObject scope**: A view observing an ObservableObject re-renders when any @Published property changes. Split large ObservableObjects into focused ones or use the Observation framework (@Observable, iOS 17+) which tracks individual property access.\n\n4. **Avoid dynamic type erasure**: AnyView, as discussed, prevents SwiftUI from optimizing diffs.\n\n5. **Lazy containers**: Use LazyVStack/LazyHStack to only create views that are visible.\n\n6. **Use `let` over computed properties for static data**: Views with only `let` properties can be compared more efficiently.\n\n7. **@Observable (iOS 17+)**: Tracks per-property access rather than per-object, dramatically reducing unnecessary redraws compared to ObservableObject.\n\n8. **Careful with closures**: Closures stored as properties always compare as not-equal, causing redraws. Use methods or extract into dedicated views."
  },
  {
    "topic": "swiftui",
    "level": 4,
    "question": "Explain sensory feedback in SwiftUI and how haptics integrate with the framework.",
    "hint": "Think about the .sensoryFeedback modifier, SensoryFeedback types, and UIFeedbackGenerator for more custom haptic patterns.",
    "answer": "SwiftUI provides built-in support for haptic feedback through the `.sensoryFeedback` modifier (iOS 17+) and lower-level UIKit haptic APIs.\n\n.sensoryFeedback modifier (iOS 17+):\n```swift\nButton(\"Submit\") {\n    submitForm()\n}\n.sensoryFeedback(.success, trigger: submissionState)\n```\n\nFeedback types:\n- `.success`, `.warning`, `.error` — outcome-based feedback.\n- `.selection` — light tap for selection changes.\n- `.impact` — physical impact sensation with weight options (.light, .medium, .heavy).\n- `.increase`, `.decrease` — for value adjustments.\n- `.start`, `.stop` — for activity state changes.\n- `.alignment`, `.levelChange` — for spatial interactions.\n\nTrigger-based activation:\n```swift\n.sensoryFeedback(.impact(weight: .heavy), trigger: dragOffset) { old, new in\n    abs(new - old) > threshold\n}\n```\n- The optional condition closure lets you control when feedback fires based on old and new trigger values.\n\nLower-level UIKit APIs:\n```swift\nlet generator = UIImpactFeedbackGenerator(style: .medium)\ngenerator.prepare() // Pre-warm the Taptic Engine\ngenerator.impactOccurred()\n```\n- UINotificationFeedbackGenerator for success/warning/error.\n- UISelectionFeedbackGenerator for selection changes.\n- Call `prepare()` before anticipated events to reduce latency.\n\nCustom haptic patterns (CoreHaptics):\n- CHHapticEngine allows designing complex haptic patterns with precise timing, intensity, and sharpness curves.\n- Useful for games or immersive experiences.\n\nBest practices:\n- Use semantic feedback types (.success, .error) rather than raw impact when an outcome is involved.\n- Do not overuse haptics — they should provide meaningful feedback, not be distracting.\n- Always provide visual feedback alongside haptic feedback for accessibility.\n- Haptics are automatically disabled when the user has reduced motion or haptics disabled in settings."
  },
  {
    "topic": "swiftui",
    "level": 5,
    "question": "How does SwiftUI's attribute graph work internally, and how does it drive view updates, layout, and rendering?",
    "hint": "Think about the directed acyclic graph of attributes, how dependencies are tracked lazily, and how changes propagate through the graph triggering minimal re-evaluation.",
    "answer": "SwiftUI's attribute graph (AG) is the runtime engine that powers the declarative framework. Understanding it helps explain SwiftUI's behavior and performance characteristics.\n\nStructure:\n- The attribute graph is a directed acyclic graph (DAG) where nodes represent attributes (state values, view body results, layout computations, render properties).\n- Edges represent dependencies between attributes.\n- When you write a view, SwiftUI compiles the body into a series of attribute nodes connected by their data dependencies.\n\nDependency tracking:\n- Dependencies are tracked lazily at runtime. When a view's body is evaluated, SwiftUI records which attributes (state, environment, preferences) were actually read.\n- This is more precise than compile-time analysis — if your body reads `@State var count` only inside an `if` block, the dependency is only registered when that branch executes.\n- The Observation framework (@Observable) leverages the same mechanism but at a per-property granularity instead of per-object.\n\nChange propagation:\n- When a state value changes, the corresponding attribute node is marked dirty.\n- SwiftUI walks forward through the graph, marking downstream nodes as potentially dirty.\n- During the next update cycle, only dirty nodes are re-evaluated (lazy evaluation).\n- If a re-evaluated node produces the same result as before, propagation stops — downstream nodes remain clean.\n\nUpdate cycle:\n1. **Event** — user interaction, timer, or async completion changes state.\n2. **Transaction** — the change is recorded with an optional animation.\n3. **Attribute graph update** — dirty nodes are re-evaluated; new body results are diffed against old.\n4. **Layout pass** — the render tree is updated with new sizes and positions.\n5. **Render** — changed layers are committed to Core Animation.\n\nLayout integration:\n- Layout is also expressed as attribute nodes. The proposed size flows down, the returned size flows up.\n- Preferences flow up (child to parent); environment flows down (parent to child).\n- GeometryReader creates a dependency on the layout attributes of its parent.\n\nPerformance implications:\n- Smaller view bodies create fewer attribute nodes and finer-grained dependencies.\n- @ObservedObject creates a dependency on the entire object (any @Published change triggers re-evaluation); @Observable tracks individual properties.\n- AnyView collapses type information, preventing some graph optimizations.\n- The graph is thread-safe but updates are coalesced onto the main thread.\n\nDebugging:\n- `Self._printChanges()` in a view's body reveals which property caused the re-evaluation.\n- Instruments (SwiftUI template) shows view body evaluations, attribute graph size, and update timing."
  },
  {
    "topic": "swiftui",
    "level": 5,
    "question": "How do property wrappers in SwiftUI work under the hood, and what is the relationship between the wrapper's wrappedValue, projectedValue, and SwiftUI's update mechanism?",
    "hint": "Consider how @State stores its value outside the struct, how the DynamicProperty protocol integrates wrappers into the update cycle, and what projectedValue ($-prefix) provides for each wrapper.",
    "answer": "SwiftUI property wrappers are not just syntactic sugar — they are deeply integrated with SwiftUI's update mechanism through the DynamicProperty protocol.\n\nDynamicProperty protocol:\n- All SwiftUI property wrappers (@State, @Binding, @StateObject, @ObservedObject, @Environment, @FocusState, etc.) conform to DynamicProperty.\n- SwiftUI calls `update()` on DynamicProperty conformances before each body evaluation, allowing wrappers to synchronize with the attribute graph.\n- Custom property wrappers can conform to DynamicProperty to participate in SwiftUI's update cycle.\n\n@State internals:\n- The wrappedValue is not stored in the struct itself (structs are recreated frequently).\n- SwiftUI allocates external storage tied to the view's identity in the attribute graph.\n- On first body evaluation, the initial value is moved to external storage. Subsequent struct recreations do not reset it.\n- wrappedValue: the current value (get/set, setter triggers view update).\n- projectedValue ($state): a `Binding<Value>` for two-way data flow.\n\n@Binding internals:\n- Contains a get closure and a set closure — essentially a reference to someone else's storage.\n- wrappedValue: calls the getter/setter closures.\n- projectedValue ($binding): returns self (another Binding), enabling further propagation.\n\n@StateObject internals:\n- Uses a storage mechanism similar to @State, but holds a reference type (ObservableObject).\n- The `@autoclosure` in its initializer `StateObject(wrappedValue:)` ensures the object is only created once.\n- Subscribes to the object's objectWillChange publisher to trigger view updates.\n- projectedValue: an ObservedObject.Wrapper that provides Bindings to @Published properties.\n\n@ObservedObject internals:\n- Does NOT manage the object's lifecycle — it simply subscribes to objectWillChange.\n- If the parent view recreates the struct with a new object instance, @ObservedObject observes the new instance.\n- projectedValue: same ObservedObject.Wrapper as @StateObject.\n\n@Environment internals:\n- Reads from the environment values dictionary maintained in the attribute graph.\n- The key path determines which EnvironmentKey to look up.\n- When the environment value changes upstream, all views reading that key path are invalidated.\n\nCreating custom SwiftUI property wrappers:\n```swift\n@propertyWrapper\nstruct Debounced: DynamicProperty {\n    @State private var debouncedValue: String\n    @State private var task: Task<Void, Never>?\n    // ... implementation using DynamicProperty conformance\n}\n```\n\nThe DynamicProperty conformance is what makes SwiftUI \"aware\" of your wrapper. Without it, changing internal @State variables would not trigger view updates correctly because SwiftUI would not know to traverse into your wrapper during the update phase."
  },
  {
    "topic": "swiftui",
    "level": 5,
    "question": "How does SwiftUI's diffing algorithm work when comparing view trees, and how does this inform best practices for building performant view hierarchies?",
    "hint": "Think about how SwiftUI compares the old and new view trees structurally and by value, the role of generic view types, conditional content, and how ForEach uses identifiers.",
    "answer": "SwiftUI's diffing algorithm is central to its performance model. Unlike React's virtual DOM diffing, SwiftUI leverages Swift's strong type system for an efficient structural comparison.\n\nHow diffing works:\n\n1. **Type-based structural comparison**: SwiftUI compares the old and new view trees by their static structure (types). Because `body` returns `some View`, the compiler knows the exact concrete type (e.g., `VStack<TupleView<(Text, HStack<...>)>>`). This type encodes the entire view tree structure.\n\n2. **Conditional content**: `if/else` in a @ViewBuilder produces `_ConditionalContent<TrueContent, FalseContent>`. When the condition changes, SwiftUI knows to transition between the two branches rather than trying to diff across incompatible types.\n\n3. **Value comparison**: For views of the same type, SwiftUI compares their stored properties. If a view's inputs haven't changed, its body is not re-evaluated. This is why using `Equatable` conformance and `let` properties helps — they enable efficient equality checks.\n\n4. **ForEach and identity**: ForEach uses the id parameter to match items across updates. This is how SwiftUI knows that item \"A\" moved from position 0 to position 2, rather than treating it as three deletions and three insertions. Stable identifiers are critical for correct animations and state preservation.\n\n5. **Tuple views**: A VStack or HStack with static children compiles to a TupleView, where each child has a fixed position. Position 0 in the old tree is compared with position 0 in the new tree. This makes static layouts essentially O(1) to diff per child.\n\nPerformance implications:\n\n- **AnyView defeats type-based diffing**: Since the concrete type is erased, SwiftUI cannot use the type system to compare old vs new. It falls back to runtime comparison which is slower and can result in unnecessary view destruction.\n\n- **Avoid conditional view swapping for simple changes**: `Text(\"Hello\").foregroundColor(isError ? .red : .blue)` is far more efficient than `if isError { Text(\"Hello\").foregroundColor(.red) } else { Text(\"Hello\").foregroundColor(.blue) }` because the former preserves view identity.\n\n- **Stable ForEach identifiers**: Using array indices as identifiers causes every item to be diffed and potentially re-rendered when the array changes. Using model-level stable IDs enables precise insertions, deletions, and moves.\n\n- **@ViewBuilder branch limits**: @ViewBuilder supports up to 10 views in a closure. Each branch in a conditional creates a distinct path in the type. Deeply nested conditionals create exponentially complex types that increase compile time and attribute graph size.\n\n- **Generic view composition**: Using `some View` typed properties or generic parameters preserves type information. Extension methods returning `some View` are preferred over returning AnyView.\n\n- **Inert modifiers**: Modifiers like `.opacity(1.0)` or `.padding(0)` still add nodes to the view tree. While their visual effect is none, they increase the attribute graph size. Apply modifiers conditionally only when needed.\n\nThe key insight is that SwiftUI's performance relies heavily on the compiler's ability to see the exact type structure at compile time, which allows the runtime to make optimal diffing decisions."
  },
  {
    "topic": "swiftui",
    "level": 5,
    "question": "Describe the full rendering pipeline in SwiftUI from a state change to pixels on screen, including the role of the attribute graph, layout system, and Core Animation.",
    "hint": "Think about the complete chain: state mutation, transaction creation, attribute graph invalidation, body re-evaluation, layout negotiation, render tree update, and CALayer commit.",
    "answer": "The SwiftUI rendering pipeline is a multi-stage process that efficiently transforms declarative view descriptions into rendered pixels.\n\nStage 1: State mutation and transaction\n- A state change (e.g., @State, @Published) is detected by SwiftUI's storage mechanism.\n- A Transaction is created, carrying the animation context (if any). `withAnimation(.spring) { state = newValue }` creates a transaction with a spring animation.\n- The change is enqueued for processing on the main run loop.\n\nStage 2: Attribute graph invalidation\n- The attribute graph node corresponding to the changed state is marked dirty.\n- Forward edges are traversed to mark dependent nodes (body computations, derived values) as potentially dirty.\n- This is a lightweight marking phase — no actual computation happens yet.\n\nStage 3: Body re-evaluation\n- SwiftUI processes dirty nodes lazily. A dirty body node is re-evaluated by calling the view's body property.\n- During evaluation, dependency tracking records which attributes are read.\n- The result is a new view tree for that subtree.\n- SwiftUI diffs the new tree against the old tree using the type-based structural comparison.\n- If a node's re-evaluation produces the same result, downstream nodes are marked clean without further evaluation (short-circuit optimization).\n\nStage 4: View update\n- New views are inserted (with appear transitions), removed views are marked for removal (with disappear transitions).\n- View identities are resolved — structural identity for static content, explicit identity for ForEach and .id() content.\n- State for new views is initialized; state for removed views is cleaned up.\n\nStage 5: Layout negotiation\n- Layout follows a two-pass algorithm similar to UIKit's but declarative:\n  - **Proposal pass (top-down)**: Parents propose sizes to children. The proposed size flows down through the view tree.\n  - **Response pass (bottom-up)**: Children return their actual size. Leaf views (Text, Image) determine their ideal size based on the proposal. Container views aggregate children's sizes.\n- Custom Layout protocol types participate directly in this negotiation.\n- The layout pass produces concrete frames (CGRect) for every view.\n\nStage 6: Render tree update\n- SwiftUI maintains a render tree separate from the view tree. The render tree maps to actual display list entries.\n- Changed frames, colors, opacity, transforms, and other visual properties are applied to corresponding render nodes.\n- Animations are resolved: the transaction's animation is applied to interpolate between old and new values over time.\n\nStage 7: Core Animation commit\n- SwiftUI's render tree is backed by CALayer instances (on Apple platforms).\n- Changed properties are committed to Core Animation's render server process.\n- Core Animation handles the actual compositing and rendering on the GPU.\n- Animated properties use CAAnimation under the hood, with SwiftUI managing the timing curves.\n\nStage 8: Display\n- The render server composites all layers and presents the frame at the next display refresh (typically 60Hz or 120Hz on ProMotion).\n- For animations, the pipeline from Stage 6 onward repeats each frame, with SwiftUI providing interpolated values.\n\nOptimization throughout:\n- Each stage has short-circuit paths to avoid unnecessary work.\n- The attribute graph's lazy evaluation means only changed subtrees are processed.\n- Layout caching means unchanged subtrees are not re-measured.\n- Core Animation's implicit layer tree management handles efficient GPU compositing.\n\nThis pipeline runs synchronously on the main thread for the CPU-bound phases (stages 1-6), with GPU rendering happening asynchronously. This is why keeping body evaluations fast and minimizing attribute graph size directly impacts frame rates."
  },
  {
    "topic": "swiftui",
    "level": 5,
    "question": "How does the Observation framework (@Observable) in iOS 17 change SwiftUI's dependency tracking compared to ObservableObject, and what are the implications for architecture?",
    "hint": "Think about per-property tracking vs per-object tracking, the elimination of @Published, and how this affects view update granularity and the need for view model decomposition.",
    "answer": "The Observation framework (iOS 17+) fundamentally changes how SwiftUI tracks dependencies on reference-type models, moving from per-object to per-property granularity.\n\nObservableObject (old model):\n- Views subscribe to the object's `objectWillChange` publisher.\n- When ANY @Published property changes, ALL views observing that object re-evaluate their body.\n- This leads to over-invalidation: a view that only reads `user.name` is re-evaluated when `user.avatarURL` changes.\n- Mitigation strategies included splitting large view models into smaller ones and using derived Bindings.\n\n@Observable (new model):\n```swift\n@Observable\nclass UserModel {\n    var name: String = \"\"\n    var avatarURL: URL?\n    var settings: Settings = .default\n}\n```\n- No @Published needed — all stored properties are automatically tracked.\n- SwiftUI tracks which specific properties a view's body actually accesses.\n- If a view only reads `model.name`, it is only invalidated when `name` changes.\n- This is achieved through the `ObservationTracking` module which uses access tracking (similar to how @State tracks dependencies).\n\nMechanism:\n- The @Observable macro rewrites property access to go through an observation registrar.\n- When SwiftUI evaluates a view's body, it uses `withObservationTracking {}` to record which properties are accessed.\n- Each property mutation calls `willSet`/`didSet` hooks that notify only the specific observers that read that property.\n- This is O(properties accessed) rather than O(views observing the object).\n\nArchitectural implications:\n\n1. **Fewer view models needed**: With per-property tracking, a single large model no longer causes performance issues. You don't need to split `UserViewModel` into `UserNameViewModel` and `UserAvatarViewModel`.\n\n2. **Simpler injection**: Use `@Environment` instead of `@EnvironmentObject`. No need for separate `@StateObject`/`@ObservedObject` distinction for @Observable classes — just use `@State` for owned objects and plain `var`/`let` for injected ones.\n\n3. **Computed properties work naturally**: Computed properties that depend on stored properties are tracked transitively. If `var fullName: String { \"\\(first) \\(last)\" }` is accessed, both `first` and `last` become dependencies.\n\n4. **Collections are efficient**: Accessing `model.items.count` only invalidates when the count changes, not when individual items are modified (assuming items are value types or themselves @Observable).\n\n5. **Nested observation**: @Observable objects can reference other @Observable objects. SwiftUI tracks across the entire access chain: `model.user.address.city` creates a dependency on the `city` property specifically.\n\nCaveats:\n- The observation registrar adds a small overhead to every property access, though this is typically negligible.\n- Existential types (`any Observable`) lose some tracking precision.\n- You must still be mindful of which properties you access in body — accessing too many properties on a rapidly changing model can still cause frequent updates.\n- Mixing ObservableObject and @Observable in the same hierarchy requires care to avoid confusion about which mechanism is in use.\n\nThe Observation framework represents a significant improvement in SwiftUI's reactivity model, bringing it closer to fine-grained reactivity systems like those in Solid.js or MobX, while maintaining Swift's type safety."
  },
  {
    "topic": "combine",
    "level": 0,
    "question": "What is the Publisher protocol in Combine and what role does it play?",
    "hint": "Think about what a Publisher represents — a type that can emit a sequence of values over time, along with a possible completion or error.",
    "answer": "The Publisher protocol is the foundation of Apple's Combine framework. A Publisher declares that it can emit a sequence of values over time and eventually complete (either successfully or with an error).\n\nKey aspects of Publisher:\n- It has two associated types: `Output` (the type of values it emits) and `Failure` (the error type, or `Never` if it cannot fail).\n- Publishers are declarative — they describe what will happen but do not start emitting values until a Subscriber subscribes.\n- Publishers are value types (typically structs), making them lightweight to create and compose.\n\nCommon built-in publishers:\n- `Just(value)` — emits a single value and completes.\n- `[1, 2, 3].publisher` — emits each element of a sequence.\n- `NotificationCenter.default.publisher(for:)` — emits notifications.\n- `URLSession.shared.dataTaskPublisher(for:)` — emits network responses.\n- `Timer.publish(every:on:in:)` — emits at regular intervals.\n\nThe publisher-subscriber pattern:\n1. A Subscriber subscribes to a Publisher.\n2. The Publisher sends a Subscription to the Subscriber.\n3. The Subscriber requests values (demand).\n4. The Publisher sends values and eventually a completion event.\n\nPublishers are composable through operators (map, filter, flatMap, etc.), allowing you to build complex data pipelines declaratively."
  },
  {
    "topic": "combine",
    "level": 0,
    "question": "What is AnyCancellable and why is it important for memory management in Combine?",
    "hint": "Think about what happens to a subscription when no one holds a reference to its cancellable token.",
    "answer": "AnyCancellable is a type-erased wrapper around any Cancellable. It is crucial for managing the lifecycle of Combine subscriptions.\n\nKey concepts:\n- When you call `.sink` or `.assign` on a publisher, it returns an `AnyCancellable` instance.\n- This object represents the active subscription. If it is deallocated, the subscription is automatically cancelled.\n- You must store the AnyCancellable for as long as you want the subscription to remain active.\n\nCommon storage patterns:\n```swift\nclass MyViewModel {\n    private var cancellables = Set<AnyCancellable>()\n\n    func observe() {\n        somePublisher\n            .sink { value in\n                // Handle value\n            }\n            .store(in: &cancellables)\n    }\n}\n```\n\nWhy it matters:\n- If you do not store the AnyCancellable, the subscription is immediately cancelled and no values are received.\n- Using `Set<AnyCancellable>` is idiomatic because the `.store(in:)` method makes it easy to add cancellables to a set.\n- When the object holding the set is deallocated, all subscriptions are automatically cancelled, preventing memory leaks and dangling callbacks.\n- You can manually call `.cancel()` on an AnyCancellable to end a subscription early.\n\nAnyCancellable implements the Cancellable protocol and calls `cancel()` in its deinit, providing automatic resource cleanup through Swift's ARC memory management."
  },
  {
    "topic": "combine",
    "level": 0,
    "question": "What are PassthroughSubject and CurrentValueSubject, and when would you use each?",
    "hint": "Consider which one stores the current value and which one simply relays values to subscribers.",
    "answer": "PassthroughSubject and CurrentValueSubject are both Subjects — types that are both a Publisher and a Subscriber, allowing you to imperatively send values into a Combine pipeline.\n\nPassthroughSubject:\n- Does NOT store any value. It simply passes through each value to current subscribers.\n- Subscribers only receive values sent after they subscribe.\n- Created with: `PassthroughSubject<String, Error>()`\n- Use when: you want to broadcast events (button taps, notifications, delegate callbacks) and there is no meaningful \"current\" value.\n\nCurrentValueSubject:\n- Stores the most recent value and immediately delivers it to new subscribers.\n- Initialized with a value: `CurrentValueSubject<Int, Never>(0)`\n- Access the current value via `.value` property.\n- Use when: you need to represent state that always has a current value (e.g., a settings value, loading state, user profile).\n\nCommon usage:\n```swift\nlet taps = PassthroughSubject<Void, Never>()\ntaps.send(()) // Fire and forget\n\nlet count = CurrentValueSubject<Int, Never>(0)\nprint(count.value) // 0\ncount.send(5)\nprint(count.value) // 5\n```\n\nBoth subjects:\n- Conform to `Subject`, which provides `send(_:)` and `send(completion:)`.\n- Are reference types (classes).\n- Can have multiple subscribers.\n- Send values synchronously to subscribers on the calling thread (unless a scheduler operator changes this)."
  },
  {
    "topic": "combine",
    "level": 0,
    "question": "What is @Published and how does it relate to Combine?",
    "hint": "Think about how @Published creates a publisher that emits values whenever the property changes.",
    "answer": "@Published is a property wrapper provided by Combine that automatically creates a publisher for a property. When the property's value changes, the publisher emits the new value.\n\nUsage:\n```swift\nclass UserSettings: ObservableObject {\n    @Published var username: String = \"\"\n    @Published var notificationsEnabled: Bool = true\n}\n```\n\nHow it works:\n- `@Published var name: String` creates a hidden publisher of type `Published<String>.Publisher`.\n- Access the publisher via the `$` prefix: `settings.$username` gives you a `Publisher` that emits String values.\n- The publisher emits on `willSet` — meaning subscribers receive the value before the property actually changes.\n- The Failure type is `Never` — @Published publishers cannot emit errors.\n\nRelationship with ObservableObject:\n- ObservableObject has an auto-synthesized `objectWillChange` publisher.\n- Any @Published property change automatically triggers `objectWillChange.send()`, which notifies SwiftUI to re-render.\n\nSubscribing to @Published:\n```swift\nsettings.$username\n    .debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n    .sink { newName in\n        print(\"Username changing to: \\(newName)\")\n    }\n    .store(in: &cancellables)\n```\n\nImportant notes:\n- @Published emits on willSet, not didSet. If you read the property inside the sink closure of $property, you get the old value.\n- @Published can only be used with classes (not structs).\n- In SwiftUI with the new @Observable macro (iOS 17+), @Published is no longer needed."
  },
  {
    "topic": "combine",
    "level": 1,
    "question": "Explain the map, flatMap, and switchToLatest operators in Combine and when you would use each.",
    "hint": "map transforms values, flatMap transforms into publishers, and switchToLatest cancels the previous inner publisher when a new one arrives.",
    "answer": "These three operators handle different types of transformations in Combine pipelines.\n\nmap:\n- Transforms each emitted value using a closure, similar to Array.map.\n- The output publisher has the same Failure type.\n```swift\n[1, 2, 3].publisher\n    .map { $0 * 2 } // Emits 2, 4, 6\n```\n- Use for simple, synchronous value transformations.\n\nflatMap:\n- Transforms each emitted value into a new Publisher, then flattens all inner publishers into a single output stream.\n- All inner publishers run concurrently (up to `maxPublishers` limit).\n```swift\nurls.publisher\n    .flatMap { url in\n        URLSession.shared.dataTaskPublisher(for: url)\n    }\n```\n- Use when each input value triggers an asynchronous operation that returns a publisher.\n- Danger: all inner publishers are active simultaneously, so results may arrive out of order.\n\nswitchToLatest:\n- Applied to a publisher of publishers. When a new inner publisher arrives, the previous one is cancelled.\n- Only the most recent inner publisher's values are emitted.\n```swift\nsearchText\n    .map { query in\n        apiService.search(query: query) // Returns a publisher\n    }\n    .switchToLatest() // Cancels previous search when new query arrives\n```\n- Use for search-as-you-type, where only the latest request matters.\n- Prevents race conditions where an older response arrives after a newer one.\n\nComparison:\n- map: 1 value in, 1 value out (synchronous transform).\n- flatMap: 1 value in, 0..N values out from inner publisher (concurrent).\n- switchToLatest: like flatMap but cancels previous, keeping only the latest (sequential).\n- flatMap(maxPublishers: .max(1)) behaves like a serial queue — processing one inner publisher at a time."
  },
  {
    "topic": "combine",
    "level": 1,
    "question": "How do combineLatest, zip, and merge differ in Combine?",
    "hint": "Think about how they combine values from multiple publishers — combineLatest emits when any publisher updates, zip pairs values one-to-one, and merge interleaves values.",
    "answer": "These three operators combine multiple publishers but with different semantics.\n\ncombineLatest:\n- Emits a tuple of the latest value from each publisher whenever any publisher emits a new value.\n- Requires all publishers to have emitted at least one value before the first combined emission.\n```swift\npublisherA.combineLatest(publisherB)\n    .sink { (a, b) in\n        // Called when A or B emits, with the latest values from both\n    }\n```\n- Use case: form validation — combine latest values of all fields to determine overall validity.\n\nzip:\n- Pairs values from publishers one-to-one in order. Emits only when all publishers have a new value.\n- The Nth emission contains the Nth value from each publisher.\n```swift\npublisherA.zip(publisherB)\n    .sink { (a, b) in\n        // a is the Nth value from A, b is the Nth value from B\n    }\n```\n- Waits for both sides to have a value before emitting.\n- Use case: coordinating two parallel async operations that should complete together.\n\nmerge:\n- Interleaves values from multiple publishers of the same Output type into a single stream.\n- Emits immediately when any source publisher emits.\n```swift\npublisherA.merge(with: publisherB)\n    .sink { value in\n        // value is from either A or B\n    }\n```\n- All publishers must have the same Output and Failure types.\n- Use case: combining multiple event sources (e.g., local and remote updates) into one stream.\n\nSummary:\n- combineLatest: any emits triggers output with latest from all (after initial).\n- zip: strict 1-to-1 pairing, waits for all.\n- merge: simple interleaving, same types only."
  },
  {
    "topic": "combine",
    "level": 1,
    "question": "What are Schedulers in Combine and how do you use them to control threading?",
    "hint": "Think about receive(on:) for downstream delivery and subscribe(on:) for upstream subscription, and the common scheduler types.",
    "answer": "Schedulers in Combine define where and when code executes. They abstract the concept of execution context (threads, dispatch queues, run loops).\n\nCommon schedulers:\n- `DispatchQueue.main` — executes on the main thread (for UI updates).\n- `DispatchQueue.global()` — executes on a background thread.\n- `RunLoop.main` — main run loop, similar to main queue but with different timing characteristics.\n- `ImmediateScheduler.shared` — executes synchronously and immediately (useful for testing).\n\nKey operators:\n\n`receive(on:)` — switches downstream delivery to a specific scheduler:\n```swift\nurlSession.dataTaskPublisher(for: url)\n    .map { $0.data }\n    .decode(type: User.self, decoder: JSONDecoder())\n    .receive(on: DispatchQueue.main) // UI updates below this\n    .sink { user in\n        self.user = user // Safe: on main thread\n    }\n```\n\n`subscribe(on:)` — specifies where the subscription and initial request happen:\n```swift\nexpensivePublisher\n    .subscribe(on: DispatchQueue.global())\n    .receive(on: DispatchQueue.main)\n    .sink { value in }\n```\n\nImportant distinctions:\n- `receive(on:)` affects everything downstream — all subsequent operators and the final subscriber run on that scheduler.\n- `subscribe(on:)` affects everything upstream — the publisher's subscription logic runs on that scheduler.\n- Multiple `receive(on:)` calls can switch context multiple times in a pipeline.\n- Time-based operators (debounce, throttle, delay) require a scheduler parameter to determine their timing source.\n\nTesting:\n- `ImmediateScheduler` makes all scheduling synchronous, simplifying tests.\n- Custom test schedulers allow manual time advancement for testing time-based operators."
  },
  {
    "topic": "combine",
    "level": 1,
    "question": "How does error handling work in Combine with catch, replaceError, and retry?",
    "hint": "Consider how catch replaces a failed publisher with a new one, replaceError substitutes a default value, and retry re-subscribes to attempt recovery.",
    "answer": "Combine has a strong error handling model where errors are part of the publisher's type signature. Several operators help manage errors gracefully.\n\ncatch:\n- Intercepts an error and replaces the failed publisher with a new publisher.\n- The original subscription ends, and the replacement publisher takes over.\n```swift\nurlSession.dataTaskPublisher(for: url)\n    .map(\\.data)\n    .decode(type: [Item].self, decoder: JSONDecoder())\n    .catch { error -> Just<[Item]> in\n        print(\"Error: \\(error)\")\n        return Just([]) // Provide empty fallback\n    }\n    .sink { items in /* ... */ }\n```\n- The replacement publisher must have the same Output type but can have a different (or Never) Failure type.\n\nreplaceError:\n- A simpler version of catch that replaces any error with a single default value, then completes.\n```swift\npublisher\n    .replaceError(with: \"Default Value\")\n```\n- Changes the Failure type to Never.\n\nretry:\n- Re-subscribes to the upstream publisher a specified number of times when an error occurs.\n```swift\nurlSession.dataTaskPublisher(for: url)\n    .retry(3) // Retry up to 3 times on failure\n    .catch { _ in Just(Data()) }\n```\n- Each retry creates a new subscription, so the upstream work (e.g., network request) is repeated.\n- The error is only forwarded downstream if all retries are exhausted.\n\nOther error operators:\n- `mapError` — transforms the error type.\n- `setFailureType(to:)` — adds an error type to a Never-failing publisher.\n- `tryMap`, `tryFilter`, etc. — throwing versions of standard operators that can introduce errors.\n\nBest practice: handle errors as close to the source as possible, and ensure the final subscriber receives a Never-failing publisher when possible (using catch or replaceError)."
  },
  {
    "topic": "combine",
    "level": 2,
    "question": "What is backpressure in Combine and how does the Demand system work?",
    "hint": "Think about how a Subscriber tells the Publisher how many values it can handle, and how the Subscribers.Demand type (none, max, unlimited) controls flow.",
    "answer": "Backpressure is a mechanism that allows a Subscriber to control the rate at which a Publisher sends values, preventing the subscriber from being overwhelmed.\n\nHow Demand works:\n1. When a Subscriber subscribes, the Publisher sends a Subscription object.\n2. The Subscriber calls `subscription.request(.max(N))` to request N values.\n3. The Publisher sends at most N values.\n4. After receiving each value, the Subscriber can request additional demand by returning a Subscribers.Demand from `receive(_:)` or calling `subscription.request(_:)` again.\n\nDemand types:\n- `.none` (0) — do not send more values.\n- `.max(N)` — send up to N more values.\n- `.unlimited` — send as many values as available (no backpressure).\n\nDemand is additive:\n- Demands accumulate. If you request .max(3) and later .max(2), the total outstanding demand is .max(5).\n- Demand can never decrease — you cannot \"un-request\" values.\n\nPractical implications:\n- `.sink` requests `.unlimited` demand, meaning it accepts all values as fast as they come.\n- `.assign` also requests `.unlimited`.\n- Custom subscribers can implement fine-grained backpressure to handle slow consumers.\n\nOperators and backpressure:\n- `buffer(size:prefetch:whenFull:)` — buffers values when demand is low. When full, can drop newest, drop oldest, or error.\n- `flatMap(maxPublishers:)` — limits concurrent inner subscriptions.\n- `throttle` and `debounce` — time-based backpressure mechanisms.\n- `collect(.byCount(N))` — batches values into arrays.\n\nWhy it matters:\n- Without backpressure, a fast producer can overwhelm a slow consumer, causing memory growth or dropped events.\n- In practice, most Combine usage in app development uses `.unlimited` demand (via sink/assign), but understanding backpressure is essential for building custom publishers and subscribers, and for system-level programming."
  },
  {
    "topic": "combine",
    "level": 2,
    "question": "How do debounce, throttle, and scan work in Combine?",
    "hint": "debounce waits for a pause in emissions, throttle samples at intervals, and scan accumulates values like reduce but emits each intermediate result.",
    "answer": "These operators are commonly used for controlling emission timing and accumulating state.\n\ndebounce:\n- Waits for a specified quiet period after the last emission before forwarding the value.\n- If a new value arrives before the quiet period ends, the timer resets.\n```swift\nsearchText\n    .debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n    .sink { query in\n        // Only fires 300ms after user stops typing\n    }\n```\n- Use case: search-as-you-type to avoid firing a request on every keystroke.\n- Only the last value in a burst is emitted.\n\nthrottle:\n- Emits at most one value per specified time interval.\n- The `latest` parameter controls whether it emits the first or last value in each interval.\n```swift\nlocationUpdates\n    .throttle(for: .seconds(1), scheduler: RunLoop.main, latest: true)\n    .sink { location in\n        // At most one update per second\n    }\n```\n- `latest: true` — emits the most recent value at each interval.\n- `latest: false` — emits the first value received in each interval.\n- Use case: rate-limiting frequent events like scroll position updates.\n\nscan:\n- Accumulates values over time, emitting the running accumulation after each new value.\n- Similar to `reduce` but emits every intermediate result, not just the final one.\n```swift\n[1, 2, 3, 4].publisher\n    .scan(0, +) // Emits 1, 3, 6, 10\n    .sink { runningTotal in\n        print(runningTotal)\n    }\n```\n- Use case: running totals, accumulating a list of items, tracking state changes over time.\n\nComparison of debounce vs throttle:\n- debounce: waits for silence, good for \"user stopped doing X\" scenarios.\n- throttle: samples at regular intervals, good for \"at most N updates per second\" scenarios.\n- debounce can be starved if values keep arriving; throttle always emits at regular intervals."
  },
  {
    "topic": "combine",
    "level": 2,
    "question": "What are Future and Deferred in Combine and when would you use them?",
    "hint": "Future wraps a single async result as a publisher (and eagerly executes), while Deferred delays publisher creation until subscription time.",
    "answer": "Future and Deferred are publisher types for bridging imperative and lazy async patterns into Combine.\n\nFuture:\n- Wraps a single asynchronous result into a publisher that emits one value and completes (or fails).\n```swift\nfunc fetchUser(id: String) -> Future<User, Error> {\n    Future { promise in\n        apiClient.getUser(id: id) { result in\n            switch result {\n            case .success(let user): promise(.success(user))\n            case .failure(let error): promise(.failure(error))\n            }\n        }\n    }\n}\n```\n- The closure executes immediately when the Future is created, not when subscribed to.\n- The result is shared — multiple subscribers receive the same result.\n- Use for bridging callback-based APIs into Combine.\n\nDeferred:\n- Delays the creation of a publisher until a subscriber subscribes.\n- The factory closure runs fresh for each new subscriber.\n```swift\nDeferred {\n    Future { promise in\n        // This runs only when someone subscribes\n        promise(.success(Date()))\n    }\n}\n```\n- Use Deferred to wrap a Future when you want lazy execution.\n- Also useful for creating publishers with side effects that should only happen upon subscription.\n\nCommon pattern — lazy network request:\n```swift\nfunc makeRequest() -> AnyPublisher<Data, Error> {\n    Deferred {\n        Future { promise in\n            // Network call happens only on subscription\n        }\n    }\n    .eraseToAnyPublisher()\n}\n```\n\nKey differences:\n- Future: eager execution, single result, shared across subscribers.\n- Deferred: lazy execution, creates a new publisher for each subscriber.\n- Combining them (Deferred { Future { ... } }) gives you a lazy, single-result publisher — the most common pattern for wrapping async work."
  },
  {
    "topic": "combine",
    "level": 2,
    "question": "What is type erasure with eraseToAnyPublisher() and why is it commonly used?",
    "hint": "Think about the complex nested generic types that Combine operators produce and how type erasure simplifies the public API.",
    "answer": "Type erasure with `eraseToAnyPublisher()` wraps any publisher into an `AnyPublisher<Output, Failure>`, hiding the concrete publisher type.\n\nWhy it is needed:\n- Combine operators return deeply nested generic types. For example:\n```swift\n// The actual type might be:\n// Publishers.Map<Publishers.Filter<Publishers.Sequence<[Int], Never>>, String>\n[1, 2, 3].publisher\n    .filter { $0 > 1 }\n    .map { String($0) }\n```\n- Exposing these types in function signatures or properties would be fragile and unreadable.\n- Any change to the internal pipeline would change the return type, breaking the API.\n\nUsage:\n```swift\nfunc searchUsers(query: String) -> AnyPublisher<[User], Error> {\n    urlSession.dataTaskPublisher(for: makeURL(query))\n        .map(\\.data)\n        .decode(type: [User].self, decoder: JSONDecoder())\n        .eraseToAnyPublisher() // Hides the concrete pipeline type\n}\n```\n\nBenefits:\n- Clean, stable API signatures that do not change when internal implementation changes.\n- Enables polymorphism — you can return different publisher chains from different code paths.\n- Required when storing publishers in properties or collections.\n\nDrawbacks:\n- Minor performance overhead due to type erasure (indirect dispatch).\n- Loses compile-time type information that could enable optimizations.\n- Overusing it inside a pipeline (between operators) is unnecessary — only erase at API boundaries.\n\nAlternatives:\n- `some Publisher<Output, Failure>` (Swift 5.7+) provides opaque return types without type erasure, preserving performance while hiding the concrete type.\n- Use `some Publisher` when possible; use `AnyPublisher` when you need to store or use heterogeneous publisher types."
  },
  {
    "topic": "combine",
    "level": 3,
    "question": "How do multicast and share work in Combine, and when would you use them to avoid redundant work?",
    "hint": "Think about the difference between cold and hot publishers, and how multicast/share convert a cold publisher into a hot one that shares a single subscription.",
    "answer": "In Combine, publishers are typically \"cold\" — each subscriber gets its own independent execution of the upstream pipeline. multicast and share convert cold publishers into \"hot\" ones that share a single upstream subscription.\n\nmulticast:\n- Wraps a publisher so that multiple subscribers share a single subscription to the upstream.\n- Takes a Subject (PassthroughSubject or CurrentValueSubject) that broadcasts values to all subscribers.\n- Returns a `ConnectablePublisher` — it does not start emitting until `.connect()` is called (or `.autoconnect()` is used).\n```swift\nlet shared = urlSession.dataTaskPublisher(for: url)\n    .map(\\.data)\n    .multicast(subject: PassthroughSubject())\n\nshared.sink { data in /* subscriber 1 */ }.store(in: &cancellables)\nshared.sink { data in /* subscriber 2 */ }.store(in: &cancellables)\n\nshared.connect() // Starts the single upstream subscription\n    .store(in: &cancellables)\n```\n\nshare:\n- A convenience operator that uses multicast with a PassthroughSubject and autoconnect.\n- Automatically connects when the first subscriber subscribes and shares with subsequent subscribers.\n```swift\nlet shared = urlSession.dataTaskPublisher(for: url)\n    .map(\\.data)\n    .share()\n```\n- Simpler API but less control over timing.\n\nWhy it matters:\n- Without sharing, each .sink on a dataTaskPublisher triggers a separate network request.\n- With share/multicast, only one request is made and the result is delivered to all subscribers.\n\nSubtleties:\n- share uses a PassthroughSubject, so late subscribers miss values emitted before they subscribed.\n- If you need replay behavior, use `multicast(subject: CurrentValueSubject(initialValue))` or the third-party `shareReplay` operator.\n- multicast's `.connect()` returns a Cancellable — you must store it to keep the subscription alive.\n- share's reference count: when all subscribers cancel, the upstream subscription is cancelled. A new subscriber starts a fresh subscription.\n\nUse cases:\n- Sharing expensive operations (network calls, heavy computations) across multiple consumers.\n- Creating event streams that multiple parts of the app observe.\n- Avoiding side effects from being executed multiple times."
  },
  {
    "topic": "combine",
    "level": 3,
    "question": "How can you bridge between Combine and Swift's async/await concurrency, and what are the trade-offs?",
    "hint": "Think about converting publishers to AsyncSequence, using async/await in Combine pipelines with Future, and when each approach is more appropriate.",
    "answer": "Combine and async/await can interoperate, but they have different design philosophies that affect when to use each.\n\nCombine to async/await:\n\n1. Publisher.values (AsyncSequence bridge):\n```swift\nfor await value in myPublisher.values {\n    print(value)\n}\n```\n- Converts any publisher into an AsyncSequence.\n- The for-await loop consumes values as they arrive.\n- Completion ends the loop; errors throw.\n- Useful for migrating Combine code to structured concurrency.\n\n2. Single value extraction:\n```swift\nlet result = try await myPublisher.first().values.first(where: { _ in true })\n```\n- Or use a continuation:\n```swift\nlet value = try await withCheckedThrowingContinuation { continuation in\n    myPublisher.first().sink(\n        receiveCompletion: { completion in\n            if case .failure(let error) = completion {\n                continuation.resume(throwing: error)\n            }\n        },\n        receiveValue: { value in\n            continuation.resume(returning: value)\n        }\n    ).store(in: &cancellables)\n}\n```\n\nasync/await to Combine:\n- Wrap async functions in Future/Deferred:\n```swift\nDeferred {\n    Future { promise in\n        Task {\n            do {\n                let result = try await fetchData()\n                promise(.success(result))\n            } catch {\n                promise(.failure(error))\n            }\n        }\n    }\n}.eraseToAnyPublisher()\n```\n\nTrade-offs:\n\nCombine strengths:\n- Rich operator library for complex data transformations.\n- Built-in backpressure.\n- Declarative pipeline composition.\n- Time-based operations (debounce, throttle) are natural.\n- Integration with SwiftUI's @Published and ObservableObject.\n\nasync/await strengths:\n- Simpler, more linear code flow.\n- Structured concurrency with automatic cancellation.\n- Better for request/response patterns.\n- First-class language support with better debugging.\n- No need for AnyCancellable management.\n\nGuidance:\n- For new code, prefer async/await for simple async operations.\n- Use Combine for complex event streams, time-based operations, and reactive UI bindings.\n- Use the bridges when integrating existing Combine code with new async/await code.\n- @Observable (iOS 17+) reduces the need for Combine in SwiftUI contexts."
  },
  {
    "topic": "combine",
    "level": 3,
    "question": "How do you build custom Publishers in Combine?",
    "hint": "Think about implementing the Publisher protocol with a custom Subscription that manages demand, delivers values, and handles cancellation.",
    "answer": "Building custom publishers requires implementing the Publisher protocol and a custom Subscription that manages the subscriber relationship.\n\nBasic structure:\n```swift\nstruct CountdownPublisher: Publisher {\n    typealias Output = Int\n    typealias Failure = Never\n\n    let start: Int\n\n    func receive<S: Subscriber>(subscriber: S)\n    where S.Input == Output, S.Failure == Failure {\n        let subscription = CountdownSubscription(\n            subscriber: subscriber,\n            start: start\n        )\n        subscriber.receive(subscription: subscription)\n    }\n}\n```\n\nCustom Subscription:\n```swift\nprivate final class CountdownSubscription<S: Subscriber>: Subscription\nwhere S.Input == Int, S.Failure == Never {\n    private var subscriber: S?\n    private var current: Int\n    private var demand: Subscribers.Demand = .none\n\n    init(subscriber: S, start: Int) {\n        self.subscriber = subscriber\n        self.current = start\n    }\n\n    func request(_ demand: Subscribers.Demand) {\n        self.demand += demand\n        emitValues()\n    }\n\n    func cancel() {\n        subscriber = nil\n    }\n\n    private func emitValues() {\n        while demand > .none, current >= 0 {\n            demand -= 1\n            let additionalDemand = subscriber?.receive(current) ?? .none\n            demand += additionalDemand\n            current -= 1\n        }\n        if current < 0 {\n            subscriber?.receive(completion: .finished)\n        }\n    }\n}\n```\n\nKey requirements:\n1. **Thread safety**: The Subscription must handle `request(_:)` and `cancel()` being called from different threads. Use locks or serial queues.\n2. **Demand management**: Never send more values than requested. Track cumulative demand and decrement as values are sent.\n3. **Cancellation**: Set subscriber to nil on cancel to break retain cycles and stop emitting.\n4. **Completion**: Send `.finished` or `.failure` exactly once, and stop sending values after completion.\n5. **Back-pressure**: Respect the subscriber's demand — this is the contract of the Publisher/Subscriber protocol.\n\nWhen to build custom publishers:\n- Wrapping non-Combine async APIs (though Future/Deferred often suffice).\n- Creating reusable publishers with specific emission patterns.\n- When existing operators cannot express the desired behavior.\n\nAlternatives to custom publishers:\n- Subjects (PassthroughSubject/CurrentValueSubject) are simpler for imperative value injection.\n- Operator composition using existing operators covers most use cases.\n- Custom publishers are rarely needed in typical app development."
  },
  {
    "topic": "combine",
    "level": 3,
    "question": "What debugging tools does Combine provide for inspecting pipelines?",
    "hint": "Think about the print, handleEvents, and breakpoint operators and how they let you observe what flows through a pipeline.",
    "answer": "Combine provides several operators specifically for debugging publisher pipelines.\n\nprint:\n- Logs all events (subscription, values, completion, cancellation, demand) to the console.\n```swift\npublisher\n    .print(\"DEBUG\")\n    .sink { value in }\n```\n- Output looks like:\n```\nDEBUG: receive subscription: (Just)\nDEBUG: request unlimited\nDEBUG: receive value: (42)\nDEBUG: receive finished\n```\n- Accepts an optional prefix string and a TextOutputStream for custom logging.\n- Useful for understanding the exact sequence of events in a pipeline.\n\nhandleEvents:\n- Allows you to inject side effects at each stage of the publisher lifecycle without modifying the stream.\n```swift\npublisher\n    .handleEvents(\n        receiveSubscription: { sub in\n            print(\"Subscribed: \\(sub)\")\n        },\n        receiveOutput: { value in\n            print(\"Value: \\(value)\")\n        },\n        receiveCompletion: { completion in\n            print(\"Completed: \\(completion)\")\n        },\n        receiveCancel: {\n            print(\"Cancelled\")\n        },\n        receiveRequest: { demand in\n            print(\"Demand: \\(demand)\")\n        }\n    )\n```\n- More flexible than print — you can add conditional logic, update debug UI, or log to analytics.\n\nbreakpoint:\n- Triggers a debugger breakpoint when a condition is met.\n```swift\npublisher\n    .breakpoint(\n        receiveOutput: { value in value > 100 },\n        receiveCompletion: { completion in\n            if case .failure = completion { return true }\n            return false\n        }\n    )\n```\n- `breakpointOnError()` is a shorthand that breaks on any error.\n- Extremely useful for catching unexpected values or errors during development.\n\nBest practices:\n- Insert print/handleEvents temporarily during development, then remove for production.\n- Use handleEvents to track subscription lifecycle issues (unexpected cancellations, missing subscriptions).\n- Combine breakpoint with specific conditions to catch edge cases.\n- For testing, use custom test schedulers and record operator output rather than relying on print statements."
  },
  {
    "topic": "combine",
    "level": 4,
    "question": "How do you effectively test Combine pipelines, including time-based operators?",
    "hint": "Think about using XCTestExpectation, custom test schedulers for deterministic time control, and recording emitted values for assertions.",
    "answer": "Testing Combine pipelines requires strategies for handling asynchronous emissions, time-based operators, and verifying exact sequences of values.\n\nBasic testing with expectations:\n```swift\nfunc testPublisherEmitsValues() {\n    let expectation = XCTestExpectation(description: \"Receives values\")\n    var received: [Int] = []\n\n    [1, 2, 3].publisher\n        .sink(\n            receiveCompletion: { _ in expectation.fulfill() },\n            receiveValue: { received.append($0) }\n        )\n        .store(in: &cancellables)\n\n    wait(for: [expectation], timeout: 1.0)\n    XCTAssertEqual(received, [1, 2, 3])\n}\n```\n\nTesting with recorded output:\n```swift\nfunc testMapping() {\n    var results: [String] = []\n    let expectation = expectation(description: \"complete\")\n\n    [1, 2, 3].publisher\n        .map { \"Value: \\($0)\" }\n        .sink(\n            receiveCompletion: { _ in expectation.fulfill() },\n            receiveValue: { results.append($0) }\n        )\n        .store(in: &cancellables)\n\n    wait(for: [expectation], timeout: 1)\n    XCTAssertEqual(results, [\"Value: 1\", \"Value: 2\", \"Value: 3\"])\n}\n```\n\nTesting time-based operators:\n- The challenge: debounce, throttle, delay depend on real time, making tests slow and flaky.\n- Solution: Use a test scheduler that gives you deterministic control over time.\n\nUsing a custom TestScheduler (or libraries like CombineSchedulers):\n```swift\nlet scheduler = DispatchQueue.test // From CombineSchedulers\n\nvar output: [String] = []\nsubject\n    .debounce(for: .seconds(1), scheduler: scheduler)\n    .sink { output.append($0) }\n    .store(in: &cancellables)\n\nsubject.send(\"a\")\nsubject.send(\"b\")\nscheduler.advance(by: .seconds(1))\nXCTAssertEqual(output, [\"b\"]) // Only last value after debounce\n```\n\nTesting error handling:\n```swift\nfunc testErrorRecovery() {\n    let subject = PassthroughSubject<Int, Error>()\n    var received: [Int] = []\n\n    subject\n        .catch { _ in Just(0) }\n        .sink(receiveValue: { received.append($0) })\n        .store(in: &cancellables)\n\n    subject.send(1)\n    subject.send(completion: .failure(TestError.some))\n    XCTAssertEqual(received, [1, 0])\n}\n```\n\nBest practices:\n- Abstract schedulers behind a protocol/parameter so you can inject test schedulers.\n- Test the entire pipeline, not individual operators (operators are already tested by Apple).\n- Verify both the values emitted AND the completion event.\n- Test cancellation behavior — ensure resources are cleaned up.\n- Use Subjects to simulate upstream events in tests.\n- For ViewModels, test the published outputs given specific inputs.\n- Keep timeouts short in tests — if a test needs more than 2 seconds, the pipeline likely has an issue."
  },
  {
    "topic": "combine",
    "level": 4,
    "question": "Explain the Subscriber protocol in detail, including how a custom Subscriber manages demand and handles the subscription lifecycle.",
    "hint": "Think about the three receive methods (subscription, input, completion), how demand accumulates, and the importance of thread safety.",
    "answer": "The Subscriber protocol is the receiving end of a Combine pipeline. Understanding it deeply is essential for building custom subscribers and understanding how built-in operators work.\n\nProtocol definition:\n```swift\nprotocol Subscriber: CustomCombineIdentifierConvertible {\n    associatedtype Input\n    associatedtype Failure: Error\n\n    func receive(subscription: Subscription)\n    func receive(_ input: Input) -> Subscribers.Demand\n    func receive(completion: Subscribers.Completion<Failure>)\n}\n```\n\nLifecycle:\n1. `receive(subscription:)` — called once when the publisher accepts the subscription. The subscriber stores the subscription and requests initial demand.\n2. `receive(_ input:)` — called for each value. Returns additional demand (can be .none).\n3. `receive(completion:)` — called once with `.finished` or `.failure(Error)`. No more values after this.\n\nCustom Subscriber example:\n```swift\nclass BatchSubscriber: Subscriber {\n    typealias Input = Int\n    typealias Failure = Never\n\n    private var subscription: Subscription?\n    private var buffer: [Int] = []\n    private let batchSize: Int\n    private let lock = NSLock()\n\n    init(batchSize: Int) {\n        self.batchSize = batchSize\n    }\n\n    func receive(subscription: Subscription) {\n        lock.lock()\n        self.subscription = subscription\n        lock.unlock()\n        subscription.request(.max(batchSize))\n    }\n\n    func receive(_ input: Int) -> Subscribers.Demand {\n        lock.lock()\n        buffer.append(input)\n        let shouldProcess = buffer.count >= batchSize\n        let batch = shouldProcess ? buffer : nil\n        if shouldProcess { buffer.removeAll() }\n        lock.unlock()\n\n        if let batch = batch {\n            processBatch(batch)\n            return .max(batchSize) // Request next batch\n        }\n        return .none // Wait for more values\n    }\n\n    func receive(completion: Subscribers.Completion<Never>) {\n        lock.lock()\n        let remaining = buffer\n        buffer.removeAll()\n        subscription = nil\n        lock.unlock()\n\n        if !remaining.isEmpty {\n            processBatch(remaining)\n        }\n    }\n\n    private func processBatch(_ batch: [Int]) {\n        // Handle batch\n    }\n\n    func cancel() {\n        lock.lock()\n        subscription?.cancel()\n        subscription = nil\n        lock.unlock()\n    }\n}\n```\n\nCritical implementation details:\n\n1. **Demand management**: The return value of `receive(_:)` adds to the cumulative demand. Return `.none` to not request more, `.max(1)` to request one more, or `.unlimited` (use sparingly).\n\n2. **Thread safety**: Publishers can call receive methods from any thread. Use locks, serial queues, or other synchronization primitives.\n\n3. **Subscription storage**: Store the subscription to request more values later and to cancel. Use weak references if needed to avoid retain cycles.\n\n4. **Cancellation**: Always implement proper cleanup. Set subscription to nil and stop processing.\n\n5. **Contract rules**:\n   - A subscriber must not receive values before requesting demand.\n   - After receiving completion, no more values arrive.\n   - Demand is always non-negative and additive.\n   - The subscriber must be prepared for receive methods to be called from different threads."
  },
  {
    "topic": "combine",
    "level": 4,
    "question": "What are the differences between Combine and async/await for real-world iOS architecture, and when should you choose one over the other?",
    "hint": "Consider reactive streams vs request-response patterns, operator richness vs linear code, lifecycle management, and how SwiftUI integrates with each.",
    "answer": "Choosing between Combine and async/await (structured concurrency) is a significant architectural decision. Each has distinct strengths.\n\nCombine strengths:\n\n1. **Reactive streams**: Combine excels at modeling continuous data flows — user input, sensor data, WebSocket messages, real-time updates. The stream stays open indefinitely.\n\n2. **Operator composition**: Operators like debounce, throttle, combineLatest, scan, and switchToLatest express complex temporal logic declaratively. Replicating these with async/await requires significant boilerplate.\n\n3. **Backpressure**: Built-in demand management prevents fast producers from overwhelming slow consumers.\n\n4. **SwiftUI integration**: @Published and ObservableObject are Combine-native. Many SwiftUI APIs return publishers.\n\n5. **Multi-subscriber broadcasting**: share/multicast efficiently deliver values to multiple consumers.\n\nasync/await strengths:\n\n1. **Linear code flow**: Async code reads top-to-bottom like synchronous code, making it easier to understand, write, and debug.\n\n2. **Structured concurrency**: Task hierarchies automatically propagate cancellation, and TaskGroup manages concurrent work with clear scoping.\n\n3. **Error handling**: Standard try/catch works naturally, versus Combine's typed error system.\n\n4. **No memory management overhead**: No AnyCancellable storage needed. Task cancellation is automatic when the parent scope ends.\n\n5. **Debugging**: Stack traces are meaningful. Combine's stack traces are often opaque chains of generic operator types.\n\n6. **Performance**: Direct compiler support means async/await has less runtime overhead than Combine's publisher chain.\n\nArchitectural guidance:\n\n- **Network layer**: async/await. Request-response is naturally suited to async functions. `let data = try await fetchUser(id)`.\n\n- **Search with debounce**: Combine. `$searchText.debounce(for: .3, scheduler: RunLoop.main).removeDuplicates()` is concise and correct.\n\n- **Data repositories**: async/await for one-shot fetches, Combine or AsyncSequence for continuous observation.\n\n- **View models**: With @Observable (iOS 17+), neither is strictly necessary for simple cases. For complex reactive logic, Combine. For sequential async operations, async/await.\n\n- **Real-time features**: Combine for WebSocket streams, sensor data, or any multi-value async stream. AsyncSequence is catching up but lacks Combine's operator richness.\n\n- **Testing**: async/await is generally easier to test. Combine requires test schedulers for time-based operators.\n\nMigration strategy:\n- New code: default to async/await, use Combine for reactive/time-based needs.\n- Existing Combine code: no need to rewrite unless simplification is significant.\n- Use bridges (publisher.values, Future wrapping async) to integrate both in the same codebase.\n- AsyncSequence is evolving and may eventually replace many Combine use cases, but Combine remains more mature for complex reactive pipelines as of iOS 17/18."
  },
  {
    "topic": "combine",
    "level": 5,
    "question": "Explain the internal mechanics of how Combine operators chain together, including subscription propagation, demand forwarding, and how operators like flatMap manage multiple inner subscriptions.",
    "hint": "Think about how each operator creates an intermediate Subscriber that sits between upstream and downstream, forwarding subscriptions, transforming values, managing demand, and handling inner publisher lifecycles.",
    "answer": "Combine operators form a chain of intermediate subscriber-publisher pairs. Understanding their internal mechanics reveals how the framework achieves its composability and performance.\n\nOperator chaining internals:\n\nWhen you write:\n```swift\nupstream\n    .map { transform($0) }\n    .filter { predicate($0) }\n    .sink { handle($0) }\n```\n\nThe actual structure created is:\n1. `sink` creates a `Subscribers.Sink` and subscribes to the filter publisher.\n2. The filter publisher creates an internal `Filter.Inner` subscriber and subscribes to the map publisher.\n3. The map publisher creates an internal `Map.Inner` subscriber and subscribes to upstream.\n\nSubscription propagation (bottom-up):\n- upstream calls `Map.Inner.receive(subscription:)`\n- Map.Inner stores the subscription and calls `Filter.Inner.receive(subscription:)` with a wrapped subscription.\n- Filter.Inner wraps again and calls `Sink.receive(subscription:)` with the final wrapped subscription.\n- Each operator may wrap the subscription to intercept demand requests.\n\nDemand forwarding:\n- Sink calls `subscription.request(.unlimited)`.\n- This propagates up through each operator's subscription wrapper.\n- Filter may request more than downstream needs (since some values will be filtered out).\n- Each operator adjusts demand based on its semantics.\n\nValue propagation (top-down):\n- Upstream sends a value to Map.Inner's `receive(_:)`.\n- Map.Inner transforms it and forwards to Filter.Inner's `receive(_:)`.\n- Filter.Inner checks the predicate. If true, forwards to Sink. If false, returns `.max(1)` to request a replacement value from upstream.\n- Sink processes the value and returns demand.\n\nflatMap internal complexity:\n\nflatMap is one of the most complex operators because it manages multiple concurrent inner subscriptions:\n\n1. **Outer subscription**: flatMap subscribes to the upstream publisher.\n2. **Inner subscriptions**: For each upstream value, flatMap creates a new inner publisher and subscribes to it.\n3. **maxPublishers parameter**: Controls how many inner subscriptions are active simultaneously. `.max(1)` creates serial behavior; `.unlimited` allows full concurrency.\n4. **Demand distribution**: flatMap must distribute downstream demand across multiple inner publishers. It maintains a demand buffer and allocates demand to inner publishers as they request it.\n5. **Completion**: flatMap completes only when BOTH the outer publisher AND all inner publishers have completed.\n6. **Cancellation**: Cancelling the outer subscription must cancel all active inner subscriptions.\n\nInternal state machine for flatMap:\n```\nStates:\n- Waiting for outer subscription\n- Active (outer subscribed, processing values)\n- Outer completed, inner publishers still active\n- All completed\n- Cancelled\n\nTransitions:\n- Receive outer value -> Create inner publisher, subscribe (if under maxPublishers)\n- Inner publisher emits -> Forward to downstream, adjust demand\n- Inner publisher completes -> Remove from active set, start pending if any\n- Outer completes + all inners complete -> Send completion downstream\n- Cancel -> Cancel outer + all inners, release resources\n```\n\nThread safety:\n- Each operator's Inner type typically uses a lock (or recursive lock) to protect its mutable state.\n- Values can arrive from any thread, and demand requests can come from downstream on a different thread.\n- The lock must be carefully managed to avoid deadlocks, especially in operators like flatMap where inner publishers may emit synchronously during subscription.\n\nPerformance characteristics:\n- Simple operators (map, filter) add minimal overhead — one function call per value plus lock acquisition.\n- Complex operators (flatMap, combineLatest) maintain internal state machines with higher overhead.\n- The chain of virtual calls (protocol dispatch) through operator layers is the primary runtime cost.\n- eraseToAnyPublisher adds an additional layer of indirection.\n\nMemory management:\n- Each operator's Inner retains the downstream subscriber (strong reference).\n- The subscription chain creates a retain cycle that is broken when the pipeline completes or is cancelled.\n- AnyCancellable calls cancel() on deinit, which propagates upstream through the subscription chain, releasing all resources.\n- Subjects used with multicast can create additional retain cycles if not carefully managed."
  },
  {
    "topic": "combine",
    "level": 5,
    "question": "How would you design a production-grade reactive architecture using Combine that handles error recovery, retry with exponential backoff, request deduplication, and graceful degradation?",
    "hint": "Think about layering retry logic with delay, using share to deduplicate in-flight requests, catch for fallback data sources, and how to compose these into a reusable data layer.",
    "answer": "Designing a production-grade reactive data layer with Combine requires composing multiple patterns into a robust, reusable architecture.\n\nExponential backoff retry:\n```swift\nextension Publisher {\n    func retryWithBackoff(\n        maxRetries: Int,\n        initialDelay: TimeInterval = 1,\n        multiplier: Double = 2,\n        scheduler: some Scheduler\n    ) -> AnyPublisher<Output, Failure> {\n        self.catch { error -> AnyPublisher<Output, Failure> in\n            guard maxRetries > 0 else {\n                return Fail(error: error).eraseToAnyPublisher()\n            }\n            return Just(())\n                .delay(for: .seconds(initialDelay), scheduler: scheduler)\n                .flatMap { _ in\n                    self.retryWithBackoff(\n                        maxRetries: maxRetries - 1,\n                        initialDelay: initialDelay * multiplier,\n                        multiplier: multiplier,\n                        scheduler: scheduler\n                    )\n                }\n                .eraseToAnyPublisher()\n        }\n        .eraseToAnyPublisher()\n    }\n}\n```\n\nRequest deduplication:\n```swift\nclass RequestDeduplicator<Key: Hashable, Output, Failure: Error> {\n    private var inFlight: [Key: AnyPublisher<Output, Failure>] = [:]\n    private let lock = NSLock()\n\n    func deduplicate(\n        key: Key,\n        factory: () -> AnyPublisher<Output, Failure>\n    ) -> AnyPublisher<Output, Failure> {\n        lock.lock()\n        if let existing = inFlight[key] {\n            lock.unlock()\n            return existing\n        }\n\n        let publisher = factory()\n            .handleEvents(receiveCompletion: { [weak self] _ in\n                self?.lock.lock()\n                self?.inFlight.removeValue(forKey: key)\n                self?.lock.unlock()\n            }, receiveCancel: { [weak self] in\n                self?.lock.lock()\n                self?.inFlight.removeValue(forKey: key)\n                self?.lock.unlock()\n            })\n            .share()\n            .eraseToAnyPublisher()\n\n        inFlight[key] = publisher\n        lock.unlock()\n        return publisher\n    }\n}\n```\n\nGraceful degradation with fallback chain:\n```swift\nfunc fetchData<T: Decodable>(endpoint: URL, type: T.Type) -> AnyPublisher<T, Never> {\n    // Primary: network request with retry\n    let network = urlSession.dataTaskPublisher(for: endpoint)\n        .map(\\.data)\n        .decode(type: T.self, decoder: decoder)\n        .retryWithBackoff(\n            maxRetries: 3,\n            scheduler: DispatchQueue.global()\n        )\n        .handleEvents(receiveOutput: { [cache] value in\n            cache.store(value, for: endpoint) // Cache successful responses\n        })\n\n    // Fallback 1: local cache\n    let cached = Deferred {\n        Future<T, Error> { promise in\n            if let cached: T = cache.retrieve(for: endpoint) {\n                promise(.success(cached))\n            } else {\n                promise(.failure(CacheError.miss))\n            }\n        }\n    }\n\n    // Fallback 2: bundled default data\n    let bundled = Deferred {\n        Future<T, Error> { promise in\n            if let data = Bundle.main.url(forResource: \"default\", withExtension: \"json\"),\n               let value = try? JSONDecoder().decode(T.self, from: Data(contentsOf: data)) {\n                promise(.success(value))\n            } else {\n                promise(.failure(FallbackError.noDefault))\n            }\n        }\n    }\n\n    return network\n        .catch { _ in cached }\n        .catch { _ in bundled }\n        .replaceError(with: T.defaultValue) // Final safety net\n        .receive(on: DispatchQueue.main)\n        .eraseToAnyPublisher()\n}\n```\n\nFull data layer composition:\n```swift\nclass DataLayer {\n    private let deduplicator = RequestDeduplicator<URL, Data, URLError>()\n    private let cache: Cache\n    private let scheduler: AnySchedulerOf<DispatchQueue>\n\n    func observe<T: Decodable>(\n        endpoint: URL,\n        refreshInterval: TimeInterval,\n        type: T.Type\n    ) -> AnyPublisher<T, Never> {\n        // Emit cached value immediately, then refresh periodically\n        let initial = fetchOnce(endpoint: endpoint, type: type)\n        let periodic = Timer.publish(\n            every: refreshInterval,\n            on: .main,\n            in: .common\n        )\n        .autoconnect()\n        .flatMap { [weak self] _ -> AnyPublisher<T, Never> in\n            self?.fetchOnce(endpoint: endpoint, type: type)\n                ?? Empty().eraseToAnyPublisher()\n        }\n\n        return initial\n            .merge(with: periodic)\n            .removeDuplicates()\n            .eraseToAnyPublisher()\n    }\n}\n```\n\nProduction considerations:\n1. **Cancellation propagation**: Ensure all nested subscriptions are cancelled when the top-level subscription is cancelled.\n2. **Memory**: Use `[weak self]` in closures within long-lived publishers to prevent retain cycles.\n3. **Thread safety**: All shared mutable state (caches, deduplication maps) must be synchronized.\n4. **Logging**: Use handleEvents at strategic points for observability without affecting the data flow.\n5. **Testing**: Inject schedulers, network sessions, and caches as protocols for testability.\n6. **Metrics**: Track retry counts, cache hit rates, and fallback usage to monitor system health.\n7. **Circuit breaker**: After repeated failures, stop retrying for a cooldown period to avoid overwhelming a failing service.\n\nThis architecture provides resilience through layered fallbacks, efficiency through deduplication and caching, and observability through structured logging — all expressed declaratively through Combine's operator composition."
  },
  {
    "topic": "combine",
    "level": 2,
    "question": "How do the reduce and collect operators work in Combine, and how do they differ from scan?",
    "hint": "Think about which operators wait for the publisher to complete before emitting, versus which one emits running values along the way.",
    "answer": "reduce, collect, and scan all accumulate values from a publisher, but they differ in when and what they emit.\n\nreduce:\n- Accumulates all values into a single result using a closure, then emits that single result when the publisher completes.\n- Analogous to Swift's Array.reduce.\n```swift\n[1, 2, 3, 4].publisher\n    .reduce(0, +) // Emits only 10 (after completion)\n```\n- Use when you need a final aggregated result (sum, count, concatenated string).\n- The publisher must complete — if it never completes (e.g., a Subject), reduce never emits.\n\ncollect:\n- Buffers all emitted values into an array and emits the array when the publisher completes.\n```swift\n[1, 2, 3].publisher\n    .collect() // Emits [1, 2, 3]\n```\n- Variants:\n  - `collect()` — collects all values into one array.\n  - `collect(3)` — collects into arrays of the specified count, emitting each batch as it fills.\n  - `collect(.byTime(scheduler, .seconds(1)))` — collects values over a time window.\n- Use for batching operations or when you need all values as a single collection.\n\nscan (for comparison):\n- Emits the running accumulation after each value — does NOT wait for completion.\n```swift\n[1, 2, 3, 4].publisher\n    .scan(0, +) // Emits 1, 3, 6, 10\n```\n- Use when you need intermediate accumulated results (running totals, state history).\n\nKey differences:\n- reduce: emits 1 value at completion.\n- collect: emits 1 array at completion (or batched arrays).\n- scan: emits N values (one per input), does not wait for completion.\n- Both reduce and collect require the upstream to complete. Using them with infinite publishers (Subjects, timers) means they will never emit and will buffer indefinitely, causing memory growth.\n- collect with a count or time strategy is safe for infinite publishers because it emits periodically."
  },
  {
    "topic": "combine",
    "level": 3,
    "question": "How does the buffer operator work in Combine, and what strategies does it provide for handling overflow?",
    "hint": "Think about the three prefetch strategies and the three overflow strategies, and when buffering is necessary between a fast producer and slow consumer.",
    "answer": "The buffer operator in Combine inserts a buffer between a publisher and its downstream subscriber, allowing them to operate at different speeds.\n\nSignature:\n```swift\n.buffer(size: Int, prefetch: Publishers.PrefetchStrategy, whenFull: Publishers.BufferingStrategy<Failure>)\n```\n\nPrefetch strategies:\n- `.byRequest` — requests values from upstream based on downstream demand. The buffer fills only as downstream requests values. This is the default behavior that respects backpressure.\n- `.keepFull` — eagerly requests values from upstream to keep the buffer full, regardless of downstream demand. Useful when you want values ready immediately when downstream requests them.\n\nBuffer overflow strategies (whenFull):\n- `.dropNewest` — when the buffer is full, new values from upstream are dropped. The most recent value that would exceed the buffer is discarded.\n- `.dropOldest` — when the buffer is full, the oldest value in the buffer is removed to make room for the new value.\n- `.customError({ SomeError() })` — when the buffer is full, the publisher terminates with the specified error.\n\nUsage example:\n```swift\nfastPublisher\n    .buffer(size: 50, prefetch: .keepFull, whenFull: .dropOldest)\n    .receive(on: DispatchQueue.main)\n    .sink { value in\n        // Process at UI speed\n    }\n```\n\nWhen to use buffer:\n1. **Fast producer, slow consumer**: Sensor data arriving at 100Hz but UI updating at 60Hz.\n2. **Thread boundary crossing**: When receive(on:) switches to a slower scheduler, buffer prevents upstream from being throttled.\n3. **Bursty data**: Network events that arrive in bursts but need to be processed at a steady rate.\n\nImportant considerations:\n- Without a buffer, `receive(on:)` can cause backpressure that slows the upstream publisher.\n- Large buffer sizes consume memory proportional to the element size times the buffer size.\n- `.dropOldest` is typically preferred for real-time data where the latest value matters most.\n- `.dropNewest` is preferred when you want to process values in order and can afford to miss recent ones.\n- The buffer operator is one of the few places where data loss is an intentional design choice to maintain system stability."
  },
  {
    "topic": "combine",
    "level": 4,
    "question": "How does Combine handle type-level error propagation, and what are the patterns for transforming error types through a pipeline?",
    "hint": "Think about how each operator preserves or transforms the Failure type, the role of mapError, setFailureType, and how operators like flatMap require matching error types.",
    "answer": "Combine uses Swift's type system to track errors at compile time through the Failure associated type on Publisher. Every operator in a pipeline must have compatible error types, which creates both safety and complexity.\n\nError type rules:\n- Each publisher has a concrete Failure type (or Never for infallible publishers).\n- Operators preserve the upstream Failure type unless they explicitly transform it.\n- Combining two publishers requires matching Failure types.\n\nCommon error type transformations:\n\nmapError — transforms the error type:\n```swift\nurlSession.dataTaskPublisher(for: url) // Failure = URLError\n    .mapError { $0 as Error } // Failure = Error\n```\n- Use to unify different error types into a common type.\n- Often used to erase to the generic `Error` protocol.\n\nsetFailureType(to:) — adds an error type to a Never-failing publisher:\n```swift\nJust(42) // Failure = Never\n    .setFailureType(to: MyError.self) // Failure = MyError\n```\n- Necessary when combining a Never publisher with a failable one.\n- Does not actually introduce errors — just changes the type.\n\ntryMap, tryFilter, etc. — throwing variants that set Failure to Error:\n```swift\npublisher // Failure = Never\n    .tryMap { value in\n        guard value > 0 else { throw ValidationError.negative }\n        return value\n    } // Failure = Error (always Error, not ValidationError)\n```\n- All try* operators produce `Failure = Error`, regardless of the thrown type.\n- This can be frustrating when you want a specific error type.\n\nflatMap error matching:\n```swift\n// This fails to compile if error types don't match:\npublisherA // Failure = ErrorA\n    .flatMap { value in\n        publisherB // Failure = ErrorB — compile error!\n    }\n\n// Fix: unify error types\npublisherA\n    .mapError { $0 as Error }\n    .flatMap { value in\n        publisherB.mapError { $0 as Error }\n    }\n```\n\nPatterns for clean error handling:\n\n1. **Domain error types**: Define a single error enum per feature/module:\n```swift\nenum DataError: Error {\n    case network(URLError)\n    case decoding(DecodingError)\n    case validation(String)\n}\n```\n\n2. **Early error type unification**: Convert to your domain error at the source:\n```swift\nurlSession.dataTaskPublisher(for: url)\n    .mapError { DataError.network($0) }\n    .map(\\.data)\n    .decode(type: Model.self, decoder: JSONDecoder())\n    .mapError { DataError.decoding($0 as! DecodingError) }\n```\n\n3. **Never to failable bridge**: When combining infallible and failable publishers:\n```swift\nlet infallible = Just(\"default\").setFailureType(to: Error.self)\nlet failable = urlSession.dataTaskPublisher(for: url).mapError { $0 as Error }\ninfallible.merge(with: failable)\n```\n\n4. **Error erasure at boundaries**: Use `mapError { $0 as Error }` at API boundaries when the concrete error type is an implementation detail.\n\nThe strictness of Combine's error types is a double-edged sword: it prevents accidental error mishandling but requires explicit transformations that can clutter pipelines. The try* operators always producing `Error` (not a specific type) is a common pain point that often forces mapError calls to recover type specificity."
  },
  {
    "topic": "combine",
    "level": 5,
    "question": "How does Combine's subscription lifecycle interact with Swift's memory management, and what are the subtle retain cycle patterns that can occur in complex publisher chains?",
    "hint": "Think about strong reference chains through operator closures, the subscription-subscriber-publisher retain triangle, how Subjects can create cycles, and the role of cancel() in breaking them.",
    "answer": "Combine's memory management is built on ARC, but the subscription lifecycle introduces unique retain cycle patterns that require careful attention.\n\nThe subscription retain chain:\nWhen a subscription is active, there is a strong reference chain:\n```\nAnyCancellable -> Subscription -> Operator.Inner -> ... -> Upstream Publisher\n                                  Operator.Inner -> Downstream Subscriber\n```\n- Each operator's Inner subscriber holds strong references to both the upstream subscription and the downstream subscriber.\n- This chain keeps the entire pipeline alive as long as the AnyCancellable exists.\n- Calling cancel() or deallocating the AnyCancellable breaks this chain.\n\nRetain cycle pattern 1 — self-referencing closures:\n```swift\nclass ViewModel {\n    var cancellables = Set<AnyCancellable>()\n\n    func bind() {\n        publisher\n            .sink { [weak self] value in\n                self?.process(value) // weak self prevents cycle\n            }\n            .store(in: &cancellables)\n    }\n}\n```\n- Without [weak self], the chain is: ViewModel -> cancellables -> AnyCancellable -> Subscription -> sink closure -> ViewModel.\n- This is a classic retain cycle. The ViewModel can never be deallocated.\n- Using [weak self] breaks the cycle.\n\nRetain cycle pattern 2 — Subject as both source and sink:\n```swift\nclass Coordinator {\n    let subject = PassthroughSubject<Int, Never>()\n    var cancellables = Set<AnyCancellable>()\n\n    init() {\n        subject\n            .map { $0 * 2 }\n            .sink { [weak self] value in\n                self?.subject.send(value + 1) // Potential infinite loop AND retain cycle\n            }\n            .store(in: &cancellables)\n    }\n}\n```\n- The sink closure references subject (through self), and the subscription is stored in cancellables (also through self).\n- Even with [weak self], sending to the same subject from its own sink can create stack overflow through synchronous re-entrancy.\n\nRetain cycle pattern 3 — flatMap with self-referencing factory:\n```swift\ntrigger\n    .flatMap { [weak self] _ -> AnyPublisher<Data, Error> in\n        guard let self else { return Empty().eraseToAnyPublisher() }\n        return self.networkService.fetch() // Strong capture of self through networkService\n    }\n```\n- Each invocation of the flatMap closure may capture self strongly if [weak self] is not used.\n- Inner publishers created by flatMap are retained until they complete or the outer subscription is cancelled.\n\nRetain cycle pattern 4 — handleEvents and side effects:\n```swift\npublisher\n    .handleEvents(\n        receiveOutput: { [weak self] _ in\n            self?.updateUI() // Needs weak self\n        },\n        receiveCancel: { [weak self] in\n            self?.cleanup() // Also needs weak self\n        }\n    )\n```\n- handleEvents closures are retained by the operator, which is retained by the subscription chain.\n\nRetain cycle pattern 5 — share() and multicast:\n```swift\nlet shared = publisher\n    .map { [weak self] value in\n        self?.transform(value) ?? value\n    }\n    .share()\n\n// Multiple subscribers keep the shared subscription alive\n// The shared subscription keeps the map closure alive\n// The map closure keeps self alive (if not weak)\n```\n- share() creates a reference-counted subscription. The upstream stays alive as long as ANY subscriber exists.\n- If the upstream closure captures self strongly, self is retained as long as any subscriber remains.\n\nBreaking cycles — the cancel() contract:\n- cancel() is the primary mechanism for breaking retain chains.\n- AnyCancellable calls cancel() in its deinit.\n- After cancel(), the subscription must release all references to upstream and downstream.\n- Well-implemented operators set their subscriber reference to nil on cancel.\n\nDebugging retain cycles:\n- Use Instruments (Leaks and Allocations) to detect cycles.\n- Set breakpoints in deinit to verify objects are being released.\n- Temporarily replace [weak self] with [unowned self] to crash early if the assumption that self outlives the subscription is wrong.\n\nBest practices:\n1. Always use [weak self] in sink, handleEvents, map, and other closures unless you can prove self outlives the subscription.\n2. Store cancellables in a Set<AnyCancellable> that is deallocated with the owner.\n3. For view controllers, cancel subscriptions in deinit or when the view disappears.\n4. Be especially careful with share() and multicast() — the shared subscription's lifetime may exceed what you expect.\n5. Avoid sending to a Subject from within its own subscription chain to prevent re-entrancy issues.\n6. Use the Memory Graph Debugger in Xcode to visualize retain cycles involving Combine objects."
  },
  {
    "topic": "concurrency",
    "level": 0,
    "question": "What is Grand Central Dispatch (GCD) and what problem does it solve?",
    "hint": "Think about how iOS manages work across multiple CPU cores without you manually creating threads.",
    "answer": "Grand Central Dispatch (GCD) is Apple's low-level concurrency framework that manages the execution of tasks on multicore hardware. It solves the problem of manual thread management by providing a queue-based abstraction.\n\nKey points:\n- GCD uses dispatch queues to schedule work. You submit closures (blocks of work) to queues, and GCD decides which thread to execute them on.\n- It manages a thread pool internally, creating and reusing threads as needed, which is more efficient than manually spawning threads.\n- There are two types of queues: serial queues (execute one task at a time in FIFO order) and concurrent queues (can execute multiple tasks simultaneously).\n- The main queue is a special serial queue tied to the main thread, used for UI updates.\n- GCD handles thread creation, scheduling, and destruction, reducing the risk of common threading bugs like over-subscription (creating too many threads).\n- You interact with GCD primarily through DispatchQueue, using methods like .async {} and .sync {}."
  },
  {
    "topic": "concurrency",
    "level": 0,
    "question": "What is the difference between synchronous and asynchronous execution in the context of DispatchQueue?",
    "hint": "Consider what happens to the calling thread — does it wait or continue?",
    "answer": "Synchronous and asynchronous refer to whether the calling thread blocks while waiting for the dispatched work to complete.\n\nSynchronous (sync):\n- The calling thread is blocked until the submitted task finishes executing.\n- Control returns to the caller only after the work is done.\n- Example: DispatchQueue.global().sync { /* work */ } — the current thread pauses here until the closure completes.\n- Calling sync on the current serial queue causes a deadlock because the queue waits for itself.\n\nAsynchronous (async):\n- The calling thread continues immediately without waiting for the task to finish.\n- The task is enqueued and will execute at some point, but the caller doesn't wait.\n- Example: DispatchQueue.global().async { /* work */ } — the current thread moves to the next line immediately.\n- This is the most common pattern for offloading work to avoid blocking the main thread.\n\nImportant distinction: sync/async describes the behavior of the caller, not the queue. A concurrent queue can still have sync calls that block the caller until that specific task completes."
  },
  {
    "topic": "concurrency",
    "level": 0,
    "question": "What is the main queue in iOS, and why is it important?",
    "hint": "Think about where UI updates must happen and what kind of queue the main queue is.",
    "answer": "The main queue (DispatchQueue.main) is a special serial dispatch queue that executes tasks on the main thread of the application.\n\nKey characteristics:\n- It is a serial queue, meaning tasks execute one at a time in the order they are submitted.\n- All UIKit and SwiftUI updates must occur on the main queue. Updating UI from a background thread leads to undefined behavior — visual glitches, crashes, or data corruption.\n- The main run loop processes events from the main queue, including user touch events, timer fires, and display refresh callbacks.\n- You dispatch back to the main queue from background threads using DispatchQueue.main.async { } to update the UI after completing background work.\n- Calling DispatchQueue.main.sync from the main thread causes a deadlock, because the main thread tries to wait for itself.\n- The main queue is automatically associated with the main thread; you don't create it — you access it via DispatchQueue.main.\n- Long-running tasks should never execute on the main queue because they block the UI, causing the app to appear frozen (unresponsive)."
  },
  {
    "topic": "concurrency",
    "level": 0,
    "question": "What are async/await in Swift, and how do they simplify asynchronous code?",
    "hint": "Compare the readability of nested completion handler callbacks versus linear async/await code.",
    "answer": "async/await is Swift's native concurrency model introduced in Swift 5.5 that allows writing asynchronous code in a sequential, linear style.\n\nKey concepts:\n- A function marked with 'async' can suspend its execution and yield the thread to other work while waiting for a result, rather than blocking the thread.\n- The 'await' keyword marks a suspension point — the place where the function may pause and resume later.\n- This eliminates 'callback hell' or 'pyramid of doom' caused by deeply nested completion handlers.\n\nBefore async/await:\nfetchUser { user in\n    fetchPosts(for: user) { posts in\n        fetchComments(for: posts.first!) { comments in\n            // deeply nested\n        }\n    }\n}\n\nWith async/await:\nlet user = try await fetchUser()\nlet posts = try await fetchPosts(for: user)\nlet comments = try await fetchComments(for: posts.first!)\n\nBenefits:\n- Code reads top-to-bottom like synchronous code.\n- Error handling uses standard try/catch instead of Result types or optional error parameters.\n- The compiler enforces proper usage — you can't forget to call a completion handler.\n- Suspension points are explicitly marked with await, making concurrency visible."
  },
  {
    "topic": "concurrency",
    "level": 1,
    "question": "Explain DispatchGroup and provide a use case where it is essential.",
    "hint": "Think about a scenario where you need to know when multiple independent asynchronous tasks have all completed.",
    "answer": "DispatchGroup allows you to group multiple asynchronous tasks together and get notified when all of them have completed. It acts as a synchronization mechanism for tracking a collection of work items.\n\nHow it works:\n- Call group.enter() before starting each async task.\n- Call group.leave() when each task completes. Every enter() must be balanced with a leave().\n- Use group.notify(queue:) to execute a closure when all tasks have finished.\n- Alternatively, group.wait() blocks the current thread until all tasks complete (use with caution, never on main thread).\n\nExample use case — loading data from multiple API endpoints before displaying a screen:\n\nlet group = DispatchGroup()\nvar user: User?\nvar posts: [Post]?\n\ngroup.enter()\nfetchUser { result in\n    user = result\n    group.leave()\n}\n\ngroup.enter()\nfetchPosts { result in\n    posts = result\n    group.leave()\n}\n\ngroup.notify(queue: .main) {\n    // Both requests finished — update UI\n    display(user: user!, posts: posts!)\n}\n\nImportant considerations:\n- If enter() and leave() are unbalanced, the group never completes (if more enters) or crashes (if more leaves).\n- DispatchGroup works across different queues — tasks can run on different concurrent queues and still be tracked by the same group.\n- You can also pass the group directly to DispatchQueue.async(group:execute:) for automatic enter/leave management."
  },
  {
    "topic": "concurrency",
    "level": 1,
    "question": "What is the difference between Task and Task.detached in Swift concurrency?",
    "hint": "Consider what each type of task inherits from the context where it's created.",
    "answer": "Both Task and Task.detached create unstructured tasks, but they differ in what they inherit from the surrounding context.\n\nTask (unstructured, inheriting):\n- Inherits the actor context of the caller. If created inside a @MainActor context, the task body runs on the main actor.\n- Inherits task-local values from the parent context.\n- Inherits the priority of the calling context (unless explicitly overridden).\n- Most commonly used when you want to launch async work from a synchronous context while preserving actor isolation.\n- Example: Task { await viewModel.loadData() } inside a SwiftUI view runs on the main actor because SwiftUI views are @MainActor.\n\nTask.detached:\n- Does NOT inherit actor context. It runs independently, not bound to any actor.\n- Does NOT inherit task-local values.\n- Does NOT inherit priority (defaults to .unspecified unless you set it).\n- Used when you explicitly want work to run without the calling context's constraints.\n- Example: Task.detached { await processImage() } ensures the work doesn't run on the main actor even if called from a @MainActor context.\n\nWhen to use which:\n- Prefer Task {} in most cases since actor inheritance is usually desirable.\n- Use Task.detached only when you specifically need to opt out of the parent context, such as performing heavy computation that should not block the main actor.\n- Both support cancellation via the returned Task handle: let task = Task { ... }; task.cancel()."
  },
  {
    "topic": "concurrency",
    "level": 1,
    "question": "What is DispatchSemaphore and when should you use it?",
    "hint": "Think of it as a counter that controls how many threads can access a resource simultaneously.",
    "answer": "DispatchSemaphore is a synchronization primitive that controls access to a shared resource by maintaining a count. It allows you to limit the number of concurrent accesses to a resource.\n\nHow it works:\n- Initialize with a count: DispatchSemaphore(value: N), where N is the number of simultaneous accesses allowed.\n- semaphore.wait() decrements the count. If the count becomes negative, the calling thread blocks until another thread signals.\n- semaphore.signal() increments the count, potentially waking a blocked thread.\n\nCommon use cases:\n\n1. Limiting concurrent operations: Control how many network requests run in parallel.\nlet semaphore = DispatchSemaphore(value: 3) // max 3 concurrent\nfor url in urls {\n    DispatchQueue.global().async {\n        semaphore.wait()\n        fetchData(from: url) {\n            semaphore.signal()\n        }\n    }\n}\n\n2. Converting async to sync (use sparingly): Making an async callback-based API behave synchronously.\nlet semaphore = DispatchSemaphore(value: 0)\nvar result: Data?\nasyncFetch { data in\n    result = data\n    semaphore.signal()\n}\nsemaphore.wait() // blocks until signal\n\nImportant warnings:\n- Never call semaphore.wait() on the main thread — it blocks the UI.\n- Semaphores are not compatible with Swift async/await. Using wait() inside an async context can cause deadlocks because the thread may be needed by the cooperative thread pool.\n- For modern Swift concurrency, prefer actors or AsyncStream for resource management instead of semaphores."
  },
  {
    "topic": "concurrency",
    "level": 1,
    "question": "What is an actor in Swift, and what problem does it solve?",
    "hint": "Think about a type that protects its mutable state by allowing only one task to access it at a time.",
    "answer": "An actor is a reference type in Swift (introduced in Swift 5.5) that provides data-race safety by isolating its mutable state. Only one task can execute on an actor at a time, preventing concurrent access to its properties.\n\nKey characteristics:\n- Declared with the 'actor' keyword instead of 'class'.\n- All mutable state inside an actor is isolated — it can only be accessed from within the actor's execution context.\n- External access to an actor's properties and methods requires 'await', because the caller may need to suspend until the actor is available.\n- The compiler enforces actor isolation at compile time, preventing data races statically.\n\nExample:\nactor BankAccount {\n    var balance: Double = 0\n    func deposit(_ amount: Double) { balance += amount }\n    func withdraw(_ amount: Double) -> Bool {\n        guard balance >= amount else { return false }\n        balance -= amount\n        return true\n    }\n}\n\nlet account = BankAccount()\nawait account.deposit(100) // must use await from outside\n\nWhat it solves:\n- Data races: Without actors, two threads modifying the same variable simultaneously can corrupt data. Actors serialize access automatically.\n- Compared to manual locking (NSLock, DispatchQueue for synchronization), actors are checked by the compiler, so you can't accidentally forget to lock.\n\nImportant notes:\n- Actors are reference types (like classes) but cannot be subclassed.\n- Properties marked 'nonisolated' can be accessed without await (must be immutable or Sendable).\n- @MainActor is a global actor that ensures code runs on the main thread."
  },
  {
    "topic": "concurrency",
    "level": 2,
    "question": "Explain structured concurrency in Swift. How do TaskGroup and async let differ, and when would you choose one over the other?",
    "hint": "Think about whether you know the number of child tasks at compile time and whether you need dynamic task creation.",
    "answer": "Structured concurrency means that child tasks have a well-defined relationship with their parent — they must complete before the parent scope exits. This ensures no tasks are accidentally leaked or forgotten.\n\nasync let (concurrent bindings):\n- Used when you have a fixed, known number of concurrent operations at compile time.\n- Each async let starts executing immediately when declared.\n- Results are collected with 'await' when needed.\n- If one fails and throws, other sibling async let tasks are automatically cancelled.\n\nExample:\nasync let profile = fetchProfile()\nasync let friends = fetchFriends()\nasync let photos = fetchPhotos()\nlet result = try await (profile, friends, photos)\n\nTaskGroup (dynamic concurrency):\n- Used when the number of concurrent tasks is determined at runtime.\n- Created via withTaskGroup(of:returning:body:) or withThrowingTaskGroup.\n- You add tasks dynamically with group.addTask { }.\n- Results are collected by iterating over the group (it conforms to AsyncSequence).\n\nExample:\nlet images = await withTaskGroup(of: UIImage?.self) { group in\n    for url in imageURLs { // dynamic count\n        group.addTask { await downloadImage(from: url) }\n    }\n    var results: [UIImage] = []\n    for await image in group {\n        if let image { results.append(image) }\n    }\n    return results\n}\n\nKey differences:\n- async let: static number of tasks, heterogeneous return types allowed, simpler syntax.\n- TaskGroup: dynamic number of tasks, homogeneous return type per group, more flexible.\n\nBoth guarantee that all child tasks complete (or are cancelled) before the enclosing scope exits. This prevents resource leaks and makes reasoning about lifetimes straightforward."
  },
  {
    "topic": "concurrency",
    "level": 2,
    "question": "What is the Sendable protocol, and what are @Sendable closures? Why are they important for Swift concurrency?",
    "hint": "Think about what guarantees are needed when data crosses actor or task boundaries.",
    "answer": "Sendable is a marker protocol that indicates a type can be safely transferred across concurrency domains (between actors, tasks, or threads) without causing data races.\n\nSendable types include:\n- Value types (structs, enums) whose stored properties are all Sendable.\n- Actors (inherently Sendable because they protect their state).\n- Classes that are final and have only immutable (let) Sendable stored properties, or classes that implement their own internal synchronization (marked @unchecked Sendable).\n- Tuples, metatypes, and functions (when marked @Sendable).\n\n@Sendable closures:\n- A closure marked @Sendable promises it captures no mutable state that could cause data races.\n- The compiler checks that @Sendable closures only capture Sendable values.\n- Task { } and Task.detached { } expect @Sendable closures.\n- Actor-isolated methods passed across boundaries must be @Sendable.\n\nExample of a violation:\nvar counter = 0\nTask { // @Sendable closure\n    counter += 1 // Error: mutation of captured var in @Sendable closure\n}\n\nWhy it matters:\n- Without Sendable checking, you could pass a mutable reference type to another actor and mutate it from two isolation domains simultaneously — a data race.\n- Sendable is the compile-time mechanism that prevents this.\n- In Swift 6 strict concurrency mode, all cross-isolation-domain transfers must be Sendable, and violations become errors rather than warnings.\n\n@unchecked Sendable:\n- Used when you know a type is thread-safe (e.g., it uses internal locks) but the compiler can't verify it.\n- Should be used sparingly and with care — it shifts the burden of correctness to the developer."
  },
  {
    "topic": "concurrency",
    "level": 2,
    "question": "How do withCheckedContinuation and withUnsafeContinuation work? When would you use each?",
    "hint": "Think about bridging callback-based APIs into async/await, and the trade-off between safety checks and performance.",
    "answer": "Continuations are the bridge between callback-based (completion handler) code and Swift's async/await. They allow you to wrap legacy asynchronous APIs so they can be called with await.\n\nwithCheckedContinuation / withCheckedThrowingContinuation:\n- Provides runtime checks that the continuation is resumed exactly once.\n- If you resume it zero times, a warning is logged (and the task hangs forever).\n- If you resume it more than once, the program traps (crashes) immediately.\n- Use this during development and in most production code for safety.\n\nwithUnsafeContinuation / withUnsafeThrowingContinuation:\n- No runtime checks — resuming zero or more than once is undefined behavior.\n- Slightly faster because it skips the checking overhead.\n- Use only in performance-critical code where you've thoroughly verified correctness.\n\nExample — wrapping a completion handler API:\nfunc fetchData() async throws -> Data {\n    try await withCheckedThrowingContinuation { continuation in\n        legacyFetch { result in\n            switch result {\n            case .success(let data):\n                continuation.resume(returning: data)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}\n\nCritical rules:\n1. You MUST resume the continuation exactly once on every code path. Forgetting to resume leaves the awaiting task suspended forever.\n2. Resuming more than once is a fatal error (checked) or undefined behavior (unsafe).\n3. The continuation can be resumed from any thread or queue — the runtime handles transitioning back to the right executor.\n4. Store the continuation carefully if it escapes the closure — ensure no code path misses the resume."
  },
  {
    "topic": "concurrency",
    "level": 2,
    "question": "What is cooperative cancellation in Swift concurrency, and how do you implement it?",
    "hint": "Think about why cancellation is not preemptive — the task must check for cancellation itself.",
    "answer": "In Swift concurrency, cancellation is cooperative, meaning that cancelling a task sets a flag but does not forcefully stop the task. The task's code is responsible for checking the cancellation flag and responding appropriately.\n\nHow cancellation propagates:\n- Calling task.cancel() marks the task and all its child tasks as cancelled.\n- Structured child tasks (async let, TaskGroup children) are automatically cancelled when the parent is cancelled.\n- The system APIs (like URLSession.data(from:)) automatically check for cancellation and throw CancellationError.\n\nChecking for cancellation in your code:\n\n1. Task.checkCancellation() — throws CancellationError if cancelled:\nfunc processItems(_ items: [Item]) async throws {\n    for item in items {\n        try Task.checkCancellation()\n        await process(item)\n    }\n}\n\n2. Task.isCancelled — returns a Bool for manual handling:\nfunc processItems(_ items: [Item]) async -> [Result] {\n    var results: [Result] = []\n    for item in items {\n        if Task.isCancelled {\n            break // graceful exit, return partial results\n        }\n        results.append(await process(item))\n    }\n    return results\n}\n\n3. withTaskCancellationHandler — runs a handler when cancellation occurs, useful for integrating with non-async cancellation APIs:\nfunc download(url: URL) async throws -> Data {\n    let urlSessionTask = ...\n    return try await withTaskCancellationHandler {\n        try await urlSessionTask.result\n    } onCancel: {\n        urlSessionTask.cancel() // Cancel the URLSession task\n    }\n}\n\nWhy cooperative:\n- Preemptive cancellation could leave resources in an inconsistent state (half-written files, unclosed connections).\n- Cooperative cancellation lets the task clean up resources, save partial progress, or return partial results gracefully."
  },
  {
    "topic": "concurrency",
    "level": 3,
    "question": "What is actor reentrancy, and why can it lead to subtle bugs? How can you mitigate it?",
    "hint": "Think about what happens to an actor's state between two await calls within a single actor method.",
    "answer": "Actor reentrancy occurs when an actor method suspends (at an await point), allowing other tasks to execute on the same actor before the original method resumes. This means the actor's state may change between suspension points within a single method.\n\nExample of the problem:\nactor ImageCache {\n    var cache: [URL: UIImage] = [:]\n\n    func getImage(for url: URL) async -> UIImage {\n        if let cached = cache[url] { return cached }\n        let image = await downloadImage(from: url) // suspension point\n        // Another task may have already downloaded and cached this URL!\n        cache[url] = image // could overwrite a different result\n        return image\n    }\n}\n\nBetween the await and the next line, another call to getImage(for:) with the same URL could execute, resulting in duplicate downloads and potential inconsistency.\n\nWhy it exists:\n- If actors didn't allow reentrancy, they would deadlock when one actor method awaits another method on the same actor.\n- Reentrancy prevents deadlocks but introduces the possibility of interleaved state changes.\n\nMitigation strategies:\n\n1. Check state again after await:\nif let cached = cache[url] { return cached }\nlet image = await downloadImage(from: url)\nif let cached = cache[url] { return cached } // re-check\ncache[url] = image\nreturn image\n\n2. Use in-progress tracking:\nvar inProgress: [URL: Task<UIImage, Error>] = [:]\nfunc getImage(for url: URL) async throws -> UIImage {\n    if let cached = cache[url] { return cached }\n    if let existing = inProgress[url] { return try await existing.value }\n    let task = Task { await downloadImage(from: url) }\n    inProgress[url] = task\n    let image = try await task.value\n    cache[url] = image\n    inProgress.removeValue(forKey: url)\n    return image\n}\n\n3. Perform all state mutations synchronously (before/after await, never depending on pre-await state being unchanged).\n\nThe key principle: never assume actor state is unchanged after an await point."
  },
  {
    "topic": "concurrency",
    "level": 3,
    "question": "Explain AsyncSequence and AsyncStream. How do you create a custom AsyncStream, and what are the back-pressure considerations?",
    "hint": "Think of AsyncSequence as the async version of Sequence, and AsyncStream as a way to produce async values from non-async sources.",
    "answer": "AsyncSequence is a protocol analogous to Sequence, but where each element is produced asynchronously. You iterate over it using 'for await' (or 'for try await' for throwing sequences).\n\nAsyncStream is a concrete type conforming to AsyncSequence that provides a convenient way to create async sequences from callback-based or imperative code.\n\nCreating an AsyncStream:\n\n1. Continuation-based (most common):\nlet stream = AsyncStream<Int> { continuation in\n    someCallbackAPI { value in\n        continuation.yield(value)\n    }\n    onComplete {\n        continuation.finish()\n    }\n    continuation.onTermination = { @Sendable _ in\n        // cleanup when consumer stops listening\n    }\n}\n\n2. Using AsyncStream.makeStream (Swift 5.9+):\nlet (stream, continuation) = AsyncStream.makeStream(of: Int.self)\n// Pass continuation to producer, stream to consumer\n\nConsuming:\nfor await value in stream {\n    print(value)\n}\n\nBuffering and back-pressure:\n- AsyncStream has a configurable buffering policy set at initialization:\n  - .unbounded: buffers all values (risk of memory growth if consumer is slow)\n  - .bufferingOldest(N): keeps the first N values, drops new ones when full\n  - .bufferingNewest(N): keeps the latest N values, drops old ones when full\n- Unlike Combine or ReactiveSwift, AsyncStream does not support true demand-based back-pressure. The producer has no signal to slow down.\n- If you need back-pressure, you can use a custom AsyncSequence implementation where next() controls the pace, or use channels (e.g., from Swift async-algorithms package).\n\nKey differences from Combine:\n- AsyncSequence is pull-based (consumer calls next()), Combine is push-based.\n- AsyncSequence integrates naturally with async/await and structured concurrency.\n- AsyncStream.Continuation.yield() is safe to call from any context, including non-async code."
  },
  {
    "topic": "concurrency",
    "level": 3,
    "question": "What is priority inversion in the context of Swift concurrency, and how does the runtime mitigate it?",
    "hint": "Consider what happens when a high-priority task is waiting on work being done by a low-priority task.",
    "answer": "Priority inversion occurs when a high-priority task is blocked waiting for a low-priority task to complete, effectively causing the high-priority task to run at the speed of the low-priority task.\n\nScenarios in Swift concurrency:\n\n1. Actor contention: A high-priority task awaits access to an actor that is currently processing a low-priority task. The high-priority task must wait until the low-priority task finishes its synchronous work on the actor.\n\n2. Task dependency: A high-priority task awaits the result of a low-priority Task's value.\n\nHow the Swift runtime mitigates it:\n\n- Priority escalation: When a high-priority task waits on an actor occupied by a low-priority task, the runtime temporarily boosts the low-priority task's priority to match the waiting task. This ensures the blocking work completes faster.\n- This is automatic — developers don't need to manage it manually.\n- Once the low-priority task finishes and the actor is free, the escalated priority is no longer needed.\n\nLimitations:\n- Priority escalation works for actor-bound work but may not cover all scenarios (e.g., external system resources, semaphores, locks).\n- GCD also performs priority escalation for dispatch queues, but mixing GCD synchronization with Swift concurrency can create situations the runtime can't resolve.\n\nBest practices:\n- Keep critical sections on actors short to reduce the window for priority inversion.\n- Avoid mixing concurrency mechanisms (e.g., don't use DispatchSemaphore inside async code).\n- Be mindful of task priorities when designing task hierarchies.\n- Use Task(priority:) explicitly when the default inherited priority is not appropriate.\n- DispatchSemaphore and os_unfair_lock do not participate in Swift's priority escalation, so using them in async contexts can cause unresolvable priority inversions."
  },
  {
    "topic": "concurrency",
    "level": 3,
    "question": "What is DispatchWorkItem, and how can you use it for cancellation and dependency management with GCD?",
    "hint": "Think about how DispatchWorkItem gives you a handle to submitted GCD work that you can cancel or wait on.",
    "answer": "DispatchWorkItem is an object that encapsulates a block of work to be dispatched on a queue. Unlike plain closures, it provides a handle that supports cancellation, notification on completion, and synchronous waiting.\n\nKey capabilities:\n\n1. Cancellation:\nlet workItem = DispatchWorkItem {\n    for i in 0..<1000 {\n        if workItem.isCancelled { return } // must check manually\n        process(i)\n    }\n}\nDispatchQueue.global().async(execute: workItem)\n// Later:\nworkItem.cancel() // sets isCancelled flag; does not stop execution automatically\n\nCancellation is cooperative — like Swift concurrency's Task cancellation. Calling cancel() sets a flag, but the closure must check workItem.isCancelled periodically.\n\nIf the work item hasn't started yet and is still in the queue, cancelling it prevents it from executing.\n\n2. Notification on completion:\nworkItem.notify(queue: .main) {\n    print(\"Work completed or cancelled\")\n}\nThis is similar to DispatchGroup.notify — it runs a closure on the specified queue when the work item finishes.\n\n3. Synchronous waiting:\nworkItem.wait() // blocks current thread until the work item finishes\n// Can also specify a timeout:\nlet result = workItem.wait(timeout: .now() + 5)\n\n4. QoS and flags:\nlet workItem = DispatchWorkItem(qos: .userInitiated, flags: .barrier) {\n    // barrier work on a concurrent queue\n}\n\nUse cases:\n- Debouncing: Cancel the previous work item and create a new one on each input change (e.g., search-as-you-type).\n- Timeout patterns: Start work and cancel it if it doesn't complete within a deadline.\n- Barrier writes: Use with .barrier flag on concurrent queues for reader-writer synchronization."
  },
  {
    "topic": "concurrency",
    "level": 4,
    "question": "How does Swift 6 strict concurrency checking work? What are the key changes from Swift 5, and what does the @preconcurrency attribute do?",
    "hint": "Think about how warnings become errors, and how @preconcurrency helps with gradual migration of pre-Swift-6 modules.",
    "answer": "Swift 6 introduces strict concurrency checking, making data-race safety a compile-time guarantee. What were warnings in Swift 5.x become hard errors in Swift 6 mode.\n\nKey changes in Swift 6:\n\n1. Sendable enforcement: All values crossing isolation boundaries must conform to Sendable. Passing a non-Sendable type across actors or to a Task is a compile error.\n\n2. Global variable isolation: Mutable global and static variables must be isolated to an actor or marked as nonisolated(unsafe). Unprotected global mutable state is disallowed.\n\n3. Implicit @MainActor inference: More contexts correctly infer @MainActor isolation, but this can cause errors where code implicitly assumed it was nonisolated.\n\n4. Closure Sendable checking: Closures passed across isolation boundaries are checked for captured mutable state.\n\n@preconcurrency attribute:\n- Applied to import statements: @preconcurrency import SomeModule\n  - Suppresses Sendable warnings/errors for types from that module.\n  - Used when a dependency hasn't adopted Sendable yet. Without it, using their types across isolation domains would be an error.\n  - The compiler still checks where possible but downgrades errors to warnings for types from that module.\n\n- Applied to protocols: @preconcurrency protocol MyDelegate\n  - Allows existing conformances that don't meet new async/Sendable requirements to compile without errors, easing migration.\n\n- Applied to declarations: @preconcurrency func oldCallback(_ handler: @escaping () -> Void)\n  - Indicates the declaration predates concurrency and shouldn't require @Sendable on its closure parameters.\n\nMigration strategy:\n1. Enable strict concurrency checking incrementally with -strict-concurrency=targeted or =complete in Swift 5.x to see warnings.\n2. Fix warnings by adding Sendable conformances, actor isolation, or @unchecked Sendable where internal synchronization exists.\n3. Use @preconcurrency import for third-party modules not yet updated.\n4. Switch to Swift 6 language mode when all warnings are resolved."
  },
  {
    "topic": "concurrency",
    "level": 4,
    "question": "Explain the concept of isolation regions and transferring sendability in Swift concurrency. What does 'sending' mean in the context of function parameters?",
    "hint": "Think about how the compiler tracks which isolation domain owns a value, and what happens when you transfer that value to another domain.",
    "answer": "Isolation regions and sending are part of Swift's advanced concurrency model for tracking data-race safety without requiring everything to be Sendable.\n\nIsolation Regions:\n- The compiler conceptually assigns each value to an 'isolation region' — a group of values that may reference each other and are accessed from the same concurrency domain.\n- A value in a region isolated to Actor A cannot be simultaneously accessed from Actor B.\n- When you pass a value to another isolation domain, the compiler must ensure either: (a) the value is Sendable, or (b) the sending context gives up access to it (transferring ownership of the region).\n\nSending parameters (SE-0430):\n- A 'sending' parameter annotation indicates that the caller must transfer the value to the callee, giving up further access.\n- The compiler ensures the caller doesn't use the value after passing it.\n\nfunc process(_ value: sending MyClass) async { ... }\n\nlet obj = MyClass()\nawait process(obj)\n// obj is no longer accessible here — compiler error if used\n\nThis allows non-Sendable types to cross isolation boundaries safely because the compiler guarantees no concurrent access.\n\nSending return values:\n- A function can return a 'sending' value, indicating the returned value is not retained by the callee's isolation domain.\n- The caller receives exclusive ownership.\n\nfunc createWorker() -> sending Worker { ... }\n\nPractical impact:\n- Reduces the need for @unchecked Sendable annotations.\n- Allows more natural patterns with non-Sendable reference types across isolation boundaries.\n- The compiler tracks the region of each value through assignments, function calls, and returns.\n- If you try to send a value while retaining a reference to it (or to something in the same region), the compiler produces an error.\n\nThis is part of Swift's approach to making concurrency safe without requiring all types to be Sendable, which would be overly restrictive for many existing codebases."
  },
  {
    "topic": "concurrency",
    "level": 4,
    "question": "What are custom executors in Swift concurrency, and how would you implement one? What is the relationship between actors and executors?",
    "hint": "Think about how an actor decides which thread or dispatch queue to run its tasks on.",
    "answer": "Custom executors allow you to control where an actor's code executes — on which thread, queue, or threading context. By default, actors use the cooperative thread pool managed by Swift's runtime, but custom executors let you override this.\n\nRelationship between actors and executors:\n- Every actor has an associated executor (its 'unownedExecutor' property).\n- When you await an actor's method, the runtime uses its executor to schedule the work.\n- The default executor uses the global cooperative thread pool.\n- Custom executors let actors run on a specific DispatchQueue, a dedicated thread, or any other scheduling mechanism.\n\nImplementing a custom executor (SE-0392):\n\nfinal class QueueExecutor: SerialExecutor {\n    let queue: DispatchQueue\n    init(queue: DispatchQueue) { self.queue = queue }\n\n    func enqueue(_ job: consuming ExecutorJob) {\n        let unownedJob = UnownedExecutorJob(job)\n        queue.async {\n            unownedJob.runSynchronously(on: self.asUnownedSerialExecutor())\n        }\n    }\n\n    func asUnownedSerialExecutor() -> UnownedSerialExecutor {\n        UnownedSerialExecutor(ordinary: self)\n    }\n}\n\nUsing it with an actor:\nactor DatabaseActor {\n    private let executor: QueueExecutor\n\n    init(queue: DispatchQueue) {\n        self.executor = QueueExecutor(queue: queue)\n    }\n\n    nonisolated var unownedExecutor: UnownedSerialExecutor {\n        executor.asUnownedSerialExecutor()\n    }\n}\n\nUse cases:\n1. Ensuring an actor runs on a specific queue (e.g., a database that requires all operations on the same serial queue for transaction safety).\n2. Interop with legacy code that requires specific threading (e.g., Core Data's private queue context).\n3. Running actors on the main thread without @MainActor (using DispatchQueue.main as the executor).\n4. Testing — injecting a deterministic executor for reproducible concurrency tests.\n\nImportant:\n- The executor must be serial (SerialExecutor protocol) to maintain actor isolation guarantees.\n- Custom executors break the cooperative thread pool assumption, so use them judiciously.\n- @MainActor is essentially a global actor with a custom executor backed by the main dispatch queue."
  },
  {
    "topic": "concurrency",
    "level": 4,
    "question": "How does Operation and OperationQueue compare to GCD and Swift concurrency? What unique capabilities does Operation provide that GCD does not?",
    "hint": "Think about dependency graphs between operations, KVO-observable state, and the ability to cancel or pause individual units of work.",
    "answer": "Operation and OperationQueue are a higher-level abstraction built on top of GCD, providing object-oriented task management with features that raw GCD dispatch queues don't offer.\n\nUnique capabilities of Operation/OperationQueue:\n\n1. Dependencies between operations:\nlet download = DownloadOperation()\nlet parse = ParseOperation()\nlet display = DisplayOperation()\nparse.addDependency(download)\ndisplay.addDependency(parse)\nqueue.addOperations([download, parse, display], waitUntilFinished: false)\n// Executes in order: download -> parse -> display\n\nGCD has no built-in dependency mechanism between arbitrary work items.\n\n2. Observable state via KVO:\n- Operations expose isExecuting, isFinished, isCancelled, isReady as KVO-observable properties.\n- You can observe an operation's lifecycle from outside.\n\n3. Cancellation with cleanup:\n- Operations have a built-in cancel() method and isCancelled property.\n- Subclasses override main() and check isCancelled periodically.\n- OperationQueue respects cancellation — cancelled operations that haven't started are skipped.\n\n4. Max concurrent operations:\nqueue.maxConcurrentOperationCount = 3\n// Built-in throttling without manual semaphore management\n\n5. Quality of Service:\noperation.qualityOfService = .userInitiated\n// Per-operation QoS, not just per-queue\n\n6. Pause and resume:\nqueue.isSuspended = true // pauses dequeueing new operations\n\nWhen to use each:\n- GCD: Simple async dispatch, one-off background tasks, barrier synchronization, precise queue control.\n- Operation: Complex task graphs with dependencies, reusable operation subclasses (e.g., network operations), when you need cancellation and progress tracking per task.\n- Swift concurrency (async/await): Modern Swift code, structured concurrency with TaskGroup, when you want compiler-enforced safety.\n\nOperation with async/await:\n- You can bridge Operations with async/await using continuations.\n- For new code, Swift concurrency's TaskGroup with cancellation often replaces OperationQueue, but Operation remains valuable for complex dependency graphs and legacy integration."
  },
  {
    "topic": "concurrency",
    "level": 5,
    "question": "Explain how Swift's cooperative thread pool works internally. What are the implications of blocking a cooperative thread, and how does this interact with GCD's thread pool?",
    "hint": "Consider the fixed thread pool size, what happens when all threads are blocked, and why mixing sync primitives with async code is dangerous.",
    "answer": "Swift's concurrency runtime uses a cooperative thread pool with a fixed width, typically equal to the number of CPU cores. This design is fundamental to understanding why certain patterns are dangerous in async/await code.\n\nHow the cooperative thread pool works:\n- The pool maintains a limited number of threads (usually one per CPU core).\n- When an async function hits an await/suspension point, it yields the thread back to the pool, which can then run another task.\n- This is fundamentally different from GCD, which can create hundreds of threads (thread explosion).\n- Tasks are scheduled cooperatively: the runtime trusts that code will suspend (yield) regularly rather than blocking threads.\n\nWhat happens when you block a cooperative thread:\n- Using DispatchSemaphore.wait(), os_unfair_lock, NSLock, Thread.sleep(), or any blocking call inside an async context holds onto a thread without yielding it.\n- With only N threads available (N = core count), blocking even a few can exhaust the pool.\n- If all cooperative threads are blocked, no async task can make progress — including the ones that the blocked threads are waiting on. This creates a deadlock.\n\nExample of a deadlock:\nfunc dangerous() async {\n    let semaphore = DispatchSemaphore(value: 0)\n    Task {\n        semaphore.signal() // needs a cooperative thread to run\n    }\n    semaphore.wait() // blocks this cooperative thread\n    // If all threads are blocked like this, signal() never executes\n}\n\nInteraction with GCD's thread pool:\n- GCD and Swift concurrency maintain separate thread pools.\n- GCD can spin up many threads (up to system limits), while Swift's pool is fixed.\n- Dispatching from async code to a GCD queue (DispatchQueue.global().async) moves work off the cooperative pool, which is sometimes used as a workaround for blocking operations.\n- However, awaiting back from GCD into async code requires the cooperative pool to have available threads.\n- Custom executors (like @MainActor) bridge between the two worlds — @MainActor uses the main dispatch queue, not the cooperative pool.\n\nBest practices:\n- Never use blocking synchronization primitives inside async functions.\n- Keep synchronous work on actors short to avoid monopolizing a cooperative thread.\n- Use Task.yield() in long-running CPU-bound loops to give other tasks a chance.\n- If you must call blocking code, dispatch it to a GCD queue and bridge back with a continuation.\n- The runtime's thread-per-core model ensures optimal performance only when code cooperates by suspending rather than blocking."
  },
  {
    "topic": "concurrency",
    "level": 5,
    "question": "What are data races versus race conditions? How does Swift concurrency eliminate data races but not race conditions? Provide examples of each.",
    "hint": "Think about the distinction between low-level memory corruption (data race) and high-level logical ordering issues (race condition).",
    "answer": "Data races and race conditions are related but distinct concurrency bugs. Swift 6's strict concurrency eliminates data races at compile time but cannot prevent race conditions.\n\nData Race:\n- Occurs when two threads access the same memory location simultaneously, and at least one is a write, with no synchronization.\n- Results in undefined behavior: corrupted memory, crashes, or unpredictable values.\n- This is a low-level memory safety issue.\n\nExample:\nvar counter = 0\nDispatchQueue.concurrentPerform(iterations: 1000) { _ in\n    counter += 1 // Data race: unsynchronized read-modify-write\n}\n// counter might be any value, not necessarily 1000\n\nSwift concurrency prevents this: the compiler won't let you mutate a non-isolated, non-Sendable variable from multiple isolation domains.\n\nRace Condition:\n- A logical bug where the correctness of the program depends on the timing or ordering of events.\n- No memory corruption — each individual access is properly synchronized — but the overall outcome is wrong.\n- This is a high-level semantic issue that the compiler cannot detect.\n\nExample (even with actors, which prevent data races):\nactor BankAccount {\n    var balance: Double = 100\n    func getBalance() -> Double { balance }\n    func withdraw(_ amount: Double) { balance -= amount }\n}\n\n// Two tasks checking and withdrawing:\nTask {\n    let balance = await account.getBalance() // 100\n    if balance >= 80 {\n        await account.withdraw(80) // succeeds\n    }\n}\nTask {\n    let balance = await account.getBalance() // 100 (before first withdrawal)\n    if balance >= 80 {\n        await account.withdraw(80) // also succeeds! Balance is now -60\n    }\n}\n\nEach access is actor-isolated and data-race-free, but the check-then-act pattern is a race condition. The balance is read and the withdrawal is performed in separate actor calls, allowing interleaving.\n\nFix: Combine the check and action into a single atomic actor operation:\nfunc withdrawIfSufficient(_ amount: Double) -> Bool {\n    guard balance >= amount else { return false }\n    balance -= amount\n    return true\n}\n\nWhy Swift can't prevent race conditions:\n- Race conditions depend on application-level invariants and business logic.\n- They require semantic understanding of what the code is trying to achieve.\n- The compiler ensures memory safety (no data races) but cannot reason about whether your actor methods are called in the right order.\n\nKey takeaway: Actors and Sendable make your code data-race-free, but correct concurrent algorithms still require careful design to avoid race conditions."
  },
  {
    "topic": "concurrency",
    "level": 5,
    "question": "How do GlobalActors work internally? How would you define a custom GlobalActor, and what are the implications for code that uses @MainActor versus a custom global actor?",
    "hint": "Think about global actors as singletons that provide a shared isolation domain, and how @MainActor is just a specific global actor backed by the main queue.",
    "answer": "A GlobalActor is a mechanism that provides a single, shared actor instance accessible globally, allowing you to isolate code to a specific execution context without passing actor references around.\n\n@MainActor is the most well-known global actor, but you can create custom ones.\n\nHow global actors work internally:\n- A global actor is defined by a type conforming to the GlobalActor protocol, which requires a static 'shared' property returning an actor instance.\n- Any function, property, type, or closure annotated with a global actor attribute is isolated to that actor's shared instance.\n- All code marked with the same global actor shares the same serial isolation domain — they never run concurrently with each other.\n\nDefining a custom global actor:\n@globalActor\nactor DatabaseActor {\n    static let shared = DatabaseActor()\n}\n\n// Usage:\n@DatabaseActor\nfunc saveToDB(_ data: Data) {\n    // This runs on DatabaseActor.shared\n}\n\n@DatabaseActor\nclass DatabaseManager {\n    var cache: [String: Data] = [:] // isolated to DatabaseActor\n    func fetch(_ key: String) -> Data? { cache[key] }\n}\n\n@MainActor specifics:\n- @MainActor.shared uses a custom executor backed by DispatchQueue.main.\n- All @MainActor code runs on the main thread, making it safe for UI work.\n- SwiftUI views are implicitly @MainActor.\n- @MainActor functions can be called synchronously from the main thread without await.\n\nCustom global actor implications:\n- A custom global actor (like @DatabaseActor) uses the default cooperative thread pool executor unless you provide a custom executor.\n- This means @DatabaseActor code doesn't run on any specific thread — it just guarantees serialization.\n- If you need a specific thread/queue, you must implement a custom executor on the actor.\n\nInteraction between global actors:\n- Calling from @MainActor to @DatabaseActor requires await (crossing isolation domains).\n- The Sendable checker ensures values passed between them are safe.\n- You can mark individual methods as 'nonisolated' to opt out of the global actor's isolation.\n\nCompile-time behavior:\n- The compiler infers global actor isolation transitively: if a protocol requirement is @MainActor, conforming implementations are also @MainActor.\n- Closures capture the isolation context: a closure created in @MainActor context is @MainActor-isolated unless explicitly marked otherwise.\n- Global actor annotations are part of the type system — @MainActor () -> Void is a different type from () -> Void.\n\nPerformance consideration:\n- Global actors create a single serialization point. If too much unrelated work is marked with the same global actor, it becomes a bottleneck.\n- Use separate global actors for logically independent subsystems (e.g., @DatabaseActor, @NetworkActor) to allow parallelism between them."
  },
  {
    "topic": "concurrency",
    "level": 5,
    "question": "Explain thread-safe patterns in Swift beyond actors. When and why would you use os_unfair_lock, NSLock, pthread_mutex, or dispatch queue synchronization instead of actors?",
    "hint": "Think about synchronous code paths where you can't use await, performance-critical sections, and legacy interop.",
    "answer": "While actors are the recommended approach for thread safety in Swift concurrency, there are legitimate scenarios where lower-level synchronization primitives are necessary or preferred.\n\nWhy not always use actors:\n1. Actors require async context — you can't await in synchronous code without bridging.\n2. Actor access has overhead: hopping to the actor's executor, potential suspension, and reentrancy.\n3. Some code must be synchronous (e.g., property getters, Objective-C delegate callbacks, real-time audio processing).\n4. Fine-grained locking can be more performant than actor serialization for simple operations.\n\nos_unfair_lock:\n- Fastest lock on Apple platforms. Spins briefly, then blocks.\n- Must be used carefully: must not be copied (use it via a pointer or wrap in a class), cannot be used recursively.\n- In Swift, typically wrapped in a class to avoid value-type copying:\nfinal class UnfairLock: @unchecked Sendable {\n    private var _lock = os_unfair_lock()\n    func lock() { os_unfair_lock_lock(&_lock) }\n    func unlock() { os_unfair_lock_unlock(&_lock) }\n    func withLock<T>(_ body: () throws -> T) rethrows -> T {\n        lock(); defer { unlock() }; return try body()\n    }\n}\n- Best for: very short critical sections, property accessors, counters.\n- Note: Does not support priority inversion avoidance like pthread_mutex with priority inheritance.\n\nNSLock / NSRecursiveLock:\n- Higher-level Objective-C lock. NSLock is non-recursive; NSRecursiveLock allows the same thread to lock multiple times.\n- Easier to use than os_unfair_lock (reference type, no copy issues).\n- Slower than os_unfair_lock but supports try-lock and timed lock.\n- In Swift 5.9+ / macOS 13.3+, NSLock has a withLock(_:) method.\n\npthread_mutex_t:\n- POSIX mutex, configurable (normal, recursive, error-checking).\n- Supports priority inheritance via PTHREAD_PRIO_INHERIT, which prevents priority inversion.\n- More complex to manage (must call pthread_mutex_destroy).\n- Useful for cross-platform code or when priority inheritance is needed.\n\nDispatch queue synchronization:\n- Use a serial queue with sync {} for mutual exclusion.\n- Concurrent queue with barrier flag for reader-writer locks:\nprivate let queue = DispatchQueue(label: \"rw\", attributes: .concurrent)\nfunc read() -> Value { queue.sync { _value } }\nfunc write(_ v: Value) { queue.async(flags: .barrier) { self._value = v } }\n- Higher overhead than raw locks but supports complex patterns.\n- GCD participates in priority escalation (unlike os_unfair_lock).\n\nSwift Mutex (SE-0424, Swift 6+):\n- New Mutex type in Synchronization framework.\n- Designed for Swift: value-type safe, Sendable, works with borrowing closures.\nlet mutex = Mutex<Int>(0)\nmutex.withLock { $0 += 1 }\n- Preferred over os_unfair_lock for new Swift 6 code.\n\nChoosing the right primitive:\n- Synchronous + simple + performance-critical: Mutex (Swift 6) or os_unfair_lock\n- Synchronous + recursive locking needed: NSRecursiveLock or pthread_mutex\n- Synchronous + priority inheritance needed: pthread_mutex with PTHREAD_PRIO_INHERIT\n- Reader-writer pattern: Concurrent DispatchQueue + barrier\n- Async context + mutable state: Actor (always prefer if possible)\n- Never mix blocking locks with async code on the cooperative thread pool."
  },
  {
    "topic": "concurrency",
    "level": 5,
    "question": "What is async let and how does its cancellation behavior differ from explicit TaskGroup task cancellation? Explain the lifecycle of an async let binding including what happens if the result is never awaited.",
    "hint": "Think about what happens at the end of the scope where async let is declared — does the runtime just discard it?",
    "answer": "async let creates a child task that starts executing immediately upon declaration and whose lifecycle is tied to the enclosing scope. It has specific cancellation and cleanup semantics that differ from TaskGroup.\n\nLifecycle of async let:\n1. Declaration: The child task starts running immediately, concurrently with the code that follows.\n2. Await: When you write 'await' on the async let variable, the current task suspends until the child task produces a result.\n3. Scope exit: If the enclosing scope exits without awaiting the result, the runtime implicitly cancels the child task and awaits its completion before proceeding.\n\nExample:\nfunc loadData() async throws -> Data {\n    async let config = fetchConfig()      // starts immediately\n    async let userData = fetchUserData()  // starts immediately, concurrently\n    \n    guard isEnabled else {\n        return Data() // config and userData tasks are cancelled and awaited here\n    }\n    \n    return try await merge(config, userData)\n}\n\nImplicit cancellation and await on scope exit:\n- This is the critical behavior: the runtime inserts an implicit 'try await' at the end of the scope.\n- If the async let task throws and you never explicitly awaited it, the error is silently discarded.\n- The scope cannot exit until the child task actually finishes (even after cancellation), because cancellation is cooperative.\n- This means a non-cooperating child task can block scope exit indefinitely.\n\nComparison with TaskGroup:\n- TaskGroup cancellation: group.cancelAll() marks all child tasks as cancelled. You still iterate over the group to collect results. You have explicit control over how results are handled.\n- async let cancellation: Automatic and implicit. You don't choose whether to await — the compiler/runtime forces it.\n- TaskGroup error handling: withThrowingTaskGroup automatically cancels remaining tasks when one throws. You can catch and handle errors per-task.\n- async let error handling: If multiple async let bindings throw, only the first error propagates when you try await them. Others are cancelled and their errors discarded.\n\nMemory and resource implications:\n- Since async let must be awaited (explicitly or implicitly), resources held by the child task are guaranteed to be released within the enclosing scope.\n- This is stronger than unstructured Task, where forgetting to await or cancel can leak resources.\n- The implicit await ensures structured concurrency's guarantee: no child task outlives its parent scope.\n\nCompiler enforcement:\n- async let variables must be declared with 'async let' (not 'let' or 'var').\n- Using the result without 'await' is a compile error.\n- The variable cannot be captured by escaping closures (ensuring it stays within structured concurrency)."
  },
  {
    "topic": "memory",
    "level": 0,
    "question": "What is ARC (Automatic Reference Counting) in Swift, and how does it manage memory?",
    "hint": "Think about what happens when you create, share, and stop using class instances.",
    "answer": "ARC (Automatic Reference Counting) is Swift's memory management system for reference types (classes). It automatically tracks how many references point to each class instance and deallocates the instance when no references remain.\n\nHow it works:\n- Every class instance has a reference count (retain count).\n- When you create a new reference to an instance (assign it to a variable, pass it to a function, store it in a collection), ARC increments the reference count.\n- When a reference goes out of scope, is set to nil, or is reassigned, ARC decrements the reference count.\n- When the reference count reaches zero, ARC deallocates the instance and frees its memory. The deinit method is called just before deallocation.\n\nExample:\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    deinit { print(\"\\(name) is deallocated\") }\n}\n\nvar ref1: Person? = Person(name: \"Alice\") // count = 1\nvar ref2 = ref1  // count = 2\nref1 = nil       // count = 1\nref2 = nil       // count = 0 -> \"Alice is deallocated\"\n\nKey points:\n- ARC only applies to reference types (classes, closures). Value types (structs, enums) are copied, not reference-counted.\n- ARC works at compile time — the compiler inserts retain and release calls automatically. There is no runtime garbage collector.\n- Unlike garbage collection (used in Java, C#), ARC is deterministic: objects are freed immediately when their reference count hits zero, not at some later GC cycle.\n- ARC cannot automatically resolve retain cycles (circular strong references), which is why weak and unowned references exist."
  },
  {
    "topic": "memory",
    "level": 0,
    "question": "What is the difference between strong, weak, and unowned references in Swift?",
    "hint": "Think about whether each reference type keeps the object alive and what happens when the object is deallocated.",
    "answer": "These three reference types differ in how they affect an object's lifetime and what happens when the referenced object is deallocated.\n\nStrong references (default):\n- Increment the reference count, keeping the object alive.\n- The object cannot be deallocated as long as any strong reference exists.\n- All references are strong by default: var person = Person()\n- Can cause retain cycles if two objects strongly reference each other.\n\nWeak references:\n- Do NOT increment the reference count.\n- The referenced object can be deallocated even while weak references to it exist.\n- Automatically set to nil when the object is deallocated.\n- Must be declared as optional var (never let, never non-optional): weak var delegate: MyDelegate?\n- Use when the referenced object may be deallocated during the reference's lifetime.\n- Common use: delegate patterns, parent-child relationships where the child references the parent.\n\nUnowned references:\n- Do NOT increment the reference count (like weak).\n- NOT set to nil when the object is deallocated (unlike weak).\n- Accessing an unowned reference after the object is deallocated is a runtime crash (like force-unwrapping nil).\n- Can be declared as non-optional: unowned let owner: Owner\n- Use when you are certain the referenced object will always outlive the reference.\n- Common use: a child object that always has an owner and cannot exist without it.\n\nWhen to use each:\n- Strong: default, when you want to keep the object alive.\n- Weak: when the referenced object might be deallocated first (delegates, optional relationships).\n- Unowned: when the referenced object is guaranteed to outlive the referencing object and you want to avoid optionals."
  },
  {
    "topic": "memory",
    "level": 0,
    "question": "What is the difference between value types and reference types in Swift regarding memory?",
    "hint": "Think about structs versus classes — what happens when you assign one variable to another.",
    "answer": "Value types and reference types have fundamentally different memory behaviors in Swift.\n\nValue types (struct, enum, tuple, and basic types like Int, String, Array):\n- Each variable holds its own independent copy of the data.\n- Assigning a value type to another variable, or passing it to a function, creates a copy.\n- Stored on the stack (in most cases) which is fast to allocate and deallocate.\n- No reference counting overhead.\n- Mutations to one copy do not affect other copies.\n- Thread-safe by nature since each context has its own copy.\n\nvar a = [1, 2, 3]\nvar b = a     // b is an independent copy\nb.append(4)   // a is still [1, 2, 3], b is [1, 2, 3, 4]\n\nReference types (class, closures, actors):\n- Variables hold a reference (pointer) to a shared instance on the heap.\n- Assigning or passing a reference type shares the same instance — no copy is made.\n- Managed by ARC (reference counting).\n- Heap allocation is slower than stack allocation.\n- Mutations through any reference affect all references to the same instance.\n\nclass Container { var items = [1, 2, 3] }\nlet a = Container()\nlet b = a       // b points to same instance\nb.items.append(4)  // a.items is now [1, 2, 3, 4] too\n\nMemory layout:\n- Stack: Value types, function call frames, local variables. Automatically freed when scope exits. Very fast (just moving the stack pointer).\n- Heap: Reference type instances. Requires allocation (finding free memory) and deallocation (ARC). Slower, but allows shared ownership and dynamic lifetimes.\n\nNote: Large value types or value types containing reference types may still be heap-allocated by the compiler for performance reasons, but semantically they behave as copies."
  },
  {
    "topic": "memory",
    "level": 1,
    "question": "Explain [weak self] versus [unowned self] in closure capture lists. When would you use each?",
    "hint": "Think about the lifetime relationship between the object and the closure — will the object always outlive the closure?",
    "answer": "[weak self] and [unowned self] are capture list annotations that prevent retain cycles by capturing self without incrementing the reference count.\n\n[weak self]:\n- self becomes Optional (weak var self: ClassName?).\n- If self is deallocated while the closure still exists, self becomes nil.\n- You must unwrap self before using it (self?.method() or guard let self).\n- Safe — never crashes due to deallocation.\n\nonComplete = { [weak self] in\n    guard let self else { return }\n    self.updateUI()\n}\n\n[unowned self]:\n- self remains non-optional.\n- If self is deallocated while the closure still exists and the closure accesses self, it crashes (like accessing a dangling pointer).\n- Slightly more performant than weak because it avoids optional wrapping and zeroing overhead.\n\nonComplete = { [unowned self] in\n    self.updateUI() // crashes if self is deallocated\n}\n\nWhen to use [weak self]:\n- When the closure might outlive self.\n- Async operations: network calls, timers, delayed dispatches.\n- Stored closures where the lifecycle is unclear.\n- When in doubt, always use [weak self] — it's the safe default.\n\nWhen to use [unowned self]:\n- When you can guarantee self will always outlive the closure.\n- Example: A closure that configures a view's subview, where the subview is owned by the view.\n- Example: A closure stored on a child object whose lifecycle is strictly within the parent's.\n- Another pattern: lazy properties with closures:\nlazy var fullName: String = { [unowned self] in\n    \"\\(self.firstName) \\(self.lastName)\"\n}()\n// self is guaranteed to exist when a lazy property is first accessed\n\nPractical advice:\n- Use [weak self] by default for safety.\n- Use [unowned self] only when you have a clear ownership guarantee and want cleaner code without optionals.\n- In modern Swift, 'guard let self' after [weak self] gives you the same ergonomics as [unowned self] with the safety of weak."
  },
  {
    "topic": "memory",
    "level": 1,
    "question": "How do retain cycles occur with the delegate pattern, and how do you prevent them?",
    "hint": "Think about the ownership relationship: which object should own the other, and which should hold a weak reference?",
    "answer": "The delegate pattern commonly causes retain cycles because the delegating object holds a reference to its delegate, and the delegate often holds a reference back to the delegating object.\n\nThe problem:\nclass TableView {\n    var delegate: TableViewDelegate? // strong reference\n}\n\nclass ViewController {\n    let tableView = TableView() // strong reference\n\n    func setup() {\n        tableView.delegate = self // strong reference back\n    }\n    // ViewController -> tableView -> delegate -> ViewController (cycle!)\n}\n\nThe delegate is never deallocated because the reference count never reaches zero.\n\nSolution — declare the delegate property as weak:\nclass TableView {\n    weak var delegate: TableViewDelegate?\n}\n\nThis breaks the cycle because the delegate reference doesn't increment the reference count of the ViewController.\n\nProtocol requirement for weak:\n- weak can only be applied to class types (reference types).\n- The delegate protocol must be constrained to AnyObject (or class):\nprotocol TableViewDelegate: AnyObject {\n    func didSelectRow(at index: Int)\n}\n- Without : AnyObject, the protocol could be adopted by a struct, which can't be weak.\n\nWhy weak and not unowned:\n- Delegates are typically set by an external object and may be deallocated independently.\n- Using weak safely handles the case where the delegate is deallocated before the delegating object.\n- The delegating object can check if delegate is nil before calling it.\n\nAlternative approaches:\n- Closure-based callbacks instead of delegates (still need [weak self] in closures).\n- Combine publishers instead of delegates.\n- In UIKit, most Apple delegate properties are already declared weak (e.g., UITableView.delegate, UICollectionView.delegate).\n\nRule of thumb: The delegating object (child) should hold a weak reference to its delegate (parent/owner). The parent strongly owns the child, the child weakly references the parent."
  },
  {
    "topic": "memory",
    "level": 1,
    "question": "What is Copy-on-Write (COW) in Swift, and which types use it?",
    "hint": "Think about how Swift avoids unnecessary copying of large value types until a mutation actually occurs.",
    "answer": "Copy-on-Write (COW) is an optimization where a value type shares its underlying storage with copies until one of the copies is mutated. Only then is a real copy of the storage made.\n\nHow it works:\n- When you assign an Array (or other COW type) to another variable, both variables point to the same underlying buffer.\n- A copy of the buffer is only made when one of the variables is mutated.\n- This is checked using the isKnownUniquelyReferenced() function internally — if only one reference exists, mutation can happen in place.\n\nExample:\nvar a = [1, 2, 3, 4, 5] // allocates buffer\nvar b = a                // b shares the same buffer (no copy)\n// At this point, a and b point to the same memory\n\nb.append(6)              // NOW a copy is made because b is being mutated\n// a = [1, 2, 3, 4, 5], b = [1, 2, 3, 4, 5, 6] (separate buffers)\n\nStandard library types that use COW:\n- Array\n- Dictionary\n- Set\n- String\n- Data\n- ContiguousArray\n\nPerformance implications:\n- Passing arrays and dictionaries around is cheap (O(1)) as long as you don't mutate the copies.\n- The actual O(n) copy only happens at the point of mutation.\n- This gives value semantics (independent copies) with reference-type performance for read-heavy patterns.\n\nCustom COW:\n- You can implement COW for your own types by wrapping storage in a reference type:\nfinal class Storage { var data: [Int] }\nstruct MyCollection {\n    private var storage: Storage\n    mutating func modify() {\n        if !isKnownUniquelyReferenced(&storage) {\n            storage = Storage(data: storage.data) // copy on write\n        }\n        storage.data.append(42)\n    }\n}\n\nImportant note: Custom structs do NOT get COW automatically. Only the standard library types and types you explicitly implement COW for have this optimization."
  },
  {
    "topic": "memory",
    "level": 2,
    "question": "Explain closure capture semantics in Swift. What is the difference between capturing a value type by value versus by reference?",
    "hint": "Think about the difference between capturing a variable (reference to its storage) and capturing its current value at the time the closure is created.",
    "answer": "Swift closures capture variables from their surrounding scope by reference by default — they share the same storage as the original variable. This is true even for value types.\n\nDefault capture (by reference):\nvar count = 0\nlet closure = {\n    print(count) // captures the variable 'count', not its value\n}\ncount = 10\nclosure() // prints 10, not 0\n\nThe closure captures a reference to the variable's storage. Changes to the original variable are visible inside the closure and vice versa.\n\nCapture by value (using capture list):\nvar count = 0\nlet closure = { [count] in\n    print(count) // captures the VALUE of count at closure creation time\n}\ncount = 10\nclosure() // prints 0\n\nThe capture list [count] copies the current value of count into the closure at the time the closure is created. The captured copy is independent of the original.\n\nImportant details:\n\n1. Capture lists create a local constant:\n[count] creates a 'let' copy inside the closure. You cannot mutate it unless you explicitly write [var count]:\nvar x = 0\nlet closure = { [var x] in\n    x += 1 // modifies the local copy only\n}\n\n2. Reference types in capture lists:\n[object] copies the reference, not the object. Both the original and captured reference point to the same instance:\nclass Box { var value = 0 }\nvar box = Box()\nlet closure = { [box] in\n    print(box.value) // same instance as outside\n}\nbox.value = 42\nclosure() // prints 42\n\n3. [weak self] and [unowned self] are capture list annotations that affect how the reference is held, not whether a copy is made.\n\n4. Multiple captures:\n{ [weak self, count, box] in ... }\n\nWhen closures cause confusion:\nvar functions: [() -> Int] = []\nfor i in 0..<5 {\n    functions.append { i } // captures 'i' by reference\n}\n// All closures print the final value of i from each loop iteration\n// In Swift, for-in loop variables are actually re-created each iteration,\n// so each closure captures a different instance. This is different from\n// languages like JavaScript (var) where this is a common pitfall.\n\nSwift's for-in actually creates a new binding per iteration, so this specific case works correctly. But be careful with while loops or variables declared outside loops."
  },
  {
    "topic": "memory",
    "level": 2,
    "question": "What is an autorelease pool in Swift, and when would you need to use one?",
    "hint": "Think about loops that create many temporary Objective-C objects that won't be released until the current run loop cycle ends.",
    "answer": "An autorelease pool is a mechanism inherited from Objective-C's memory management that collects objects marked for deferred release and releases them all when the pool is drained.\n\nIn Swift, you use autoreleasepool { } to create an explicit autorelease pool scope.\n\nBackground:\n- In Objective-C (and when bridging to ObjC), some methods return autoreleased objects — objects whose release is deferred until the current autorelease pool is drained.\n- The main run loop automatically drains an autorelease pool at the end of each event loop iteration.\n- In normal usage, this is fine because temporary objects are cleaned up frequently.\n\nWhen you need explicit autorelease pools:\n\n1. Tight loops creating many temporary objects:\nfor i in 0..<1_000_000 {\n    autoreleasepool {\n        let image = UIImage(contentsOfFile: paths[i]) // large ObjC object\n        processImage(image)\n        // image is released here, not after the entire loop\n    }\n}\n\nWithout the autoreleasepool, all 1,000,000 images would accumulate in memory until the loop finishes and the run loop drains the outer pool.\n\n2. Background threads:\n- Background threads (GCD, manual threads) don't automatically have an autorelease pool.\n- GCD dispatch blocks do get an implicit pool, but manually created threads (Thread) may not.\n- Foundation's Thread.detachNewThread creates a pool, but if you use pthread directly, you may need your own.\n\n3. Command-line tools / non-UI apps:\n- Without a run loop, there's no automatic draining. Autorelease pools prevent unbounded memory growth.\n\nWhen you don't need it:\n- Pure Swift code that doesn't bridge to Objective-C typically doesn't create autoreleased objects.\n- ARC in Swift uses retain/release directly for Swift objects, not autorelease.\n- Short-lived operations that return to the run loop quickly.\n\nPractical modern usage:\n- Processing large collections of images, strings, or data using Foundation/UIKit APIs.\n- Batch processing (importing many Core Data objects in a loop).\n- Any loop where memory usage spikes due to temporary ObjC-bridged objects."
  },
  {
    "topic": "memory",
    "level": 2,
    "question": "What are zombie objects in iOS development? How do you enable them, and what problem do they solve?",
    "hint": "Think about what happens when you try to send a message to a deallocated object, and how zombies help you diagnose it.",
    "answer": "Zombie objects are a debugging tool that helps diagnose EXC_BAD_ACCESS crashes caused by accessing deallocated objects (dangling pointers).\n\nThe problem:\n- When an object is deallocated, its memory is freed and may be reused for other allocations.\n- If code still holds a pointer to that memory and tries to access it, the behavior is undefined:\n  - The memory might contain a completely different object, causing bizarre behavior.\n  - The memory might be unmapped, causing EXC_BAD_ACCESS.\n  - The crash might happen far from the actual bug, making it extremely hard to debug.\n\nHow zombies work:\n- When enabled, instead of deallocating an object, the runtime replaces it with a special _NSZombie_OriginalClassName object.\n- The zombie object occupies the same memory but intercepts all messages (method calls).\n- When you try to use a zombie, instead of crashing randomly, you get a clear error message:\n  \"-[_NSZombie_MyClass doSomething]: message sent to deallocated instance 0x6000012345\"\n- This tells you exactly which class was deallocated and what method was called on it.\n\nEnabling zombie objects:\n1. In Xcode: Edit Scheme > Run > Diagnostics > check \"Zombie Objects\"\n2. This sets the NSZombieEnabled environment variable to YES.\n\nWhat zombies tell you:\n- The class name of the deallocated object.\n- The method that was attempted on the deallocated object.\n- The memory address, which you can use in the Memory Graph Debugger or Instruments to find the allocation backtrace.\n\nImportant caveats:\n- Zombie objects are never deallocated, so memory usage grows continuously. Only use for debugging, never in production.\n- They are most useful for Objective-C or bridged code. Pure Swift code with ARC rarely has dangling pointer issues unless using Unmanaged or unsafe pointers.\n- In Swift, accessing an unowned reference to a deallocated object also crashes, and zombies can help identify the object.\n\nModern relevance:\n- Less common in pure Swift (ARC + weak references prevent most dangling pointers).\n- Still valuable when working with Objective-C interop, C libraries, or unsafe Swift code.\n- Useful for debugging legacy codebases or complex Objective-C/Swift mixed projects."
  },
  {
    "topic": "memory",
    "level": 2,
    "question": "What is the memory layout difference between a class and a struct in Swift? What overhead does a class instance have?",
    "hint": "Think about heap metadata, reference counting storage, and alignment requirements.",
    "answer": "Classes and structs have fundamentally different memory layouts due to their reference-type vs value-type nature.\n\nStruct memory layout:\n- Stored inline: struct properties are laid out contiguously in memory, one after another.\n- No metadata overhead — the memory contains only the stored properties (plus padding for alignment).\n- Allocated on the stack (typically) or inline within the containing type.\n- Size = sum of all stored property sizes + alignment padding.\n\nstruct Point {\n    var x: Double // 8 bytes\n    var y: Double // 8 bytes\n}  // Total: 16 bytes, no overhead\n\nClass memory layout:\n- Allocated on the heap via malloc.\n- Has metadata overhead before the stored properties:\n  - Type metadata pointer (8 bytes on 64-bit): points to the class's type metadata, used for dynamic dispatch, type checking (is/as), and protocol conformance.\n  - Reference count storage (8 bytes): contains the strong reference count, unowned reference count, and flags. On 64-bit, this is a single 64-bit word with bit fields.\n- Total overhead: 16 bytes of header before any stored properties.\n\nclass PointClass {\n    var x: Double // 8 bytes\n    var y: Double // 8 bytes\n}  // Heap allocation: 16 (header) + 16 (properties) = 32 bytes minimum\n   // Plus malloc overhead (typically 16 bytes for bookkeeping)\n\nAdditional class costs:\n- Heap allocation: finding free memory, thread-safe allocation (malloc uses locks/thread-local caches).\n- Reference counting: every retain/release is an atomic operation (thread-safe increment/decrement), which is more expensive than a simple increment.\n- Deallocation: returning memory to the heap, calling deinit.\n- Cache locality: heap objects may be scattered in memory, causing CPU cache misses. Structs in arrays are contiguous, which is cache-friendly.\n\nYou can inspect layout at runtime:\nMemoryLayout<Point>.size      // 16\nMemoryLayout<Point>.stride    // 16\nMemoryLayout<Point>.alignment // 8\n\n// For classes, this measures the reference (pointer) size:\nMemoryLayout<PointClass>.size // 8 (size of a pointer)\n// The actual instance is on the heap and is larger\n\nPractical impact:\n- For small, frequently-created types (coordinates, colors, ranges), structs avoid heap allocation overhead.\n- For large types or types that need identity/shared ownership, classes are appropriate despite the overhead."
  },
  {
    "topic": "memory",
    "level": 3,
    "question": "Explain tagged pointers in Apple's runtime. How do they optimize memory for small objects like NSNumber and short NSString?",
    "hint": "Think about encoding the actual value directly inside the pointer itself instead of allocating a separate heap object.",
    "answer": "Tagged pointers are a runtime optimization where small object values are stored directly in the pointer variable itself, eliminating the need for heap allocation entirely.\n\nHow regular object pointers work:\n- A pointer is typically 8 bytes (64-bit) and stores a memory address pointing to a heap-allocated object.\n- On modern 64-bit systems, not all 64 bits are needed for addressing (Apple uses ~36-47 bits for actual memory addresses).\n- The remaining bits can be repurposed.\n\nHow tagged pointers work:\n- The least significant bit (or a specific bit pattern) indicates the pointer is 'tagged' — it's not a real heap address.\n- Some bits encode the class type (NSNumber, NSDate, short NSString, etc.).\n- The remaining bits store the actual value inline.\n- No heap allocation, no reference counting, no deallocation needed.\n\nExample with NSNumber:\n- NSNumber storing the integer 42 as a regular object: requires 32+ bytes (16 byte header + stored value + malloc overhead).\n- NSNumber storing 42 as a tagged pointer: the value 42 is encoded directly in the 8-byte pointer. Zero heap allocation.\n\nTypes that use tagged pointers:\n- NSNumber (for small integers, floats that fit)\n- NSDate (for common date ranges)\n- NSString (for very short strings, up to about 7 ASCII characters — called NSTaggedPointerString)\n- NSIndexPath (for short paths)\n\nPerformance benefits:\n- No heap allocation or deallocation.\n- No reference counting overhead — retain/release are no-ops for tagged pointers.\n- Better cache performance — the data is in the variable itself.\n- Faster comparison — can compare pointer values directly.\n\nHow the runtime handles it:\n- objc_retain and objc_release check if a pointer is tagged before performing reference counting. If tagged, they return immediately.\n- Message dispatch for tagged pointers goes through a special fast path.\n\nSwift implications:\n- When you bridge Swift Int/Double to NSNumber, the runtime may use tagged pointers for small values.\n- You generally don't interact with tagged pointers directly in Swift, but they affect performance of bridged Foundation types.\n- isKnownUniquelyReferenced() always returns false for tagged pointers (since they aren't real heap objects).\n\nSecurity:\n- Apple obfuscates tagged pointer values with a per-process random key (since iOS 14/macOS 11) to prevent exploitation."
  },
  {
    "topic": "memory",
    "level": 3,
    "question": "How does Swift's side table work for weak references, and what changed from the older weak reference implementation?",
    "hint": "Think about where the weak reference count and the zeroing information are stored, and why moving this off the main object matters.",
    "answer": "Side tables are an auxiliary data structure used by Swift's runtime to manage weak references efficiently, introduced to optimize the common case where objects have no weak references.\n\nThe old approach (pre-side tables):\n- The reference count word in the object's header stored strong count, unowned count, and weak count together.\n- The object's memory couldn't be freed until both the strong AND weak reference counts reached zero.\n- This meant a weakly-referenced object stayed in memory (as a sort of zombie) even after all strong references were gone, until all weak references were also cleared.\n- This wasted memory for large objects that had lingering weak references.\n\nThe side table approach:\n- The object header contains an inline reference count word.\n- When the first weak reference to an object is created, the runtime allocates a small side table entry.\n- The side table entry contains:\n  - A pointer back to the object.\n  - The weak reference count.\n  - The unowned reference count (moved here when the side table is created).\n- The object's header is updated to point to the side table (using a flag bit to indicate the pointer is to a side table, not inline counts).\n- Weak references point to the side table entry, not directly to the object.\n\nHow weak reference zeroing works:\n1. When the strong reference count reaches zero, the object is deinitialized and its memory is freed.\n2. The side table entry remains alive (it's a small, separate allocation).\n3. When a weak reference is accessed, the runtime checks the side table. If the object has been deallocated, it returns nil and decrements the weak count.\n4. When the weak reference count in the side table reaches zero, the side table entry itself is freed.\n\nBenefits:\n- The object's memory (which could be large) is freed as soon as strong references reach zero, regardless of weak references.\n- The side table is tiny (a few pointers), so keeping it alive for lingering weak references wastes minimal memory.\n- Objects with no weak references have zero overhead — no side table is allocated.\n- The side table acts as a stable indirection point, making weak reference zeroing simpler and more efficient.\n\nPerformance:\n- Creating the first weak reference has a one-time cost of allocating the side table.\n- Subsequent weak reference operations are just atomic increments/decrements on the side table.\n- Accessing a weak reference involves one extra indirection through the side table."
  },
  {
    "topic": "memory",
    "level": 3,
    "question": "What is withExtendedLifetime in Swift, and when is it necessary?",
    "hint": "Think about a situation where ARC might deallocate an object before you're done using its resources, because the compiler sees no more references to it.",
    "answer": "withExtendedLifetime(_:_:) is a Swift standard library function that ensures an object stays alive (is not deallocated by ARC) for the duration of a closure, even if there are no apparent references to it within that scope.\n\nWhy it's needed:\n- Swift's ARC is aggressive — the compiler may release an object as soon as it detects the last use of a reference, even before the end of the scope.\n- This is an optimization: early release frees memory sooner.\n- But it can cause problems when you access the object's resources through raw pointers or unmanaged references that ARC doesn't track.\n\nExample of the problem:\nclass ResourceHolder {\n    let buffer: UnsafeMutablePointer<Int>\n    init() {\n        buffer = .allocate(capacity: 10)\n    }\n    deinit {\n        buffer.deallocate() // frees the buffer\n    }\n}\n\nfunc process() {\n    let holder = ResourceHolder()\n    let ptr = holder.buffer // ARC may release 'holder' here\n    // because 'holder' is never used again\n    ptr.pointee = 42 // DANGER: buffer may already be deallocated!\n}\n\nSolution:\nfunc process() {\n    let holder = ResourceHolder()\n    withExtendedLifetime(holder) {\n        let ptr = holder.buffer\n        ptr.pointee = 42 // safe: holder is guaranteed alive\n    }\n}\n\nCommon use cases:\n1. Working with UnsafePointer/UnsafeMutablePointer derived from an object's properties.\n2. Passing object data to C APIs via raw pointers.\n3. Ensuring an object stays alive during Objective-C message sends that ARC can't track.\n4. When using Unmanaged references for performance.\n\nAlternatives:\n- _ = holder at the end of the scope forces a reference to exist, but this is fragile and unclear.\n- withExtendedLifetime is explicit and communicates intent.\n\nSignature:\nfunc withExtendedLifetime<T, Result>(_ x: T, _ body: () throws -> Result) rethrows -> Result\nfunc withExtendedLifetime<T, Result>(_ x: T, _ body: (T) throws -> Result) rethrows -> Result\n\nThe second form passes the value into the closure, making it clear you're using it.\n\nNote: This is primarily needed when working with unsafe code. In normal Swift code with strong references, ARC handles lifetimes correctly and withExtendedLifetime is unnecessary."
  },
  {
    "topic": "memory",
    "level": 3,
    "question": "What is an indirect enum in Swift, and why is it needed from a memory perspective?",
    "hint": "Think about what happens when an enum case needs to contain a value of the same enum type — how would the compiler determine the size?",
    "answer": "An indirect enum is an enum where one or more cases store their associated values on the heap (via a pointer) instead of inline. The 'indirect' keyword tells the compiler to add a level of indirection.\n\nWhy it's needed — the size problem:\n- The compiler must know the size of every type at compile time.\n- An enum's size is determined by its largest case (plus a tag for discriminating cases).\n- If an enum case contains the same enum type as an associated value, this creates a recursive type with infinite size.\n\nWithout indirect:\nenum Expression {\n    case number(Int)\n    case addition(Expression, Expression) // ERROR: recursive type has infinite size\n}\n// size(Expression) = max(size(Int), 2 * size(Expression)) — unsolvable!\n\nWith indirect:\nindirect enum Expression {\n    case number(Int)\n    case addition(Expression, Expression) // OK!\n}\n// Each Expression case stores a pointer (8 bytes) to heap-allocated storage\n\nYou can also mark individual cases as indirect:\nenum Expression {\n    case number(Int)                              // stored inline\n    indirect case addition(Expression, Expression) // heap-allocated\n}\n\nMemory layout:\n- Without indirect: all associated values are stored inline in the enum's memory.\n- With indirect: the associated values are boxed — allocated on the heap, and the enum stores a pointer to that allocation.\n\nTradeoffs:\n- Pros: Enables recursive data structures (trees, linked lists, ASTs) using enums.\n- Cons: Heap allocation for each indirect case, reference counting overhead, pointer indirection (cache miss potential).\n\nCommon use cases:\n- Abstract syntax trees (AST): indirect enum Expr { case literal(Int); indirect case binary(Expr, Op, Expr) }\n- Linked lists: indirect enum List<T> { case empty; case node(T, List<T>) }\n- Tree structures: indirect enum Tree<T> { case leaf(T); case branch(Tree<T>, Tree<T>) }\n- JSON representation: indirect enum JSON { case object([String: JSON]); case array([JSON]); ... }\n\nNote: When 'indirect' is on the entire enum, ALL cases are heap-allocated, even simple ones like .number(Int). For optimal performance, apply 'indirect' only to the recursive cases."
  },
  {
    "topic": "memory",
    "level": 4,
    "question": "Explain the internal structure of Swift's reference count word. How are strong, unowned, and weak counts stored, and what are the different states an object can be in during its lifecycle?",
    "hint": "Think about the bit layout in the refcount word and the transitions: live, deiniting, deinited, freed, and dead.",
    "answer": "Swift's reference counting is implemented using a compact inline reference count stored in the object header, with overflow to side tables for complex cases.\n\nObject header layout (64-bit):\n- Word 1: Type metadata pointer (isa pointer) — 8 bytes.\n- Word 2: Reference count word — 8 bytes.\n\nInline reference count word bit layout:\nThe 64-bit refcount word packs multiple fields using bit manipulation:\n- Strong reference count (upper bits): The number of strong references minus one (biased by 1).\n- Unowned reference count (lower bits): The number of unowned references plus one (the object itself counts as one unowned reference to itself).\n- Flags:\n  - isDeinitingBit: Set when the object begins deinitialization.\n  - hasSideTableBit: Indicates the refcount word is actually a pointer to a side table.\n  - isImmortalBit: For objects that should never be deallocated (certain global singletons).\n  - useSlowRCBit: Indicates non-standard refcounting (bridged ObjC objects).\n\nObject lifecycle states:\n\n1. LIVE: Strong count > 0. Object is fully usable.\n   - Strong references work normally.\n   - Unowned references work normally.\n   - Weak references (via side table) work normally.\n\n2. DEINITING: Strong count reached 0, deinit is running.\n   - Triggered when the last strong reference is released.\n   - isDeinitingBit is set.\n   - New strong references are forbidden (retaining a deiniting object traps).\n   - Existing unowned references still keep the memory alive.\n   - Weak references return nil.\n   - The object's deinit runs.\n\n3. DEINITED: deinit has completed, but unowned references still exist.\n   - Object memory is still allocated (because unowned count > 0).\n   - Accessing an unowned reference to this object traps (runtime error).\n   - Memory hasn't been freed yet to allow the unowned trap diagnostic.\n\n4. FREED: Both strong and unowned counts are zero, but weak references exist.\n   - The object's memory has been freed.\n   - Only the side table remains alive.\n   - Weak references read from the side table and discover the object is gone, returning nil.\n   - This state only exists when side tables are used.\n\n5. DEAD: All reference counts (strong, unowned, weak) are zero.\n   - All memory is freed (object and side table if any).\n\nSide table transition:\n- When the first weak reference is created, a side table is allocated.\n- The inline refcount word is replaced with a pointer to the side table (hasSideTableBit set).\n- The side table stores: strong count, unowned count, weak count, and a back-pointer to the object.\n- This allows the object's memory to be freed while the side table keeps a small footprint for weak reference zeroing.\n\nOptimizations:\n- Atomic operations are used for thread-safe reference counting.\n- The runtime uses fast paths for common cases (no side table, no overflow).\n- Objects that never have weak references avoid side table overhead entirely.\n- Immortal objects skip all reference counting operations."
  },
  {
    "topic": "memory",
    "level": 4,
    "question": "How does Swift's memory alignment work, and how does it affect struct layout and performance? Explain padding, stride, and how you can optimize memory usage with property ordering.",
    "hint": "Think about how the CPU requires data to be at addresses that are multiples of the data's size, and how the compiler adds padding.",
    "answer": "Memory alignment is a requirement (or optimization) where data types are placed at memory addresses that are multiples of their alignment value. The CPU accesses aligned data more efficiently; misaligned access can be slower or even cause crashes on some architectures.\n\nKey concepts:\n\n- Alignment: The address of a value must be a multiple of its alignment. For basic types, alignment typically equals the type size: Int8 aligns to 1, Int16 to 2, Int32 to 4, Int64/Double to 8.\n- Size: The actual bytes the value occupies.\n- Stride: The distance between consecutive elements in a contiguous array. stride >= size, accounting for trailing padding.\n\nPadding in structs:\nThe compiler inserts padding bytes between properties to satisfy alignment requirements.\n\nstruct Inefficient {\n    var a: Bool    // 1 byte + 7 bytes padding (to align next Int64)\n    var b: Int64   // 8 bytes\n    var c: Bool    // 1 byte + 7 bytes trailing padding (stride alignment)\n}\n// size = 24, stride = 24, alignment = 8\n// Actual data: 10 bytes, padding waste: 14 bytes!\n\nstruct Efficient {\n    var b: Int64   // 8 bytes\n    var a: Bool    // 1 byte\n    var c: Bool    // 1 byte + 6 bytes trailing padding\n}\n// size = 16, stride = 16, alignment = 8\n// Actual data: 10 bytes, padding waste: 6 bytes\n\nSame data, different ordering: 24 bytes vs 16 bytes — a 33% reduction.\n\nRules the compiler follows:\n1. Each property is placed at the next available address that satisfies its alignment.\n2. The struct's overall alignment is the maximum alignment of any of its properties.\n3. The stride is the size rounded up to the nearest multiple of the struct's alignment.\n\nSwift's approach:\n- Unlike C, Swift does not guarantee struct layout matches declaration order. The compiler is allowed to reorder stored properties to minimize padding (though in practice, current Swift compilers often preserve declaration order for ABI stability of frozen types).\n- For @frozen structs (library evolution mode), the layout is fixed and matches declaration order.\n- For non-frozen structs, the compiler has freedom to optimize layout.\n\nUsing MemoryLayout:\nMemoryLayout<Inefficient>.size       // 17 (minimum bytes needed)\nMemoryLayout<Inefficient>.stride     // 24 (with trailing padding)\nMemoryLayout<Inefficient>.alignment  // 8\n\nPerformance implications:\n- Smaller structs mean more data fits in CPU cache lines (typically 64 bytes), improving cache hit rates.\n- Arrays of well-aligned structs have better memory access patterns.\n- For performance-critical data structures (game entities, signal processing buffers), property ordering matters.\n\nPractical optimization:\n- Order properties from largest alignment to smallest: Int64 > Int32 > Int16 > Bool.\n- Group same-sized types together.\n- Use MemoryLayout to verify your assumptions.\n- For extreme optimization, consider packing with bitfields or using manual memory layout with UnsafeMutableRawPointer."
  },
  {
    "topic": "memory",
    "level": 4,
    "question": "Explain the differences between MRC (Manual Reference Counting) and ARC. What operations does ARC automate, and what are the historical reasons for the transition?",
    "hint": "Think about retain, release, and autorelease calls that developers used to write manually.",
    "answer": "MRC (Manual Reference Counting, also called Manual Retain-Release or MRR) was the memory management model in Objective-C before ARC was introduced in 2011 (Xcode 4.2, iOS 5).\n\nMRC — manual management:\nDevelopers explicitly called retain, release, and autorelease:\n\n// Creating: count = 1\nNSString *name = [[NSString alloc] initWithString:@\"Hello\"];\n\n// Passing to another owner:\n[someObject setName:name]; // someObject calls [name retain] internally\n\n// Done with it: count decremented\n[name release];\n\n// Returning from a method without immediate release:\n- (NSString *)fullName {\n    NSString *result = [[NSString alloc] initWithFormat:@\"%@ %@\", first, last];\n    return [result autorelease]; // released later when autorelease pool drains\n}\n\nMRC rules developers had to follow:\n1. If you alloc/init, copy, mutableCopy, or new an object, you own it and must release it.\n2. If you receive an object from any other method, you don't own it. If you want to keep it, retain it.\n3. When done, release objects you own. Balance every retain with a release.\n4. Never release an object you don't own.\n\nCommon MRC bugs:\n- Over-release: Releasing too many times, causing a dangling pointer and crash (EXC_BAD_ACCESS).\n- Under-release (memory leak): Forgetting to release, so the object is never freed.\n- Use-after-free: Accessing an object after releasing it.\n- Autorelease confusion: Not understanding when autoreleased objects would be invalidated.\n\nARC — automatic management:\n- The compiler inserts retain, release, and autorelease calls automatically at compile time.\n- Developers never write retain/release/autorelease.\n- The compiler analyzes code paths and places retain/release at optimal points.\n- Still uses reference counting (not garbage collection) — deterministic deallocation.\n\nWhat ARC automates:\n- Inserting retain when a strong reference is established.\n- Inserting release when a strong reference goes away (scope exit, reassignment, deallocation).\n- Inserting autorelease when needed for Objective-C convention compliance.\n- Managing the lifetime of temporary objects.\n- Optimizing away redundant retain/release pairs.\n\nWhat ARC does NOT handle:\n- Retain cycles: The programmer must still use weak/unowned to break cycles.\n- Non-object resources: File handles, sockets, GPU buffers — must be manually managed or use deinit.\n- Core Foundation objects: CF types need explicit CFRelease (unless using toll-free bridging annotations).\n\nHistorical context:\n- Before ARC, memory bugs were the #1 source of crashes in iOS apps.\n- Apple first tried garbage collection on macOS (Objective-C GC in 10.5), but it had pause-time issues and was never suitable for iOS.\n- ARC was designed as a compile-time solution with zero runtime overhead compared to hand-written retain/release.\n- ARC was so successful that Apple deprecated Objective-C GC and removed it in macOS 10.12.\n- Swift was designed from the start with ARC — it has never supported manual reference counting."
  },
  {
    "topic": "memory",
    "level": 5,
    "question": "Explain how Copy-on-Write is implemented internally in Swift's Array. Walk through what happens at the memory level when an array is shared and then mutated, including the role of isKnownUniquelyReferenced.",
    "hint": "Think about the ContiguousArrayBuffer class, the reference count check, and what happens during the copy at the buffer level.",
    "answer": "Swift's Array uses a class-based internal buffer to enable Copy-on-Write (COW). Understanding the implementation requires examining the layered structure and the mutation path.\n\nInternal structure:\n- Array<Element> is a struct containing a single stored property: a reference to _ArrayBuffer<Element>.\n- _ArrayBuffer wraps _ContiguousArrayBuffer<Element> (for native Swift arrays) or _NSArrayBuffer (for bridged NSArrays).\n- _ContiguousArrayBuffer is a class (ManagedBuffer subclass) that holds:\n  - count: number of elements\n  - capacity: allocated capacity\n  - A contiguous block of memory for elements (tail-allocated after the header)\n\nSharing (assignment with no copy):\nvar a = [1, 2, 3, 4, 5]\nvar b = a\n// Both a and b hold strong references to the same _ContiguousArrayBuffer instance\n// Buffer's strong reference count = 2\n// No element copying occurs — O(1) operation\n\nMutation path (b.append(6)):\n1. The mutating method on Array checks if the buffer is uniquely referenced.\n2. It calls isKnownUniquelyReferenced(&_buffer) — this is a Swift runtime function that atomically checks the strong reference count.\n3. If count == 1 (unique): mutate the buffer in place. No copy needed.\n4. If count > 1 (shared): a new buffer is allocated, elements are copied, and the struct's buffer reference is updated.\n\nDetailed mutation flow when shared:\n1. b.append(6) triggers _ArrayBuffer.makeUniqueIfNeeded()\n2. isKnownUniquelyReferenced returns false (count = 2)\n3. A new _ContiguousArrayBuffer is allocated with sufficient capacity.\n4. Elements are copied (memcpy for trivial types, or element-by-element retain for reference types).\n5. b's internal buffer reference now points to the new buffer (strong ref count = 1).\n6. a's buffer reference count drops to 1 (it was 2, b's release makes it 1).\n7. The new element is appended to b's new buffer.\n8. From this point, a and b are fully independent.\n\nisKnownUniquelyReferenced internals:\n- Reads the object's reference count atomically.\n- Returns false if: count > 1, object is an Objective-C object (bridged arrays), or the object uses a side table with weak references.\n- For tagged-pointer objects, always returns false.\n- This is a constant-time (O(1)) operation.\n\nBridged NSArray case:\n- When an NSArray is bridged to [Element], the buffer wraps the NSArray.\n- isKnownUniquelyReferenced always returns false for ObjC objects.\n- Any mutation triggers a full copy from NSArray into a native Swift buffer.\n- Subsequent mutations use the normal COW path.\n\nCapacity and growth strategy:\n- When the buffer needs to grow, Swift typically doubles the capacity (amortized O(1) append).\n- The exact growth formula considers the current count and requested capacity.\n- reserveCapacity(_:) allows pre-allocating to avoid repeated copies.\n\nThread safety:\n- isKnownUniquelyReferenced uses atomic loads, making the uniqueness check thread-safe.\n- However, Array itself is NOT thread-safe: concurrent read+write or write+write from multiple threads is a data race.\n- The COW check prevents issues from sequential copies but doesn't provide thread safety.\n\nPerformance characteristics:\n- Passing arrays is always O(1) (reference copy).\n- First mutation after sharing is O(n) (element copy).\n- Subsequent mutations (while unique) are O(1) amortized.\n- For value-type elements, the copy is a memcpy (very fast). For reference-type elements, each element needs a retain call."
  },
  {
    "topic": "memory",
    "level": 5,
    "question": "Describe the deinit execution order and semantics in Swift class hierarchies. What are the guarantees, pitfalls, and patterns around deinit? How does deinit interact with weak/unowned references and actor isolation?",
    "hint": "Think about the order of deinit calls in inheritance, what self looks like during deinit, and the special concurrency rules for actor deinit.",
    "answer": "Swift's deinit has specific semantics that become nuanced with inheritance, reference types, and actor isolation.\n\nExecution order in class hierarchies:\n- deinit is called in reverse order of initialization: the most derived (leaf) class's deinit runs first, then its superclass's, up to the root class.\n- This is the opposite of init order (base class initializes first).\n- Each class's deinit only has access to properties it declared — by the time the superclass's deinit runs, the subclass's properties have already been deinitialized.\n\nclass Base {\n    deinit { print(\"Base deinit\") } // runs second\n}\nclass Derived: Base {\n    let resource: Resource\n    deinit { print(\"Derived deinit\") } // runs first\n}\n\nWhat self looks like during deinit:\n- self is fully valid at the start of your deinit — all properties are still accessible.\n- The strong reference count is 0, but the object memory is still alive.\n- You can call methods on self, access properties, and pass self to functions.\n- HOWEVER: if you leak self (store it somewhere that creates a new strong reference), behavior is undefined. The runtime may trap or corrupt memory.\n\nWeak reference behavior during deinit:\n- Once deinit begins, weak references to the object return nil.\n- This happens before your deinit code runs — so even at the first line of deinit, any weak reference elsewhere already sees nil.\n- This prevents resurrection: no one can obtain a new strong reference through a weak reference.\n\nUnowned reference behavior during deinit:\n- Accessing an unowned reference to an object that is deiniting traps.\n- The unowned reference count keeps the memory allocated (not the object alive) until it reaches zero.\n\nActor deinit rules:\n- An actor's deinit is nonisolated — it does NOT run on the actor's executor.\n- This means you cannot access the actor's isolated state in deinit without special handling.\n- This is because deinit can run on any thread when the last reference is released.\n- Accessing isolated properties from a nonisolated deinit would require an await, which is not allowed in deinit (deinit is synchronous).\n- Workaround: capture the values you need before the object is in a deiniting state, or make the cleanup operation synchronous and explicitly nonisolated.\n\nactor MyActor {\n    var resource: Resource\n    deinit {\n        // Cannot do: resource.close() — 'resource' is actor-isolated\n        // Workaround: resource must be nonisolated or use nonisolated(unsafe)\n    }\n}\n\nPatterns and pitfalls:\n\n1. Closing resources in deinit:\ndeinit {\n    fileHandle.closeFile() // OK for synchronous cleanup\n    // Cannot: await networkConnection.disconnect() — deinit is not async\n}\n\n2. NotificationCenter removal (pre-iOS 9):\nHistorically, failing to remove observers in deinit caused crashes. Since iOS 9/macOS 10.11, this is handled automatically, but explicit removal in deinit is still common practice.\n\n3. Timer invalidation:\ndeinit {\n    timer?.invalidate() // necessary — Timer retains its target\n}\n\n4. No guaranteed execution:\n- deinit may never run if there's a retain cycle.\n- deinit runs on whatever thread releases the last reference — not necessarily the main thread.\n- For UI cleanup, this means deinit might run on a background thread.\n\n5. Inheritance and stored properties:\n- Stored properties are released AFTER the most derived deinit but BEFORE the superclass deinit.\n- Between the derived deinit and the base deinit, the derived class's properties are already deinitialized.\n\n6. withExtendedLifetime interaction:\n- Inside deinit, self's lifetime is extended through the body, so withExtendedLifetime is not needed for self in deinit."
  },
  {
    "topic": "memory",
    "level": 5,
    "question": "Explain how Swift optimizes reference counting operations. What are immortal objects, the effect of escape analysis, and how does the compiler eliminate unnecessary retain/release pairs?",
    "hint": "Think about compiler optimizations like ARC optimization passes, guaranteed parameters, and objects that never need reference counting.",
    "answer": "Swift employs multiple layers of optimization to minimize the overhead of reference counting, from compile-time elimination of operations to runtime shortcuts.\n\n1. Compiler ARC Optimization Passes:\n- The Swift compiler (via SIL — Swift Intermediate Language) runs optimization passes that analyze retain/release patterns and eliminate redundant ones.\n- Retain/release pairs that provably have no observable effect are removed.\n- Example: If a function receives a reference, retains it, uses it, and releases it without any other observable side effect, the retain/release pair is eliminated.\n\nfunc process(_ obj: MyClass) {\n    // Compiler might skip retain at entry and release at exit\n    // if it can prove obj stays alive through the function\n    obj.doWork()\n}\n\n2. Guaranteed (borrowing) parameters:\n- In Swift's calling convention, parameters can be passed as 'guaranteed' — the caller guarantees the object stays alive for the duration of the call.\n- The callee doesn't need to retain/release the parameter.\n- This is the default for most parameters in optimized builds.\n- @owned parameters transfer ownership — the callee is responsible for releasing.\n- In Swift 5.9+, 'borrowing' and 'consuming' keywords make this explicit in the source.\n\n3. Escape analysis:\n- The compiler analyzes whether a reference escapes the current scope (stored in a heap-allocated closure, assigned to a global, etc.).\n- Non-escaping references don't need retain/release because their lifetime is bounded by the scope.\n- Non-escaping closures (@noescape, the default) don't retain captured references.\n- Stack promotion: If the compiler can prove an allocation doesn't escape, it may allocate on the stack instead of the heap, avoiding ARC entirely.\n\n4. Immortal objects:\n- Certain objects are marked as immortal in the runtime — their reference count operations are no-ops.\n- Examples: type metadata objects, protocol witness tables, empty collection singletons.\n- The immortal bit in the refcount word causes retain/release to return immediately.\n- Tagged pointer objects (NSNumber, short NSString) are also effectively immortal since they aren't real heap allocations.\n- Global string literals in Swift are immortal — they live for the program's entire lifetime.\n\n5. Inline reference counting:\n- For non-ObjC Swift objects, retain/release are simple atomic increment/decrement operations on the inline refcount word.\n- No Objective-C message send overhead.\n- The fast path (non-ObjC, no side table, no overflow) is extremely cheap — a single atomic add instruction.\n\n6. Copy-on-Write avoidance:\n- For value types containing references (like Array), the compiler tries to prove uniqueness statically.\n- If it can, it skips the isKnownUniquelyReferenced check and mutates in place.\n\n7. Move semantics (consume operator):\n- Swift 5.9's 'consume' keyword transfers ownership without retain/release:\nlet x = MyClass()\nlet y = consume x  // no retain; x is no longer usable\n- This eliminates a retain+release pair that would occur with simple assignment.\n\n8. Dead object elimination:\n- If an object is created but the compiler proves its side effects (init/deinit) are unobservable, the entire allocation can be eliminated.\n\n9. Whole Module Optimization (WMO):\n- With -whole-module-optimization, the compiler sees all callers and callees, enabling more aggressive ARC optimization across function boundaries.\n- Internal methods can be fully inlined, exposing more retain/release pairs for elimination.\n\nMeasurable impact:\n- In optimized builds (-O), ARC overhead is typically 2-5% of execution time for most apps.\n- In debug builds (-Onone), retain/release calls are not optimized away, leading to significantly more overhead.\n- For performance-critical code, ensure profiling is done in Release/optimized builds."
  },
  {
    "topic": "testing",
    "level": 0,
    "question": "What is XCTest and what is its role in iOS development?",
    "hint": "Think about Apple's built-in framework that comes with Xcode for verifying code behavior.",
    "answer": "XCTest is Apple's built-in testing framework for Swift and Objective-C projects. It provides the infrastructure for writing and running unit tests, performance tests, and UI tests.\n\nKey points:\n- Test classes inherit from XCTestCase.\n- Test methods must start with the word 'test' and take no parameters.\n- setUp() runs before each test method, tearDown() runs after each.\n- Xcode's Test Navigator shows all test classes and methods.\n- Tests run via Cmd+U or through the test diamond icons in the gutter.\n- XCTest integrates with Xcode's code coverage tools and CI systems.\n- It is included automatically when you create a new Xcode project with the 'Include Tests' checkbox enabled."
  },
  {
    "topic": "testing",
    "level": 0,
    "question": "What are the most commonly used XCTAssert functions and when do you use each?",
    "hint": "Think about the different ways you can verify equality, truthfulness, nil values, and error throwing.",
    "answer": "The XCTAssert family provides various assertion functions for different verification needs:\n\n- XCTAssertTrue(expression) / XCTAssertFalse(expression): Verify boolean conditions.\n- XCTAssertEqual(a, b) / XCTAssertNotEqual(a, b): Check value equality (requires Equatable conformance).\n- XCTAssertNil(expression) / XCTAssertNotNil(expression): Verify optionals are nil or non-nil.\n- XCTAssertThrowsError(expression): Verify that code throws an error.\n- XCTAssertNoThrow(expression): Verify that code does not throw.\n- XCTAssertGreaterThan / XCTAssertLessThan: Compare Comparable values.\n- XCTAssertEqual(a, b, accuracy:): Compare floating-point values within a tolerance.\n- XCTFail(message): Unconditionally fail the test, useful in unreachable branches.\n\nAll assertions accept an optional trailing message string to provide context when they fail."
  },
  {
    "topic": "testing",
    "level": 0,
    "question": "What does @testable import do and why is it needed?",
    "hint": "Consider Swift's default access control level and how test targets relate to the main module.",
    "answer": "@testable import ModuleName allows a test target to access internal-scoped symbols from the imported module as if they were public.\n\nWithout @testable, only public and open symbols are visible to external modules, including test targets. Since Swift's default access level is internal, most types, methods, and properties would be invisible to tests.\n\nKey points:\n- It only elevates 'internal' to be visible; it does not expose 'private' or 'fileprivate' symbols.\n- The module must be compiled with testing enabled (the default for Debug builds).\n- Release/production builds typically have testing disabled, so @testable import will fail against release builds.\n- Some developers argue that if you need @testable import, your public API surface may be insufficient, and you should consider testing through public interfaces instead."
  },
  {
    "topic": "testing",
    "level": 1,
    "question": "Explain the Arrange-Act-Assert (AAA) pattern and the Given-When-Then pattern for structuring tests. How do they relate?",
    "hint": "Both patterns divide a test into three logical phases. One comes from TDD, the other from BDD.",
    "answer": "Both patterns structure tests into three distinct phases for clarity and consistency:\n\nArrange-Act-Assert (AAA):\n- Arrange: Set up the system under test, create dependencies, configure initial state.\n- Act: Execute the behavior being tested (call a method, trigger an action).\n- Assert: Verify the outcome matches expectations.\n\nGiven-When-Then (from BDD):\n- Given: The preconditions and initial context.\n- When: The action or event that occurs.\n- Then: The expected outcome.\n\nThey map directly to each other: Given=Arrange, When=Act, Then=Assert.\n\nThe difference is primarily in origin and naming convention. AAA comes from the TDD community, while Given-When-Then comes from Behavior-Driven Development (BDD) and is often used in acceptance criteria.\n\nExample:\n// Given (Arrange)\nlet calculator = Calculator()\n// When (Act)\nlet result = calculator.add(2, 3)\n// Then (Assert)\nXCTAssertEqual(result, 5)"
  },
  {
    "topic": "testing",
    "level": 1,
    "question": "What are test doubles? Describe the difference between mocks, stubs, spies, fakes, and dummies.",
    "hint": "Each type of test double serves a different purpose in isolating the system under test from its dependencies.",
    "answer": "Test doubles are objects that stand in for real dependencies during testing. The five types are:\n\n1. Dummy: An object passed around but never actually used. It just fills a parameter requirement. Example: passing an empty struct to satisfy a function signature.\n\n2. Stub: Provides canned answers to method calls. It returns predefined values but does not verify interactions. Example: a UserService stub that always returns a hardcoded User object.\n\n3. Spy: Records information about how it was called (method names, arguments, call counts) so you can verify interactions after the fact. It may also return values like a stub.\n\n4. Mock: A pre-programmed object with expectations about which methods will be called, with what arguments, and how many times. Verification typically happens automatically. Mocks verify behavior.\n\n5. Fake: A working implementation that takes shortcuts unsuitable for production. Example: an in-memory database instead of a real one, or a fake network client that reads from local JSON files.\n\nThe key distinction: stubs provide input to the system under test, while mocks/spies verify output (interactions) from the system under test."
  },
  {
    "topic": "testing",
    "level": 1,
    "question": "What is the test pyramid and why does it matter?",
    "hint": "Think about the different layers of testing and the trade-offs between speed, coverage, and confidence at each layer.",
    "answer": "The test pyramid is a model that describes the ideal distribution of tests across different levels:\n\nBottom (most tests) — Unit Tests:\n- Test individual functions, methods, or classes in isolation.\n- Fast to run (milliseconds each), cheap to write and maintain.\n- High specificity for pinpointing failures.\n\nMiddle — Integration Tests:\n- Test how multiple components work together.\n- Slower than unit tests but verify real interactions.\n- Examples: testing a ViewModel with a real (but local) database, testing networking with a mock server.\n\nTop (fewest tests) — UI/End-to-End Tests:\n- Test the full application from the user's perspective.\n- Slowest to run, most brittle, hardest to maintain.\n- Provide highest confidence that the whole system works.\n\nWhy it matters:\n- Following the pyramid gives fast feedback loops (most tests are fast unit tests).\n- Inverting the pyramid (too many UI tests, few unit tests) leads to slow, flaky test suites.\n- Each layer catches different categories of bugs.\n- The goal is confidence in correctness with minimal execution time.\n- Some teams also add a 'contract testing' layer between integration and E2E."
  },
  {
    "topic": "testing",
    "level": 1,
    "question": "What are common test naming conventions in Swift and why do they matter?",
    "hint": "Think about what information a test name should convey when it appears in a failure report.",
    "answer": "Good test names communicate three things: what is being tested, under what conditions, and what the expected outcome is.\n\nCommon conventions:\n\n1. test_methodName_condition_expectedResult:\n   test_login_withValidCredentials_returnsUser()\n   test_login_withInvalidPassword_throwsAuthError()\n\n2. test_givenCondition_whenAction_thenOutcome (BDD style):\n   test_givenEmptyCart_whenAddingItem_thenCartCountIsOne()\n\n3. testMethodName_condition (shorter form):\n   testFetchUser_networkError()\n\nWhy naming matters:\n- When a test fails in CI, the test name is often the first clue about what broke.\n- Good names serve as documentation of expected behavior.\n- Consistent naming makes it easy to find related tests.\n- Xcode's Test Navigator groups tests by class, so names help navigation.\n\nIn the newer Swift Testing framework, @Test attributes accept a display name string argument, letting you use human-readable descriptions:\n@Test(\"Login succeeds with valid credentials\")\nfunc loginWithValidCredentials() { ... }"
  },
  {
    "topic": "testing",
    "level": 2,
    "question": "How do you test asynchronous code using XCTestExpectation? What pitfalls should you watch out for?",
    "hint": "Think about how you create an expectation, fulfill it when the async work completes, and wait with a timeout.",
    "answer": "XCTestExpectation enables testing asynchronous code by making the test wait for an event to occur:\n\nBasic pattern:\nfunc testAsyncFetch() {\n    let expectation = expectation(description: \"Data fetched\")\n    \n    service.fetchData { result in\n        XCTAssertNotNil(result)\n        expectation.fulfill()\n    }\n    \n    waitForExpectations(timeout: 5.0)\n}\n\nKey APIs:\n- expectation(description:) creates a new expectation.\n- fulfill() signals that the expected event occurred.\n- waitForExpectations(timeout:) blocks the test until all expectations are fulfilled or the timeout expires.\n- wait(for: [expectations], timeout:) waits for specific expectations.\n- isInverted = true verifies that something does NOT happen.\n- expectedFulfillmentCount sets how many times fulfill() must be called.\n\nPitfalls:\n- Forgetting to call fulfill() causes the test to always time out.\n- Calling fulfill() more than expectedFulfillmentCount causes a crash or failure.\n- Setting the timeout too low causes flaky tests; too high slows the suite.\n- Assertions inside callbacks may not report failures correctly if the test has already finished.\n- With Swift concurrency, prefer async/await test methods instead: func testAsyncFetch() async throws { let result = try await service.fetchData(); XCTAssertNotNil(result) }."
  },
  {
    "topic": "testing",
    "level": 2,
    "question": "How does dependency injection improve testability? Show an example of refactoring tightly coupled code to be testable.",
    "hint": "Think about replacing concrete dependencies with protocols so you can substitute test doubles.",
    "answer": "Dependency injection (DI) makes code testable by allowing test doubles to replace real dependencies.\n\nTightly coupled (hard to test):\nclass OrderService {\n    func placeOrder(_ order: Order) {\n        let network = URLSessionNetworkClient()\n        network.post(order)\n        let analytics = FirebaseAnalytics()\n        analytics.track(\"order_placed\")\n    }\n}\n\nRefactored with DI:\nprotocol NetworkClient {\n    func post(_ data: Encodable)\n}\nprotocol AnalyticsTracker {\n    func track(_ event: String)\n}\n\nclass OrderService {\n    private let network: NetworkClient\n    private let analytics: AnalyticsTracker\n    \n    init(network: NetworkClient, analytics: AnalyticsTracker) {\n        self.network = network\n        self.analytics = analytics\n    }\n    \n    func placeOrder(_ order: Order) {\n        network.post(order)\n        analytics.track(\"order_placed\")\n    }\n}\n\nIn tests:\nclass SpyAnalytics: AnalyticsTracker {\n    var trackedEvents: [String] = []\n    func track(_ event: String) { trackedEvents.append(event) }\n}\n\nfunc testPlaceOrder_tracksAnalyticsEvent() {\n    let spy = SpyAnalytics()\n    let sut = OrderService(network: StubNetwork(), analytics: spy)\n    sut.placeOrder(Order())\n    XCTAssertEqual(spy.trackedEvents, [\"order_placed\"])\n}\n\nDI can be done via constructor injection (shown above), property injection, or method injection. Constructor injection is preferred because it makes dependencies explicit and required."
  },
  {
    "topic": "testing",
    "level": 2,
    "question": "What is code coverage and what are its limitations? Should you aim for 100% coverage?",
    "hint": "Think about what code coverage actually measures versus what it does not tell you about test quality.",
    "answer": "Code coverage measures which lines, branches, or functions of your code are executed during test runs. Xcode provides built-in coverage reporting via the Test Results and the Coverage tab.\n\nWhat coverage tells you:\n- Which code paths are exercised by tests.\n- Which areas have zero test coverage and may be risky.\n- Trends over time (is coverage increasing or decreasing?).\n\nLimitations:\n- Coverage measures execution, NOT correctness. A line can be covered without any meaningful assertion.\n- 100% line coverage does not mean 100% branch coverage or 100% state coverage.\n- It does not measure the quality of assertions. A test that calls a method but asserts nothing still counts as coverage.\n- It can create perverse incentives: writing trivial tests just to hit a coverage number.\n- Some code is impractical or impossible to test (e.g., fatalError paths, OS-specific branches).\n- Coverage varies across build configurations and device simulators.\n\nShould you aim for 100%?\n- No. Diminishing returns set in around 80-90%. The last 10-20% often requires disproportionate effort for minimal benefit.\n- Focus on covering critical business logic, edge cases, and error handling.\n- Use coverage as a guide, not a goal. High coverage with poor assertions is worse than moderate coverage with strong assertions.\n- Coverage is a lagging indicator; test quality is what matters."
  },
  {
    "topic": "testing",
    "level": 2,
    "question": "How do you test Combine publishers? Walk through the approach for testing a publisher that emits multiple values over time.",
    "hint": "Consider collecting emitted values into an array and using expectations or the new Swift concurrency features.",
    "answer": "Testing Combine publishers requires capturing emitted values and verifying them. There are several approaches:\n\nApproach 1 — Collecting values with expectations:\nfunc testPublisherEmitsValues() {\n    let expectation = expectation(description: \"Values received\")\n    var receivedValues: [Int] = []\n    let publisher = [1, 2, 3].publisher\n    \n    let cancellable = publisher.sink(\n        receiveCompletion: { _ in expectation.fulfill() },\n        receiveValue: { receivedValues.append($0) }\n    )\n    \n    waitForExpectations(timeout: 1.0)\n    XCTAssertEqual(receivedValues, [1, 2, 3])\n    cancellable.cancel()\n}\n\nApproach 2 — Using a helper that collects values:\nextension XCTestCase {\n    func awaitPublisher<T: Publisher>(\n        _ publisher: T,\n        timeout: TimeInterval = 1.0\n    ) throws -> [T.Output] where T.Failure == Never {\n        var values: [T.Output] = []\n        let exp = expectation(description: \"Await publisher\")\n        let cancellable = publisher.sink(\n            receiveCompletion: { _ in exp.fulfill() },\n            receiveValue: { values.append($0) }\n        )\n        waitForExpectations(timeout: timeout)\n        cancellable.cancel()\n        return values\n    }\n}\n\nApproach 3 — Testing with XCTestExpectation and specific value counts:\nSet expectedFulfillmentCount on the expectation to match the number of expected emissions.\n\nKey tips:\n- Always store the AnyCancellable to prevent premature deallocation.\n- For time-based publishers (debounce, throttle), use a TestScheduler or virtual time from libraries like CombineSchedulers.\n- Test both the happy path values and the completion event.\n- Test error cases by verifying receiveCompletion with a .failure case.\n- For subjects, call send() in the test to simulate input."
  },
  {
    "topic": "testing",
    "level": 3,
    "question": "Explain the TDD red-green-refactor cycle. What are the practical benefits and common objections?",
    "hint": "Think about the three steps: write a failing test first, make it pass with minimal code, then improve the code while keeping tests green.",
    "answer": "TDD (Test-Driven Development) follows a strict three-step cycle:\n\n1. RED: Write a test for behavior that does not yet exist. Run it and confirm it fails. This validates that the test is actually testing something and is not a false positive.\n\n2. GREEN: Write the minimum production code needed to make the test pass. Do not over-engineer or add functionality beyond what the test requires. Even hardcoding a return value is acceptable at this stage.\n\n3. REFACTOR: Clean up both the production code and test code. Remove duplication, improve naming, extract methods. All tests must stay green throughout refactoring.\n\nThen repeat for the next piece of behavior.\n\nBenefits:\n- Forces you to think about the API design before implementation.\n- Produces code that is inherently testable (since it was designed test-first).\n- Provides a safety net for refactoring.\n- Results in higher test coverage naturally.\n- Small incremental steps reduce debugging time.\n- Tests serve as living documentation of behavior.\n\nCommon objections:\n- Slower initial velocity: writing tests first feels slower, but reduces debugging time later.\n- Hard for UI code: TDD works best for business logic; UI is harder to test-drive.\n- Over-testing: can lead to brittle tests if testing implementation details rather than behavior.\n- Learning curve: developers new to TDD often write tests that are too granular.\n- Not always practical for exploratory or prototype code.\n\nBest practice: Use TDD for business logic and algorithms. Use test-after for UI and integration layers."
  },
  {
    "topic": "testing",
    "level": 3,
    "question": "What is the Swift Testing framework introduced in Xcode 16? How does it differ from XCTest?",
    "hint": "Think about the new @Test attribute, #expect macro, parameterized tests, and how test discovery works differently.",
    "answer": "Swift Testing is a modern testing framework introduced alongside Swift 6 and Xcode 16. It uses Swift macros and language features for a more expressive testing experience.\n\nKey differences from XCTest:\n\n1. Test declaration: Uses @Test attribute instead of method name prefix 'test'. Functions can have any name.\n   @Test func userCanLogin() { ... }\n   @Test(\"Descriptive display name\") func someTest() { ... }\n\n2. Assertions: Uses #expect and #require macros instead of XCTAssert family.\n   #expect(value == 42) — soft assertion, test continues on failure.\n   try #require(value != nil) — hard assertion, throws and stops the test on failure.\n   The macros capture the full expression and show detailed failure messages automatically.\n\n3. Suites: @Suite groups related tests, replacing XCTestCase subclassing. Suites can be structs, not just classes.\n   @Suite struct LoginTests { ... }\n\n4. Parameterized tests: Built-in support for running the same test with multiple inputs.\n   @Test(arguments: [1, 2, 3]) func testSquare(value: Int) { ... }\n\n5. Tags: Tests can be tagged for filtering and organization.\n   @Test(.tags(.critical)) func importantTest() { ... }\n\n6. Parallel execution: Tests run in parallel by default for faster execution.\n\n7. No setUp/tearDown: Use init/deinit on the suite struct/class, or use .setUp trait.\n\n8. Interoperability: Swift Testing and XCTest can coexist in the same target.\n\nSwift Testing is more Swifty, leveraging macros and value types, while XCTest follows the Objective-C heritage of class-based patterns."
  },
  {
    "topic": "testing",
    "level": 3,
    "question": "How do you test error cases effectively? What strategies ensure your error handling is robust?",
    "hint": "Think about XCTAssertThrowsError, matching specific error types, testing error messages, and verifying side effects when errors occur.",
    "answer": "Testing error cases is critical because error paths are where bugs often hide. Strategies:\n\n1. XCTAssertThrowsError with error type verification:\nfunc testInvalidInput_throwsValidationError() {\n    XCTAssertThrowsError(try parser.parse(\"\")) { error in\n        XCTAssertTrue(error is ValidationError)\n        XCTAssertEqual(error as? ValidationError, .emptyInput)\n    }\n}\n\n2. Testing async throwing functions:\nfunc testNetworkFailure() async {\n    let sut = Service(network: FailingNetworkStub())\n    do {\n        _ = try await sut.fetchData()\n        XCTFail(\"Expected error to be thrown\")\n    } catch {\n        XCTAssertEqual(error as? ServiceError, .networkUnavailable)\n    }\n}\n\n3. Verify state remains consistent after errors:\nfunc testFailedSave_doesNotModifyState() {\n    let originalState = viewModel.state\n    viewModel.save() // triggers an error internally\n    XCTAssertEqual(viewModel.state, originalState)\n}\n\n4. Test error messages for user-facing errors:\nXCTAssertEqual(error.localizedDescription, \"Please enter a valid email address.\")\n\n5. Test Result types:\nlet result = service.validate(input)\nswitch result {\ncase .success: XCTFail(\"Expected failure\")\ncase .failure(let error): XCTAssertEqual(error, .tooShort)\n}\n\n6. With Swift Testing:\n#expect(throws: ValidationError.emptyInput) {\n    try parser.parse(\"\")\n}\n\nBest practices:\n- Test each error path individually with a dedicated test.\n- Verify both the error type and any associated values.\n- Ensure no side effects occur on failure (state unchanged, no network calls made).\n- Test boundary conditions that trigger errors (empty strings, nil values, negative numbers).\n- Test that error recovery works correctly."
  },
  {
    "topic": "testing",
    "level": 4,
    "question": "How do you implement parameterized tests in both XCTest and Swift Testing? What are the trade-offs?",
    "hint": "In XCTest you typically use loops or invocations; in Swift Testing there is built-in @Test(arguments:) support.",
    "answer": "Parameterized tests run the same test logic with different input/output combinations, reducing code duplication.\n\nXCTest approach — loop-based:\nfunc testEmailValidation() {\n    let cases: [(input: String, isValid: Bool)] = [\n        (\"user@example.com\", true),\n        (\"invalid\", false),\n        (\"\", false),\n        (\"a@b.c\", true)\n    ]\n    for testCase in cases {\n        let result = validator.isValidEmail(testCase.input)\n        XCTAssertEqual(result, testCase.isValid, \"Failed for: \\(testCase.input)\")\n    }\n}\n\nProblem: If the second case fails, remaining cases still run, but the failure message doesn't clearly identify which iteration failed without the custom message. Also, Xcode shows one test, not four.\n\nXCTest approach — defaultTestSuite override (advanced):\nOverride class var defaultTestSuite to create dynamic test invocations. This gives separate test entries but is complex and fragile.\n\nSwift Testing approach — built-in:\n@Test(arguments: [\n    (\"user@example.com\", true),\n    (\"invalid\", false),\n    (\"\", false),\n    (\"a@b.c\", true)\n])\nfunc emailValidation(input: String, isValid: Bool) {\n    #expect(validator.isValidEmail(input) == isValid)\n}\n\nThis creates four distinct test cases in the test navigator, each with a clear label. Each runs independently and reports separately.\n\nYou can also use multiple argument collections with zip or cartesian product:\n@Test(arguments: [\"light\", \"dark\"], [\"iPhone\", \"iPad\"])\nfunc themeRendering(theme: String, device: String) { ... }\n\nTrade-offs:\n- XCTest loops are simple but lose individual test identity and reporting.\n- Swift Testing parameterized tests are elegant but require Xcode 16+.\n- For complex setups, parameterized tests can become hard to read if there are many parameters.\n- Each parameterized case runs in parallel by default in Swift Testing, which may cause issues with shared state."
  },
  {
    "topic": "testing",
    "level": 4,
    "question": "How do #expect and #require macros work in Swift Testing? How do they compare to XCTAssert?",
    "hint": "Think about how Swift macros capture expressions at compile time, and the difference between soft and hard assertions.",
    "answer": "#expect and #require are macros in the Swift Testing framework that replace the XCTAssert family.\n\n#expect — Soft assertion:\n- Records a failure but allows the test to continue.\n- Equivalent to XCTAssertTrue but much more powerful.\n- The macro captures the full expression at compile time and displays detailed failure information.\n\n#expect(user.name == \"Alice\")\n// Failure: user.name == \"Alice\" → \"Bob\" == \"Alice\"\n\nCompare with XCTAssertEqual(user.name, \"Alice\"):\n// Failure: XCTAssertEqual failed: (\"Bob\") is not equal to (\"Alice\")\n\n#require — Hard assertion:\n- Throws an error on failure, stopping the current test.\n- Useful for preconditions where continuing makes no sense.\n- Also unwraps optionals.\n\nlet user = try #require(fetchUser(id: \"123\"))\n// If nil, the test stops here with a clear message.\n// Otherwise, 'user' is now non-optional.\n\nAdvantages over XCTAssert:\n1. Single macro handles all comparison types — no need for XCTAssertEqual, XCTAssertNil, XCTAssertGreaterThan, etc.\n2. Expression capture provides richer failure messages automatically.\n3. #require combines nil-checking and unwrapping in one step.\n4. #expect(throws: ErrorType.self) replaces XCTAssertThrowsError with cleaner syntax.\n5. Compiler integration means typos in expressions are caught at compile time.\n\nLimitations:\n- Only available in Swift Testing (Xcode 16+), not in XCTest.\n- Migration from XCTest requires adopting the new framework.\n- Custom failure messages are still supported: #expect(value > 0, \"Value must be positive\")."
  },
  {
    "topic": "testing",
    "level": 4,
    "question": "Explain test tags, @Suite, and parallel test execution in Swift Testing. How do you use them to organize a large test suite?",
    "hint": "Think about how tags enable cross-cutting categorization, suites group related tests, and parallelism affects test design.",
    "answer": "Swift Testing provides several organizational features for managing large test suites:\n\n@Suite:\n- Groups related tests into a named container.\n- Can be a struct, class, enum, or actor.\n- Suites can be nested for hierarchical organization.\n- Can have custom display names: @Suite(\"Authentication Tests\")\n- Properties in a suite struct can serve as shared setup.\n\n@Suite(\"User Authentication\")\nstruct AuthTests {\n    let service = AuthService(network: MockNetwork())\n    \n    @Test func loginSucceeds() { ... }\n    @Test func loginFails() { ... }\n    \n    @Suite(\"Password Reset\")\n    struct PasswordResetTests {\n        @Test func resetSendsEmail() { ... }\n    }\n}\n\nTags:\n- Enable cross-cutting categorization independent of suite hierarchy.\n- Define custom tags as static properties:\nextension Tag {\n    @Tag static var critical: Self\n    @Tag static var slow: Self\n    @Tag static var network: Self\n}\n- Apply to tests: @Test(.tags(.critical, .network)) func importantNetworkTest() { ... }\n- Filter tests by tag in test plans or command line.\n- A test can have multiple tags.\n- Tags can be applied to entire suites: @Suite(.tags(.slow)) struct SlowTests { ... }\n\nParallel execution:\n- Tests run in parallel by default in Swift Testing.\n- Each test gets its own instance of the suite (since suites are usually structs).\n- Use .serialized trait when tests must run sequentially: @Suite(.serialized) struct DatabaseTests { ... }\n- Parallel execution exposes hidden dependencies between tests (shared state bugs).\n- Design tests to be independent: no shared mutable state, unique test data.\n\nOrganization strategy:\n- Use suites for logical grouping (by feature).\n- Use tags for cross-cutting concerns (by priority, speed, or infrastructure dependency).\n- Use serialized suites only when truly necessary (database, file system).\n- Keep suites focused — a suite should represent a single unit or feature."
  },
  {
    "topic": "testing",
    "level": 5,
    "question": "How would you design a testing strategy for a large-scale iOS app with multiple modules? Consider unit tests, integration tests, and the boundaries between modules.",
    "hint": "Think about module boundaries, test targets per module, contract testing, shared test utilities, and CI pipeline optimization.",
    "answer": "A comprehensive testing strategy for a modular iOS app requires careful consideration at multiple levels:\n\n1. Test target architecture:\n- Each module gets its own test target containing unit tests for that module's internal logic.\n- Create an integration test target that tests interactions between modules.\n- Create a UI test target for end-to-end flows.\n- Shared test utilities (builders, helpers, fixtures) go in a dedicated TestSupport module.\n\n2. Module boundary testing:\n- Define protocols at module boundaries (ports/adapters pattern).\n- Test each module in isolation by mocking its dependencies via these protocols.\n- Contract tests verify that implementations satisfy their protocol contracts.\n- Example: a NetworkModule exposes a NetworkClient protocol. Both the real implementation and the mock used by consumer modules are tested against the same contract.\n\n3. Dependency management for tests:\n- Use a DI container or factory pattern to wire dependencies.\n- Test configurations swap real implementations for fakes/mocks.\n- Provide pre-built mock modules that other test targets can import.\n\n4. Test data strategy:\n- Use builder patterns for creating test fixtures: User.builder().withName(\"Alice\").build()\n- Avoid hardcoded IDs or values that couple tests to specific data.\n- Shared fixture factories live in the TestSupport module.\n\n5. CI pipeline optimization:\n- Run unit tests for changed modules first (affected-module detection).\n- Parallelize test targets across multiple CI machines.\n- Integration and UI tests run on a separate, less frequent schedule.\n- Cache derived data and simulators.\n- Use test plans to create different test configurations (smoke, full, nightly).\n\n6. Coverage strategy:\n- Set coverage thresholds per module (80%+ for business logic, lower for UI).\n- Track coverage trends, not absolute numbers.\n- Critical paths (payments, authentication) must have near-100% coverage.\n\n7. Flakiness management:\n- Quarantine flaky tests immediately.\n- Track flakiness rates per test.\n- Retry failed tests once in CI before marking as failure.\n- Root-cause all flaky tests within a sprint.\n\n8. Living documentation:\n- Tests serve as executable specifications.\n- Use descriptive test names and Swift Testing display names.\n- Tag critical-path tests for easy identification."
  },
  {
    "topic": "testing",
    "level": 5,
    "question": "How do you test code that depends on system APIs like Date, Locale, TimeZone, or UserDefaults? What patterns make this testable without modifying production behavior?",
    "hint": "Think about abstracting system dependencies behind protocols or using injectable closures and current-value patterns.",
    "answer": "System dependencies are global state that makes tests non-deterministic. Several patterns address this:\n\n1. Protocol abstraction:\nprotocol DateProvider {\n    var now: Date { get }\n}\n\nstruct SystemDateProvider: DateProvider {\n    var now: Date { Date() }\n}\n\nstruct FixedDateProvider: DateProvider {\n    let now: Date\n}\n\nInject DateProvider into types that need the current date. Tests use FixedDateProvider.\n\n2. Closure injection (lighter weight):\nclass SessionManager {\n    var currentDate: () -> Date = { Date() }\n    \n    func isSessionExpired() -> Bool {\n        currentDate() > session.expiresAt\n    }\n}\n// Test:\nmanager.currentDate = { Date(timeIntervalSince1970: 1000000) }\n\n3. Environment-style pattern (SwiftUI inspired):\nstruct Environment {\n    var date: () -> Date = { Date() }\n    var locale: Locale = .current\n    var timeZone: TimeZone = .current\n    var userDefaults: UserDefaults = .standard\n}\n\nPass the environment through the dependency graph. Tests provide a controlled environment.\n\n4. UserDefaults isolation:\n- Create a named suite for each test: UserDefaults(suiteName: \"TestSuite\")\n- Remove the suite in tearDown: UserDefaults.standard.removePersistentDomain(forName: \"TestSuite\")\n- Or use a protocol: protocol KeyValueStore { func value(forKey: String) -> Any? }\n\n5. Swift clock abstraction (Swift 5.7+):\nUse Clock protocol with ContinuousClock in production and a test clock in tests.\nfunc waitForTimeout<C: Clock>(clock: C, duration: C.Duration) async throws { ... }\n\n6. FileManager isolation:\n- Use a temporary directory per test.\n- Inject a protocol wrapper around FileManager.\n\n7. The withDependencies pattern (from PointFree):\nwithDependencies {\n    $0.date.now = Date(timeIntervalSince1970: 0)\n    $0.uuid = .incrementing\n} operation: {\n    let model = FeatureModel()\n    // model sees controlled dependencies\n}\n\nBest practices:\n- Never call Date(), Locale.current, etc. directly in business logic.\n- Make the abstraction minimal — a closure is often sufficient.\n- Document which system dependencies a module uses.\n- Consider using swift-dependencies library for a standardized approach."
  },
  {
    "topic": "testing",
    "level": 5,
    "question": "Discuss advanced testing patterns for Swift concurrency: testing actors, @MainActor-isolated code, task groups, and async sequences. What are the challenges?",
    "hint": "Think about actor isolation, MainActor requirements in tests, non-determinism in concurrent code, and testing AsyncSequence consumers.",
    "answer": "Testing Swift concurrency introduces unique challenges due to isolation, non-determinism, and runtime requirements:\n\n1. Testing actors:\n- Actor methods are async from outside, so test methods must be async.\n- Internal state cannot be accessed directly — you must go through the actor's interface.\n- Test that concurrent access is properly serialized:\n\nactor Counter {\n    private var count = 0\n    func increment() { count += 1 }\n    func getCount() -> Int { count }\n}\n\n@Test func concurrentIncrements() async {\n    let counter = Counter()\n    await withTaskGroup(of: Void.self) { group in\n        for _ in 0..<1000 {\n            group.addTask { await counter.increment() }\n        }\n    }\n    let finalCount = await counter.getCount()\n    #expect(finalCount == 1000)\n}\n\n2. Testing @MainActor-isolated code:\n- Test functions must also be @MainActor or use MainActor.run { }.\n- In XCTest, marking the test method @MainActor works:\n@MainActor func testViewModel() async { ... }\n- In Swift Testing, tests are not on the main actor by default. Use @MainActor on the suite or test.\n- Caveat: Running tests on MainActor can cause deadlocks if the code under test dispatches to MainActor synchronously.\n\n3. Testing task groups and structured concurrency:\n- Verify that all child tasks complete and their results are aggregated correctly.\n- Test cancellation: create a task, cancel it, verify cleanup occurs.\nlet task = Task { await sut.longRunningOperation() }\ntask.cancel()\nlet result = await task.value\n#expect(result == .cancelled)\n\n4. Testing AsyncSequence:\n- Collect values from an async sequence within a timeout.\n- Use Task with cancellation to prevent hanging:\n\nfunc collectValues<S: AsyncSequence>(_ sequence: S, count: Int) async throws -> [S.Element] {\n    var values: [S.Element] = []\n    for try await value in sequence {\n        values.append(value)\n        if values.count == count { break }\n    }\n    return values\n}\n\n5. Non-determinism challenges:\n- Task scheduling is not deterministic — tasks may execute in any order.\n- Avoid asserting on execution order unless the code guarantees it.\n- Use synchronization primitives (AsyncStream, continuations) to create deterministic test scenarios.\n- Inject a controllable clock for time-based operations.\n\n6. Testing sendable conformance:\n- Verify that types crossing isolation boundaries are Sendable.\n- The compiler enforces this with strict concurrency checking enabled.\n- Enable -strict-concurrency=complete in test targets to catch violations.\n\n7. Common pitfalls:\n- Tests that hang forever because an async sequence never terminates — always use timeouts or cancellation.\n- Race conditions in test setup/teardown with concurrent tests.\n- Forgetting that XCTestExpectation-based patterns don't compose well with async/await.\n- Over-mocking concurrency primitives, making tests not representative of real behavior.\n\nBest practice: Prefer testing the observable outcomes of concurrent code rather than the concurrency mechanism itself. Test that the final state is correct, not the order of internal task execution."
  },
  {
    "topic": "ui-testing",
    "level": 0,
    "question": "What is XCUITest and how does it differ from unit testing with XCTest?",
    "hint": "Think about what XCUITest interacts with — the running app's UI — versus unit tests that test code in isolation.",
    "answer": "XCUITest is Apple's framework for UI testing that tests the application from the user's perspective by interacting with the actual user interface.\n\nKey differences from unit tests:\n- XCUITest launches the full application as a separate process and interacts with it through the accessibility layer.\n- Unit tests run in-process and test individual functions/classes directly.\n- UI tests are slower because they launch the app, render UI, and simulate user interactions.\n- UI tests use XCUIApplication, XCUIElement, and XCUIElementQuery to find and interact with UI elements.\n- Unit tests import the module directly; UI tests cannot access internal code at all.\n- UI tests verify what the user sees and can interact with; unit tests verify code behavior.\n\nBasic structure:\nclass LoginUITests: XCTestCase {\n    let app = XCUIApplication()\n    \n    override func setUpWithError() throws {\n        continueAfterFailure = false\n        app.launch()\n    }\n    \n    func testLoginButton_isDisplayed() {\n        XCTAssertTrue(app.buttons[\"Login\"].exists)\n    }\n}\n\nUI tests are at the top of the test pyramid — fewer but higher confidence that the full system works."
  },
  {
    "topic": "ui-testing",
    "level": 0,
    "question": "What are accessibility identifiers and why are they important for UI testing?",
    "hint": "Think about how XCUITest finds elements on screen and why accessibility labels alone might not be reliable for tests.",
    "answer": "Accessibility identifiers are string properties on UI elements that uniquely identify them for testing and accessibility purposes.\n\nWhy they matter for UI testing:\n- XCUITest finds elements by querying the accessibility hierarchy.\n- Without identifiers, you must rely on element types, labels, or indices, which are fragile.\n- Accessibility identifiers are not visible to users (unlike accessibility labels) so they can be stable test hooks.\n\nSetting identifiers:\n// UIKit\nbutton.accessibilityIdentifier = \"loginButton\"\n// SwiftUI\nButton(\"Login\") { ... }.accessibilityIdentifier(\"loginButton\")\n\nUsing in tests:\nlet loginButton = app.buttons[\"loginButton\"]\nXCTAssertTrue(loginButton.exists)\nloginButton.tap()\n\nBest practices:\n- Use descriptive, consistent naming conventions (e.g., \"screen.element\" like \"login.emailField\").\n- Add identifiers to all interactive and important UI elements.\n- Do not rely on text labels for finding elements — they change with localization.\n- Avoid using index-based queries (cells.element(boundBy: 0)) as they are order-dependent.\n- Accessibility identifiers also help with accessibility auditing and VoiceOver support.\n- Consider defining identifier constants in a shared enum to avoid string mismatches."
  },
  {
    "topic": "ui-testing",
    "level": 0,
    "question": "How do you record a UI test in Xcode and what are the limitations of recorded tests?",
    "hint": "Think about the red record button in the test editor and why the generated code often needs manual cleanup.",
    "answer": "Xcode provides a UI test recording feature that generates test code by capturing your interactions with the app:\n\nHow to record:\n1. Create or open a UI test method.\n2. Place the cursor inside the test method body.\n3. Click the red Record button at the bottom of the editor.\n4. The app launches and Xcode records your taps, swipes, and text input as code.\n5. Stop recording by clicking the Record button again.\n\nThe generated code looks like:\napp.textFields[\"Email\"].tap()\napp.textFields[\"Email\"].typeText(\"user@test.com\")\napp.buttons[\"Login\"].tap()\n\nLimitations:\n- Generated code is often verbose and fragile, using hardcoded strings and indices.\n- It records UI interactions but does not add assertions — you must add XCTAssert calls manually.\n- Element queries may use localized text which breaks with different locales.\n- Index-based queries (element(boundBy: 2)) are generated when identifiers are missing.\n- The recording may capture unintended interactions (dismissing keyboards, scrolling).\n- Complex gestures may not be recorded accurately.\n- The code structure does not follow any pattern (no page objects, no helpers).\n\nBest practice: Use recording as a starting point to understand the element hierarchy, then rewrite the test manually with proper identifiers, assertions, and patterns."
  },
  {
    "topic": "ui-testing",
    "level": 1,
    "question": "How do you launch an app with specific arguments or environment variables in UI tests? When is this useful?",
    "hint": "Think about configuring the app for testing before it launches — things like skipping onboarding or using mock data.",
    "answer": "XCUIApplication provides launchArguments and launchEnvironment properties that pass data to the app process before launch:\n\nlet app = XCUIApplication()\napp.launchArguments = [\"-UITestMode\", \"-skipOnboarding\"]\napp.launchEnvironment = [\"API_BASE_URL\": \"http://localhost:8080\", \"USE_MOCK_DATA\": \"true\"]\napp.launch()\n\nIn the app code, read these values:\n// Arguments\nif CommandLine.arguments.contains(\"-skipOnboarding\") {\n    // Skip onboarding flow\n}\n// Environment\nif ProcessInfo.processInfo.environment[\"USE_MOCK_DATA\"] == \"true\" {\n    // Use mock network layer\n}\n\nCommon use cases:\n- Skipping login/onboarding screens to test specific features directly.\n- Pointing the app at a local mock server instead of production APIs.\n- Enabling/disabling feature flags for specific test scenarios.\n- Setting the app into a known state (pre-populated data, specific locale).\n- Resetting user defaults or keychain state.\n- Controlling animations (disabling them for faster, more reliable tests).\n\nBest practices:\n- Use launchArguments for boolean flags (presence/absence).\n- Use launchEnvironment for key-value configuration.\n- Keep the set of test-only flags minimal and well-documented.\n- Consider using a UITestingAppDelegate that wires up mock dependencies.\n- Reset app state in setUp to ensure each test starts clean.\n- Arguments are passed as an array of strings; each element is a separate argument."
  },
  {
    "topic": "ui-testing",
    "level": 1,
    "question": "How do you handle asynchronous UI in tests using waitForExistence and other waiting strategies?",
    "hint": "Think about what happens when a UI element appears after a network call or animation completes.",
    "answer": "UI tests often need to wait for elements that appear asynchronously. XCUITest provides several waiting mechanisms:\n\n1. waitForExistence(timeout:):\nlet welcomeLabel = app.staticTexts[\"Welcome\"]\nXCTAssertTrue(welcomeLabel.waitForExistence(timeout: 5))\n\nThis polls for the element's existence up to the timeout. Returns true if found, false if timeout expires.\n\n2. XCTNSPredicateExpectation (more flexible):\nlet element = app.buttons[\"Submit\"]\nlet predicate = NSPredicate(format: \"isEnabled == true\")\nlet expectation = XCTNSPredicateExpectation(predicate: predicate, object: element)\nwait(for: [expectation], timeout: 10)\n\nThis waits for any predicate condition, not just existence.\n\n3. Custom polling:\nfunc waitForElement(_ element: XCUIElement, timeout: TimeInterval = 5) -> Bool {\n    let deadline = Date().addingTimeInterval(timeout)\n    while Date() < deadline {\n        if element.exists { return true }\n        RunLoop.current.run(until: Date().addingTimeInterval(0.1))\n    }\n    return false\n}\n\nCommon waiting scenarios:\n- Waiting for a loading spinner to disappear.\n- Waiting for a list to populate after an API call.\n- Waiting for a navigation transition to complete.\n- Waiting for an alert to appear.\n\nBest practices:\n- Always use waits instead of sleep() — sleep is unreliable and wastes time.\n- Set reasonable timeouts — too short causes flakiness, too long slows the suite.\n- Wait for specific elements, not arbitrary time periods.\n- After a wait, assert on the element's properties (exists, isEnabled, label).\n- Use XCTAssertTrue(element.waitForExistence(timeout:)) to combine waiting and assertion."
  },
  {
    "topic": "ui-testing",
    "level": 1,
    "question": "How do you handle system alerts and permission dialogs in UI tests?",
    "hint": "Think about addUIInterruptionMonitor and the fact that system alerts are outside your app's process.",
    "answer": "System alerts (location, camera, notification permissions) are presented by SpringBoard, not your app, requiring special handling in UI tests:\n\n1. addUIInterruptionMonitor:\naddUIInterruptionMonitor(withDescription: \"Permission Alert\") { alert in\n    if alert.buttons[\"Allow\"].exists {\n        alert.buttons[\"Allow\"].tap()\n        return true  // Alert was handled\n    }\n    return false  // Alert was not handled\n}\n// IMPORTANT: After setting up the monitor, you must interact with the app\n// to trigger the handler:\napp.tap()\n\nThe handler is only invoked when the test tries to interact with the app and finds the alert blocking it.\n\n2. Direct alert interaction (simpler for known alerts):\nlet springboard = XCUIApplication(bundleIdentifier: \"com.apple.springboard\")\nlet allowButton = springboard.buttons[\"Allow\"]\nif allowButton.waitForExistence(timeout: 3) {\n    allowButton.tap()\n}\n\n3. Reset permissions between tests:\nlet app = XCUIApplication()\napp.resetAuthorizationStatus(for: .location)\napp.launch()\n\n(Available in iOS 15+)\n\nCommon gotchas:\n- The interruption monitor requires a subsequent app interaction (tap) to fire.\n- Multiple alerts may appear in sequence (e.g., tracking + notifications).\n- Alert button labels change between iOS versions and localizations.\n- The first launch after install triggers different alerts than subsequent launches.\n\nBest practices:\n- Set up interruption monitors in setUp() for permissions you always want to handle.\n- Use launch arguments to pre-set permission states when possible.\n- Test both the 'Allow' and 'Deny' paths for permission-dependent features.\n- Use resetAuthorizationStatus to get a clean state for permission tests.\n- For critical permission flows, write dedicated tests that verify the app's behavior when permission is denied."
  },
  {
    "topic": "ui-testing",
    "level": 2,
    "question": "What is the Page Object pattern for UI tests? How does it improve test maintainability?",
    "hint": "Think about encapsulating screen-specific element queries and actions into reusable objects that tests compose together.",
    "answer": "The Page Object pattern encapsulates UI element queries and interactions for a specific screen into a dedicated object, separating 'what to test' from 'how to interact with the UI'.\n\nWithout Page Objects:\nfunc testLogin() {\n    app.textFields[\"login.emailField\"].tap()\n    app.textFields[\"login.emailField\"].typeText(\"user@test.com\")\n    app.secureTextFields[\"login.passwordField\"].tap()\n    app.secureTextFields[\"login.passwordField\"].typeText(\"pass123\")\n    app.buttons[\"login.submitButton\"].tap()\n    XCTAssertTrue(app.staticTexts[\"home.welcomeLabel\"].waitForExistence(timeout: 5))\n}\n\nWith Page Objects:\nstruct LoginPage {\n    let app: XCUIApplication\n    \n    var emailField: XCUIElement { app.textFields[\"login.emailField\"] }\n    var passwordField: XCUIElement { app.secureTextFields[\"login.passwordField\"] }\n    var submitButton: XCUIElement { app.buttons[\"login.submitButton\"] }\n    \n    @discardableResult\n    func typeEmail(_ email: String) -> LoginPage {\n        emailField.tap()\n        emailField.typeText(email)\n        return self\n    }\n    \n    @discardableResult\n    func typePassword(_ password: String) -> LoginPage {\n        passwordField.tap()\n        passwordField.typeText(password)\n        return self\n    }\n    \n    func tapLogin() -> HomePage {\n        submitButton.tap()\n        return HomePage(app: app)\n    }\n}\n\nstruct HomePage {\n    let app: XCUIApplication\n    var welcomeLabel: XCUIElement { app.staticTexts[\"home.welcomeLabel\"] }\n    var isDisplayed: Bool { welcomeLabel.waitForExistence(timeout: 5) }\n}\n\nTest becomes:\nfunc testLogin() {\n    let homePage = LoginPage(app: app)\n        .typeEmail(\"user@test.com\")\n        .typePassword(\"pass123\")\n        .tapLogin()\n    XCTAssertTrue(homePage.isDisplayed)\n}\n\nBenefits:\n- DRY: Element queries are defined once. If an identifier changes, update one place.\n- Readable: Tests read like user stories.\n- Composable: Navigation methods return the next page, enabling fluent chaining.\n- Maintainable: UI changes only affect page objects, not test logic.\n- Reusable: Multiple tests share the same page objects."
  },
  {
    "topic": "ui-testing",
    "level": 2,
    "question": "What causes UI test flakiness and what strategies can you use to reduce it?",
    "hint": "Think about timing issues, environmental dependencies, test isolation, and non-deterministic behavior.",
    "answer": "UI test flakiness — tests that sometimes pass and sometimes fail without code changes — is one of the biggest challenges in UI testing.\n\nCommon causes:\n1. Timing issues: Elements not yet loaded, animations in progress, network responses varying in speed.\n2. State leakage: Previous tests leaving the app in an unexpected state.\n3. Environment differences: Different simulators, OS versions, or CI machine performance.\n4. System interruptions: Unexpected alerts, keyboard appearances, status bar changes.\n5. Test ordering: Tests that depend on running in a specific sequence.\n6. Race conditions: Multiple UI updates happening concurrently.\n\nStrategies to reduce flakiness:\n\n1. Proper waiting:\n- Use waitForExistence instead of sleep.\n- Wait for specific conditions (element enabled, text changed).\n- Set appropriate timeouts.\n\n2. Test isolation:\n- Reset app state before each test (launch arguments, clearing data).\n- Each test should work independently regardless of order.\n- Use unique test data per test.\n\n3. Disable animations:\nUIView.setAnimationsEnabled(false) // via launch argument\n\n4. Mock network layer:\n- Use a local mock server or inject stub responses.\n- Eliminates network variability.\n\n5. Stable selectors:\n- Always use accessibility identifiers.\n- Never rely on element indices or localized strings.\n\n6. Retry mechanisms:\n- CI can retry failed tests once before marking as failure.\n- But this is a band-aid — fix root causes.\n\n7. CI consistency:\n- Use the same simulator version across all CI machines.\n- Erase simulator state between test runs.\n- Use dedicated hardware or consistent VM configurations.\n\n8. Screenshot on failure:\n- Automatically capture screenshots when tests fail to aid debugging.\n- XCTest supports automatic screenshots via XCTAttachment."
  },
  {
    "topic": "ui-testing",
    "level": 2,
    "question": "How do you test navigation flows in UI tests? What are the challenges with complex navigation hierarchies?",
    "hint": "Think about verifying that tapping elements navigates to the correct screen, and handling deep navigation stacks, tab bars, and modal presentations.",
    "answer": "Testing navigation flows involves verifying that user actions lead to the correct screens with the expected content.\n\nBasic navigation testing:\nfunc testSettingsNavigation() {\n    app.tabBars.buttons[\"Settings\"].tap()\n    XCTAssertTrue(app.navigationBars[\"Settings\"].exists)\n    \n    app.cells[\"Account\"].tap()\n    XCTAssertTrue(app.navigationBars[\"Account\"].waitForExistence(timeout: 3))\n    \n    app.navigationBars.buttons.element(boundBy: 0).tap() // Back\n    XCTAssertTrue(app.navigationBars[\"Settings\"].waitForExistence(timeout: 3))\n}\n\nChallenges and solutions:\n\n1. Deep navigation stacks:\n- Tests must navigate through many screens to reach the target.\n- Solution: Use launch arguments to deep-link directly to the target screen.\n- Solution: Create helper methods that encapsulate common navigation paths.\n\n2. Tab bars:\n- Verify tab selection state and content switching.\n- Test that state is preserved when switching tabs and returning.\n\n3. Modal presentations:\n- Modals overlay the existing navigation hierarchy.\n- Verify dismissal returns to the correct screen.\n- Test swipe-to-dismiss gesture and cancel buttons.\n\n4. Navigation state restoration:\n- Test that reopening the app returns to the correct screen.\n- Use app.terminate() and app.launch() within a test.\n\n5. Conditional navigation:\n- Different user roles or states lead to different screens.\n- Set up the condition via launch environment, then verify the correct destination.\n\nWith Page Objects:\nfunc testFullPurchaseFlow() {\n    let productPage = HomePage(app: app)\n        .tapCategory(\"Electronics\")\n        .tapProduct(\"iPhone\")\n    \n    XCTAssertTrue(productPage.isDisplayed)\n    \n    let cartPage = productPage.tapAddToCart()\n    let checkoutPage = cartPage.tapCheckout()\n    let confirmationPage = checkoutPage.completePurchase()\n    \n    XCTAssertTrue(confirmationPage.successMessage.exists)\n}\n\nBest practices:\n- Verify the destination screen by checking for unique elements (navigation bar title, specific content).\n- Test the back/dismiss actions, not just forward navigation.\n- Keep navigation tests focused — don't test business logic within navigation tests."
  },
  {
    "topic": "ui-testing",
    "level": 3,
    "question": "How do you use test plans in Xcode for UI testing? What can they configure?",
    "hint": "Think about running the same tests with different configurations, languages, locales, or environment settings.",
    "answer": "Test plans (.xctestplan files) define reusable configurations for running tests. They allow running the same test suite under different conditions without duplicating test code.\n\nKey capabilities:\n\n1. Configurations:\n- Each test plan can have multiple named configurations.\n- Each configuration specifies language, region, locale, and other settings.\n- All configurations run when the test plan executes.\n\nExample configurations:\n- \"English (US)\" — Language: en, Region: US\n- \"Arabic (RTL)\" — Language: ar, Region: SA\n- \"German\" — Language: de, Region: DE\n\n2. Per-configuration settings:\n- Application language and region.\n- Launch arguments and environment variables.\n- Location simulation.\n- Code coverage collection on/off.\n- Address Sanitizer, Thread Sanitizer, Undefined Behavior Sanitizer.\n- Execution order (random or alphabetical).\n- Runtime API checking.\n\n3. Test selection:\n- Include/exclude specific test classes or methods.\n- Different test plans can run different subsets of tests.\n- Useful for smoke tests vs full regression suites.\n\n4. Shared settings:\n- Settings that apply across all configurations.\n- Override per-configuration when needed.\n\nUsage in CI:\nxcodebuild test -testPlan SmokeTests -scheme MyApp\nxcodebuild test -testPlan LocalizationTests -scheme MyApp\n\nPractical applications:\n- Localization testing: Run UI tests in every supported language.\n- Accessibility testing: Run with different dynamic type sizes.\n- Sanitizer testing: One plan with sanitizers for nightly runs.\n- Smoke tests: A lightweight plan that runs critical path tests on every PR.\n- Full regression: A comprehensive plan for nightly or release testing.\n\nBest practices:\n- Create separate test plans for different purposes (smoke, regression, localization).\n- Use shared settings for common configuration.\n- Reference test plans from CI scripts.\n- Store test plans in version control alongside the project."
  },
  {
    "topic": "ui-testing",
    "level": 3,
    "question": "How do you capture and use screenshots in XCUITest? What role do they play in debugging and continuous integration?",
    "hint": "Think about XCTAttachment, automatic vs manual screenshots, and how CI systems can surface screenshot artifacts.",
    "answer": "Screenshots in XCUITest serve both debugging and documentation purposes.\n\n1. Manual screenshots:\nfunc testLoginScreen() {\n    // Navigate to the screen\n    let screenshot = app.screenshot()\n    let attachment = XCTAttachment(screenshot: screenshot)\n    attachment.name = \"Login Screen\"\n    attachment.lifetime = .keepAlways // or .deleteOnSuccess\n    add(attachment)\n}\n\n2. Element-specific screenshots:\nlet loginButton = app.buttons[\"Login\"]\nlet screenshot = loginButton.screenshot()\n\n3. Automatic screenshots on failure:\nXcode automatically captures screenshots when a UI test fails. These appear in the test report.\n\n4. Configuring screenshot lifetime:\n- .keepAlways: Always keep the screenshot regardless of pass/fail.\n- .deleteOnSuccess: Only keep if the test fails (saves disk space).\n\n5. Using in CI:\n- Xcode generates .xcresult bundles containing screenshots.\n- Extract with: xcrun xcresulttool get --path TestResults.xcresult\n- CI systems (Bitrise, GitHub Actions) can archive these as build artifacts.\n- Tools like xcparse extract screenshots from result bundles.\n\n6. Screenshot-based testing workflow:\n- Capture screenshots at key points in a flow.\n- Use as visual documentation of the app's state.\n- Compare screenshots between runs to detect visual regressions (though this is better handled by dedicated snapshot testing libraries).\n\n7. Full-page screenshots:\nlet screenshot = XCUIScreen.main.screenshot()\n// Captures the entire screen including status bar.\n\nBest practices:\n- Capture screenshots at critical checkpoints (before/after actions).\n- Use .deleteOnSuccess in CI to save storage.\n- Name screenshots descriptively for easy identification in reports.\n- Combine with test failure messages for comprehensive failure context.\n- In CI, always archive the .xcresult bundle.\n- For visual regression testing, use dedicated snapshot testing libraries rather than manual screenshot comparison."
  },
  {
    "topic": "ui-testing",
    "level": 4,
    "question": "How do you test the same UI across different device sizes and orientations in XCUITest? What are the strategies for handling responsive layouts?",
    "hint": "Think about test plans, simulator selection, device rotation API, and size-class-dependent UI changes.",
    "answer": "Testing across device sizes and orientations ensures responsive layouts work correctly.\n\n1. Multiple simulators via test plans:\n- Create a test plan with configurations targeting different simulators.\n- CI runs tests on each specified simulator.\n- xcodebuild: -destination 'platform=iOS Simulator,name=iPhone SE (3rd generation)'\n- xcodebuild: -destination 'platform=iOS Simulator,name=iPad Pro (12.9-inch)'\n\n2. Orientation testing:\nfunc testLandscapeLayout() {\n    XCUIDevice.shared.orientation = .landscapeLeft\n    // Verify landscape-specific UI\n    XCTAssertTrue(app.buttons[\"sidebarToggle\"].exists)\n    \n    XCUIDevice.shared.orientation = .portrait\n    // Verify portrait-specific UI\n    XCTAssertFalse(app.buttons[\"sidebarToggle\"].exists)\n}\n\n3. Size-class-dependent testing:\n- iPad split view, slide over, and multitasking change size classes.\n- Test that your UI adapts when size classes change.\n- Multitasking can be simulated by changing the window size.\n\n4. Dynamic Type:\n- Set preferred content size category via launch arguments or accessibility settings.\n- Test that text is readable and layouts don't break with large fonts.\n\n5. Strategy patterns:\n\nTest matrix approach:\n- Define a matrix of device + orientation + text size combinations.\n- Use test plans to run tests across the matrix.\n- Prioritize the most common configurations.\n\nAdaptive assertions:\nfunc assertLayout() {\n    if UIDevice.current.userInterfaceIdiom == .pad {\n        XCTAssertTrue(app.tables[\"sidebar\"].exists)\n    } else {\n        XCTAssertTrue(app.tabBars.firstMatch.exists)\n    }\n}\n\n6. CI integration:\n- Run different test plans for different device categories.\n- Use parallel destinations to speed up matrix testing.\n- xcodebuild test -destination '...,name=iPhone 15' -destination '...,name=iPad Air'\n\nChallenges:\n- Element positions vary by device — use identifiers, not coordinates.\n- Animations may have different durations on different devices.\n- iPad multitasking introduces unique layout states.\n- Some UI is only visible on specific device types.\n\nBest practices:\n- Always restore orientation in tearDown: XCUIDevice.shared.orientation = .portrait\n- Test the extremes: smallest iPhone (SE), largest iPad, with largest Dynamic Type.\n- Focus UI tests on layout correctness; use snapshot tests for pixel-perfect verification.\n- Group device-specific tests separately so they can run on the appropriate simulators."
  },
  {
    "topic": "ui-testing",
    "level": 4,
    "question": "How does addUIInterruptionMonitor work internally, and what are its limitations? How do you handle complex alert sequences?",
    "hint": "Think about the interruption monitor's trigger mechanism, its requirement for subsequent interactions, and handling multiple sequential system dialogs.",
    "answer": "addUIInterruptionMonitor is XCUITest's mechanism for handling unexpected UI elements (usually system alerts) that block test interaction.\n\nHow it works internally:\n1. You register a handler with addUIInterruptionMonitor(withDescription:handler:).\n2. The handler is NOT called immediately when an alert appears.\n3. When your test tries to interact with the app (tap, swipe) and the interaction fails because a system alert is blocking, XCUITest invokes registered handlers.\n4. The handler receives an XCUIElement representing the blocking UI.\n5. The handler returns true if it handled the interruption, false otherwise.\n6. Handlers are called in reverse order of registration (LIFO).\n\nCritical limitations:\n\n1. Requires a subsequent interaction:\naddUIInterruptionMonitor(withDescription: \"Alert\") { alert in\n    alert.buttons[\"Allow\"].tap()\n    return true\n}\n// THIS IS REQUIRED — without it, the handler never fires:\napp.tap()\n\n2. Only fires for SpringBoard alerts (system dialogs), not your own app alerts.\n\n3. Multiple sequential alerts:\n- If two system alerts appear back-to-back (e.g., Location + Notifications), you need to handle both.\n- After handling the first, you need another app interaction to trigger the next handler.\n\nHandling complex sequences:\n\n// Approach 1: Multiple monitors\naddUIInterruptionMonitor(withDescription: \"Location\") { alert in\n    guard alert.buttons[\"Allow While Using App\"].exists else { return false }\n    alert.buttons[\"Allow While Using App\"].tap()\n    return true\n}\naddUIInterruptionMonitor(withDescription: \"Notifications\") { alert in\n    guard alert.buttons[\"Allow\"].exists else { return false }\n    alert.buttons[\"Allow\"].tap()\n    return true\n}\n// Trigger both\napp.tap()\nsleep(1)\napp.tap() // May need second tap for second alert\n\n// Approach 2: Direct SpringBoard interaction (more reliable)\nlet springboard = XCUIApplication(bundleIdentifier: \"com.apple.springboard\")\nfunc handleAlertIfPresent(buttonLabel: String) {\n    let button = springboard.buttons[buttonLabel]\n    if button.waitForExistence(timeout: 3) {\n        button.tap()\n    }\n}\nhandleAlertIfPresent(buttonLabel: \"Allow While Using App\")\nhandleAlertIfPresent(buttonLabel: \"Allow\")\n\nApproach 2 is generally more reliable because:\n- It doesn't require the trigger tap.\n- It handles alerts in a deterministic order.\n- It works for both system and app alerts.\n\nBest practices:\n- Prefer direct SpringBoard interaction for known alert sequences.\n- Use interruption monitors as a safety net for unexpected alerts.\n- Remove monitors in tearDown to prevent interference between tests.\n- Use resetAuthorizationStatus (iOS 15+) to avoid alerts altogether when testing non-permission features."
  },
  {
    "topic": "ui-testing",
    "level": 5,
    "question": "How do you write performance tests in XCTest, and what are the specific challenges of performance testing on iOS? How do you set reliable baselines?",
    "hint": "Think about measure blocks, metrics, baselines, environmental variability, and what makes performance tests meaningful versus noisy.",
    "answer": "XCTest provides infrastructure for performance testing via the measure API, but meaningful performance testing on iOS has significant challenges.\n\nBasic performance testing:\nfunc testScrollPerformance() {\n    measure(metrics: [XCTClockMetric(), XCTMemoryMetric(), XCTCPUMetric()]) {\n        // Code to measure\n        for _ in 0..<100 {\n            app.swipeUp()\n        }\n    }\n}\n\nAvailable metrics:\n- XCTClockMetric: Wall clock time.\n- XCTCPUMetric: CPU time and instruction count.\n- XCTMemoryMetric: Peak and average memory usage.\n- XCTStorageMetric: Disk I/O.\n- XCTOSSignpostMetric: Measures duration between os_signpost intervals (advanced).\n\nUI-specific performance testing (Xcode 12+):\nfunc testScrollingPerformance() throws {\n    app.launch()\n    app.staticTexts[\"Large List\"].tap()\n    \n    let measureOptions = XCTMeasureOptions()\n    measureOptions.invocationCount = 5\n    \n    measure(metrics: [XCTOSSignpostMetric.scrollDecelerationMetric],\n            options: measureOptions) {\n        app.swipeUp(velocity: .fast)\n    }\n}\n\nChallenges:\n\n1. Environmental variability:\n- CPU throttling, battery state, background processes, thermal state all affect results.\n- Simulators don't represent real device performance.\n- CI machines may have varying load levels.\n\n2. Setting reliable baselines:\n- Xcode allows setting per-device baselines.\n- Baselines should be set on a dedicated, controlled machine.\n- Too tight baselines cause false failures; too loose ones miss regressions.\n- Strategy: Set baselines to 15-20% above the measured value to account for variability.\n\n3. Noise reduction:\n- Run multiple iterations (default is 10, configurable).\n- Xcode discards outliers using standard deviation analysis.\n- Warm up the system before measuring (first iteration is often slower).\n- Disable unnecessary features during measurement.\n\n4. What to measure:\n- App launch time (cold and warm).\n- Scroll performance (frame drops, hitch rate).\n- Data processing time for large datasets.\n- Memory usage during complex operations.\n- Database query times.\n\n5. CI integration:\n- Store baselines in the test plan or xcodeproj (version controlled).\n- Set max standard deviation percentage to control acceptable variance.\n- Separate performance tests into a dedicated test plan that runs less frequently.\n- Use dedicated CI machines with consistent hardware for performance tests.\n\n6. Advanced: XCTOSSignpostMetric:\n- Allows measuring custom code regions marked with os_signpost.\n- Most accurate for measuring specific subsystems.\n- Requires instrumenting production code with signposts.\n\nBest practices:\n- Performance tests should run on real devices, not simulators.\n- Test on the lowest-spec supported device for worst-case performance.\n- Track trends over time rather than absolute values.\n- Use A/B comparison (before/after a change) rather than absolute baselines.\n- Keep performance tests isolated from functional tests.\n- Document what is being measured and why, as performance tests are often unclear in intent."
  },
  {
    "topic": "ui-testing",
    "level": 5,
    "question": "Design a comprehensive UI testing architecture for a large app with dozens of screens. How would you handle test data management, environment configuration, reusable patterns, and CI integration?",
    "hint": "Think about page objects, test data builders, base test classes, environment abstraction, parallel execution, and result reporting.",
    "answer": "A comprehensive UI testing architecture for a large app requires multiple layers of abstraction and infrastructure.\n\n1. Architecture layers:\n\nScreen Objects (Page Object pattern):\n- One struct per screen: LoginScreen, HomeScreen, SettingsScreen.\n- Each screen encapsulates element queries and user actions.\n- Navigation methods return the destination screen type.\n- Verification methods check screen state.\n\nprotocol Screen {\n    var app: XCUIApplication { get }\n    func verify() -> Self // Asserts the screen is displayed\n}\n\nstruct LoginScreen: Screen {\n    let app: XCUIApplication\n    @discardableResult func verify() -> Self {\n        XCTAssertTrue(app.textFields[\"login.email\"].waitForExistence(timeout: 5))\n        return self\n    }\n    func login(email: String, password: String) -> HomeScreen { ... }\n}\n\n2. Test data management:\n\nstruct TestUser {\n    static let standard = TestUser(email: \"test@example.com\", password: \"Test123!\")\n    static let admin = TestUser(email: \"admin@example.com\", password: \"Admin123!\")\n    let email: String\n    let password: String\n}\n\n- Use factory methods for complex test data.\n- Seed data via API calls in setUp if the backend supports it.\n- Use launch environment to configure mock data scenarios.\n\n3. Environment configuration:\n\nenum TestEnvironment {\n    case mockServer, staging, production\n    \n    var launchEnvironment: [String: String] {\n        switch self {\n        case .mockServer: return [\"API_URL\": \"http://localhost:8080\"]\n        case .staging: return [\"API_URL\": \"https://staging.api.com\"]\n        case .production: return [\"API_URL\": \"https://api.com\"]\n        }\n    }\n}\n\n4. Base test class:\n\nclass BaseUITest: XCTestCase {\n    let app = XCUIApplication()\n    var environment: TestEnvironment { .mockServer }\n    \n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n        app.launchArguments = [\"-UITestMode\", \"-disableAnimations\"]\n        app.launchEnvironment = environment.launchEnvironment\n        setupInterruptionMonitors()\n        app.launch()\n    }\n    \n    private func setupInterruptionMonitors() {\n        addUIInterruptionMonitor(withDescription: \"System Alert\") { alert in\n            alert.buttons[\"Allow\"].tap()\n            return true\n        }\n    }\n    \n    func captureScreenshot(name: String) {\n        let attachment = XCTAttachment(screenshot: app.screenshot())\n        attachment.name = name\n        attachment.lifetime = .deleteOnSuccess\n        add(attachment)\n    }\n}\n\n5. Flows for common paths:\n\nstruct Flows {\n    static func loginAsStandardUser(app: XCUIApplication) -> HomeScreen {\n        return LoginScreen(app: app)\n            .verify()\n            .login(email: TestUser.standard.email, password: TestUser.standard.password)\n    }\n}\n\n6. Test plans:\n- SmokePlan: Critical path tests only (~20 tests), runs on every PR.\n- RegressionPlan: All tests, runs nightly.\n- LocalizationPlan: Smoke tests in all supported languages.\n- AccessibilityPlan: Tests with Dynamic Type and VoiceOver configurations.\n\n7. CI integration:\n- Parallel execution: Split test classes across multiple simulators.\n- Result collection: Archive .xcresult bundles, extract failures and screenshots.\n- Flakiness tracking: Tag and quarantine flaky tests, track pass rates over time.\n- Mock server: Start a local mock server in a CI step before tests run.\n- Reporting: Generate HTML reports from xcresult bundles using xcresultparser or similar tools.\n\n8. Naming and organization:\nTests/UITests/\n  Screens/\n    LoginScreen.swift\n    HomeScreen.swift\n  Flows/\n    AuthenticationFlows.swift\n  TestData/\n    TestUser.swift\n  Base/\n    BaseUITest.swift\n  Tests/\n    LoginUITests.swift\n    HomeUITests.swift\n\nThis architecture scales to dozens of screens while keeping tests maintainable, readable, and reliable."
  },
  {
    "topic": "snapshot-testing",
    "level": 0,
    "question": "What is snapshot testing and why would you use it in an iOS project?",
    "hint": "Think about visually verifying UI appearance by comparing against a saved reference image rather than writing manual assertions.",
    "answer": "Snapshot testing is a technique where you render a UI component, capture its visual appearance as an image (or other representation), and compare it against a previously saved reference snapshot. If the current output differs from the reference, the test fails.\n\nWhy use snapshot testing:\n\n1. Visual regression detection: Catches unintended UI changes that unit tests miss — colors, spacing, fonts, layout.\n\n2. Faster than manual QA: Automatically verifies dozens of UI states that would take a human significant time to check.\n\n3. Documentation: Reference snapshots serve as a visual catalog of how components look in different states.\n\n4. Covers combinations: Test a component across multiple configurations (light/dark mode, device sizes, Dynamic Type, RTL) with minimal extra code.\n\n5. Complements other testing:\n- Unit tests verify logic.\n- UI tests verify flows and interactions.\n- Snapshot tests verify visual appearance.\n\nHow it works:\n1. First run (recording): The test renders the component, saves the output as a reference file, and the test fails to remind you to commit the reference.\n2. Subsequent runs (verification): The test renders the component and compares against the reference. If they match, the test passes. If different, it fails and provides a diff image.\n\nPopular libraries:\n- PointFree's SnapshotTesting (Swift, most popular).\n- iOSSnapshotTestCase (originally from Facebook/Uber).\n\nSnapshot testing is most valuable for shared design components, complex layouts, and UI that changes infrequently."
  },
  {
    "topic": "snapshot-testing",
    "level": 0,
    "question": "What is the difference between recording mode and verification mode in snapshot testing?",
    "hint": "Think about the first time you run a snapshot test versus subsequent runs.",
    "answer": "Snapshot testing has two modes that represent different phases of the workflow:\n\nRecording mode:\n- Captures the current UI output and saves it as the reference snapshot.\n- Used when creating a new snapshot test for the first time.\n- Also used when you intentionally change the UI and need to update the reference.\n- The test typically fails during recording to remind you that a new reference was created and needs to be committed.\n- In PointFree's library: isRecording = true or use withSnapshotTesting(record: .all).\n\nVerification mode (default):\n- Renders the current UI and compares it pixel-by-pixel against the saved reference.\n- If they match, the test passes.\n- If they differ, the test fails and typically generates a diff image showing the changes.\n- This is the normal mode for CI and everyday test runs.\n\nWorkflow:\n1. Write a new snapshot test.\n2. Run in recording mode to generate the reference snapshot.\n3. Review the generated snapshot to confirm it looks correct.\n4. Commit the reference snapshot to version control.\n5. Switch to verification mode (remove the recording flag).\n6. Future runs compare against the committed reference.\n\nWhen to re-record:\n- After intentional UI changes (design updates, new features).\n- After updating the snapshot library version (rendering may change).\n- After changing the test configuration (device size, OS version).\n\nBest practices:\n- Never leave recording mode enabled in committed code.\n- Review all new and changed snapshots in pull requests.\n- Store reference snapshots in version control alongside the code."
  },
  {
    "topic": "snapshot-testing",
    "level": 1,
    "question": "How does the PointFree SnapshotTesting library work? Show the basic usage for testing a SwiftUI view.",
    "hint": "Think about the assertSnapshot function, snapshot strategies, and how you host a SwiftUI view for snapshot capture.",
    "answer": "PointFree's swift-snapshot-testing is the most popular snapshot testing library for Swift. It provides a flexible, strategy-based approach to snapshot testing.\n\nBasic setup:\n// Package dependency\n.package(url: \"https://github.com/pointfreeco/swift-snapshot-testing\", from: \"1.15.0\")\n\nBasic usage with a SwiftUI view:\nimport SnapshotTesting\nimport XCTest\n@testable import MyApp\n\nclass ProfileViewSnapshotTests: XCTestCase {\n    func testProfileView() {\n        let view = ProfileView(user: .mock)\n        \n        assertSnapshot(\n            of: view,\n            as: .image(layout: .device(config: .iPhone13))\n        )\n    }\n}\n\nKey components:\n\n1. assertSnapshot(of:as:): The main assertion function.\n   - 'of' is the value to snapshot.\n   - 'as' is the strategy defining how to capture the snapshot.\n\n2. Strategies for SwiftUI views:\n   - .image(layout: .device(config: .iPhone13)) — renders at a specific device size.\n   - .image(layout: .fixed(width: 375, height: 200)) — renders at a fixed size.\n   - .image(layout: .sizeThatFits) — renders at the intrinsic content size.\n\n3. Recording:\n   // Record new reference (method 1 — per-test)\n   assertSnapshot(of: view, as: .image(...), record: true)\n   \n   // Record all (method 2 — globally)\n   withSnapshotTesting(record: .all) {\n       assertSnapshot(of: view, as: .image(...))\n   }\n\n4. Reference storage:\n   - Snapshots are saved in __Snapshots__/<TestClassName>/ next to the test file.\n   - File names match the test function name.\n   - Failed tests generate diff and failure images in a temporary directory.\n\n5. UIKit views work similarly:\n   let vc = ProfileViewController()\n   assertSnapshot(of: vc, as: .image(on: .iPhone13))\n\nBest practices:\n- Use consistent device configurations across all tests.\n- Name tests descriptively so snapshot filenames are meaningful.\n- Commit __Snapshots__ directories to version control."
  },
  {
    "topic": "snapshot-testing",
    "level": 1,
    "question": "How do you test a UI component in multiple configurations like light mode, dark mode, and different Dynamic Type sizes using snapshot testing?",
    "hint": "Think about wrapping the view in different trait environments or using the library's configuration options.",
    "answer": "Testing multiple configurations involves rendering the same component with different environment settings and comparing each against its own reference snapshot.\n\nApproach 1 — Multiple assertions with traits:\nfunc testProfileCard() {\n    let view = ProfileCard(user: .mock)\n    \n    // Light mode\n    assertSnapshot(\n        of: view,\n        as: .image(layout: .device(config: .iPhone13)),\n        named: \"light\"\n    )\n    \n    // Dark mode\n    assertSnapshot(\n        of: view,\n        as: .image(layout: .device(config: .iPhone13), traits: UITraitCollection(userInterfaceStyle: .dark)),\n        named: \"dark\"\n    )\n    \n    // Large Dynamic Type\n    assertSnapshot(\n        of: view,\n        as: .image(\n            layout: .device(config: .iPhone13),\n            traits: UITraitCollection(preferredContentSizeCategory: .accessibilityExtraLarge)\n        ),\n        named: \"largeText\"\n    )\n}\n\nApproach 2 — Helper function for all configs:\nfunc assertSnapshotInAllModes<V: View>(_ view: V, file: StaticString = #file, testName: String = #function, line: UInt = #line) {\n    let configs: [(name: String, traits: UITraitCollection)] = [\n        (\"light\", UITraitCollection(userInterfaceStyle: .light)),\n        (\"dark\", UITraitCollection(userInterfaceStyle: .dark)),\n        (\"largeText\", UITraitCollection(preferredContentSizeCategory: .accessibilityExtraLarge)),\n    ]\n    \n    for config in configs {\n        assertSnapshot(\n            of: view,\n            as: .image(layout: .device(config: .iPhone13), traits: config.traits),\n            named: config.name,\n            file: file,\n            testName: testName,\n            line: line\n        )\n    }\n}\n\n// Usage:\nfunc testProfileCard() {\n    assertSnapshotInAllModes(ProfileCard(user: .mock))\n}\n\nApproach 3 — Different device sizes:\nlet devices: [(name: String, config: ViewImageConfig)] = [\n    (\"iPhoneSE\", .iPhoneSe),\n    (\"iPhone13\", .iPhone13),\n    (\"iPadPro\", .iPadPro12_9),\n]\n\nfor device in devices {\n    assertSnapshot(\n        of: view,\n        as: .image(layout: .device(config: device.config)),\n        named: device.name\n    )\n}\n\nApproach 4 — RTL testing:\nlet rtlTraits = UITraitCollection(layoutDirection: .rightToLeft)\nassertSnapshot(\n    of: view,\n    as: .image(layout: .device(config: .iPhone13), traits: rtlTraits),\n    named: \"rtl\"\n)\n\nEach named variant generates a separate reference snapshot file, so you get comprehensive coverage with minimal code."
  },
  {
    "topic": "snapshot-testing",
    "level": 2,
    "question": "What snapshot strategies are available beyond image snapshots? When would you use text-based or other non-image strategies?",
    "hint": "Think about the .dump, .recursiveDescription, and .json strategies, and scenarios where image comparison is not the best approach.",
    "answer": "PointFree's SnapshotTesting library supports multiple strategies beyond pixel-based image comparison:\n\n1. .image — Visual pixel comparison:\n- Most common for UI testing.\n- Renders the view/controller as a PNG image.\n- Best for: Verifying visual appearance, layout, colors, spacing.\n\n2. .recursiveDescription — UIKit view hierarchy:\nassertSnapshot(of: viewController, as: .recursiveDescription)\n- Captures the text output similar to LLDB's 'po view.recursiveDescription()'.\n- Shows the full view tree with frames, classes, and properties.\n- Best for: Verifying view hierarchy structure without caring about exact pixels.\n- Advantage: Not affected by rendering differences across machines.\n\n3. .dump — Swift Mirror dump:\nassertSnapshot(of: viewModel, as: .dump)\n- Uses Swift's dump() to create a text representation of any value.\n- Shows all properties and nested values.\n- Best for: Snapshot testing non-UI values like view models, data models, or state.\n\n4. .json — JSON encoding:\nassertSnapshot(of: apiResponse, as: .json)\n- Encodes Encodable values as formatted JSON.\n- Best for: Testing API response models, configuration objects, serialization.\n\n5. .plist — Property list:\nassertSnapshot(of: settings, as: .plist)\n\n6. Custom strategies:\n- You can create custom Snapshotting strategies for any type.\n- Define how to serialize (snapshot) and compare (diff) values.\n\nWhen to use non-image strategies:\n\n- View model testing: Use .dump to verify complex state without building UI.\nassertSnapshot(of: viewModel.state, as: .dump)\n\n- API contract testing: Use .json to verify response models haven't changed.\nassertSnapshot(of: decodedResponse, as: .json)\n\n- CI reliability: Text-based snapshots are deterministic across machines (no rendering differences).\n\n- Performance: Text comparison is faster than image comparison.\n\n- View hierarchy verification: Use .recursiveDescription when you care about structure but not pixels.\n\nBest practice: Use image snapshots for visual design verification and text-based snapshots for structural and data verification. Combine both for comprehensive coverage."
  },
  {
    "topic": "snapshot-testing",
    "level": 2,
    "question": "How do you prevent false positives and false negatives in snapshot tests? What are the common pitfalls?",
    "hint": "Think about non-deterministic content (dates, animations), rendering differences across environments, and overly broad vs overly narrow snapshots.",
    "answer": "False positives (tests fail when nothing meaningful changed) and false negatives (tests pass when bugs exist) both undermine confidence in snapshot tests.\n\nCommon causes of false positives:\n\n1. Non-deterministic content:\n- Dates, timestamps, random IDs displayed in the UI.\n- Solution: Inject fixed dates and mock data. Use a fixed locale and timezone.\n\n2. Rendering differences across machines:\n- Different macOS versions render fonts slightly differently.\n- CI machines may have different GPU capabilities.\n- Solution: Pin the exact macOS and Xcode version in CI. Use tolerance thresholds.\n\n3. Simulator differences:\n- Different iOS simulator versions may render differently.\n- Solution: Lock the simulator runtime version.\n\n4. Animation state:\n- Capturing during an animation produces different results.\n- Solution: Disable animations in test setup.\n\n5. Cursor/selection state:\n- Text fields with active cursors blink.\n- Solution: Resign first responder before snapshot.\n\n6. Anti-aliasing and subpixel rendering:\n- Floating-point layout calculations can differ by fractions of a pixel.\n- Solution: Use perceptual diff with a small tolerance rather than exact pixel comparison.\n\nCommon causes of false negatives:\n\n1. Snapshot too broad:\n- Full-screen snapshots may not detect small changes in dense UIs.\n- Solution: Also snapshot individual components at larger scale.\n\n2. Reference snapshots not updated:\n- Old references committed that don't match current design.\n- Solution: Review snapshot changes in PRs.\n\n3. Missing configurations:\n- Only testing light mode misses dark mode regressions.\n- Solution: Test all meaningful configuration combinations.\n\nPrevention strategies:\n- Use deterministic test data (fixed dates, sorted arrays, seeded randoms).\n- Set the locale, timezone, and calendar explicitly in tests.\n- Control the environment completely (no network, no real data).\n- Keep snapshot scope focused — test components, not entire screens when possible.\n- Review all snapshot changes in code review.\n- Use a tolerance/threshold for image comparison (1-2% can absorb rendering noise).\n- Document which macOS/Xcode/simulator version snapshots were recorded on.\n- Consider recording snapshots in CI to ensure consistency."
  },
  {
    "topic": "snapshot-testing",
    "level": 3,
    "question": "What are the challenges of running snapshot tests in CI, and how do you solve the 'works on my machine' problem for pixel-perfect comparisons?",
    "hint": "Think about rendering differences between developer machines and CI, font rendering, GPU differences, and strategies like CI-only recording.",
    "answer": "Snapshot tests are notoriously problematic in CI because pixel-level rendering depends on the exact environment.\n\nCore challenges:\n\n1. macOS version differences:\n- Core Text renders fonts differently across macOS versions.\n- A snapshot recorded on macOS 14 may fail on macOS 15.\n- Even minor updates (14.4 vs 14.5) can change rendering.\n\n2. Xcode version differences:\n- Different Xcode versions ship different simulators with different rendering.\n- SwiftUI rendering can change between Xcode point releases.\n\n3. Hardware differences:\n- GPU (integrated vs discrete) affects anti-aliasing and rendering.\n- Retina vs non-Retina displays affect scale factors.\n\n4. Simulator differences:\n- iOS runtime versions render differently.\n- Simulator window scale can affect captures.\n\nSolutions:\n\n1. Record snapshots in CI, verify in CI:\n- ONLY generate reference snapshots on the CI machine.\n- Developers never record locally — they push code, CI records, they pull the snapshots.\n- Ensures references always match the CI environment.\n- Workflow: PR records new snapshots -> team reviews -> merge.\n\n2. Pin the exact environment:\n- Lock macOS version (e.g., macOS 14.4.1 specifically).\n- Lock Xcode version (14.3.1, not just 14.x).\n- Lock simulator runtime (iOS 17.4, not just iOS 17).\n- Use the same hardware (all M1, or all Intel).\n\n3. Tolerance-based comparison:\n- Allow a small per-pixel difference threshold.\n- PointFree library supports precision parameter:\nassertSnapshot(of: view, as: .image(precision: 0.99))\n- 0.99 allows 1% pixel difference.\n- perceptualPrecision allows color differences below a perceptual threshold.\nassertSnapshot(of: view, as: .image(precision: 0.99, perceptualPrecision: 0.98))\n\n4. Use text-based snapshots where possible:\n- .recursiveDescription and .dump are deterministic across environments.\n- Reserve image snapshots for truly visual concerns.\n\n5. Docker/VM-based CI:\n- Use identical VM images for all CI runs.\n- macOS VMs on services like MacStadium or Cirrus CI.\n\n6. Dedicated snapshot CI job:\n- Separate snapshot verification from other tests.\n- Run on a dedicated, controlled machine.\n\nBest practice combination:\n- Pin the environment tightly.\n- Use tolerance (precision: 0.995, perceptualPrecision: 0.98).\n- Record references in CI, not locally.\n- Fail loudly when the environment changes (check macOS/Xcode version in test setUp)."
  },
  {
    "topic": "snapshot-testing",
    "level": 3,
    "question": "How do you snapshot test view models or application state rather than UI? When is this approach preferable to image-based snapshots?",
    "hint": "Think about using .dump or custom strategies to capture the state of a view model, and why this avoids rendering-dependent issues.",
    "answer": "Snapshot testing is not limited to visual UI — it is equally powerful for verifying complex data structures, view model states, and application state.\n\nSnapshot testing view models:\n\nstruct ProfileViewModel {\n    var name: String\n    var email: String\n    var avatarURL: URL?\n    var badges: [Badge]\n    var isVerified: Bool\n}\n\nfunc testProfileViewModelState() {\n    let viewModel = ProfileViewModel(\n        name: \"Alice\",\n        email: \"alice@example.com\",\n        avatarURL: URL(string: \"https://example.com/avatar.jpg\"),\n        badges: [.earlyAdopter, .contributor],\n        isVerified: true\n    )\n    \n    assertSnapshot(of: viewModel, as: .dump)\n}\n\nThis generates a text file like:\n- ProfileViewModel\n  - name: \"Alice\"\n  - email: \"alice@example.com\"\n  - avatarURL: https://example.com/avatar.jpg\n  - badges: 2 elements\n    - Badge.earlyAdopter\n    - Badge.contributor\n  - isVerified: true\n\nFor Encodable types, use .json:\nassertSnapshot(of: apiResponse, as: .json)\n\nWhen state snapshots are preferable:\n\n1. Complex state verification:\n- A view model with dozens of properties is tedious to assert individually.\n- XCTAssertEqual requires Equatable conformance on every nested type.\n- Snapshot captures everything in one assertion.\n\n2. CI reliability:\n- No rendering dependencies — text comparison is deterministic.\n- Works identically on any machine.\n\n3. Regression detection for data transformations:\n- Test that a data pipeline produces the same output.\n- Catch unexpected changes in API response parsing.\n\n4. State machine testing:\n- Snapshot the state after each transition.\n- Detect unintended state changes.\n\nfunc testStateMachine() {\n    var machine = OrderStateMachine()\n    assertSnapshot(of: machine.currentState, as: .dump, named: \"initial\")\n    \n    machine.handle(.addItem(.mock))\n    assertSnapshot(of: machine.currentState, as: .dump, named: \"afterAddItem\")\n    \n    machine.handle(.checkout)\n    assertSnapshot(of: machine.currentState, as: .dump, named: \"afterCheckout\")\n}\n\n5. Custom snapshot strategies:\n- Create strategies for domain-specific types.\n- Example: A strategy that snapshots a Core Data model graph.\n\nLimitations:\n- .dump output can be verbose for large objects.\n- .dump format is not guaranteed stable across Swift versions.\n- .json requires Encodable conformance.\n- Cannot catch visual issues (wrong colors, broken layouts).\n\nBest practice: Use state snapshots for logic and data, image snapshots for visual design. They complement each other."
  },
  {
    "topic": "snapshot-testing",
    "level": 4,
    "question": "How do you integrate snapshot testing into a SwiftUI preview-driven workflow? What are the challenges of snapshot testing SwiftUI views specifically?",
    "hint": "Think about how SwiftUI views need a hosting environment, how previews relate to snapshot test configs, and SwiftUI-specific rendering behaviors.",
    "answer": "Snapshot testing SwiftUI views has unique challenges compared to UIKit, and integrating with the preview workflow requires careful design.\n\nHosting SwiftUI views for snapshots:\nSwiftUI views must be wrapped in a UIHostingController for the SnapshotTesting library:\n\nlet view = ProfileView(user: .mock)\nassertSnapshot(\n    of: view,\n    as: .image(layout: .device(config: .iPhone13))\n)\n\nThe library handles the UIHostingController wrapping internally for SwiftUI views.\n\nSwiftUI-specific challenges:\n\n1. Environment dependencies:\n- SwiftUI views may depend on @Environment values.\n- Missing environment values cause crashes or incorrect rendering.\n- Solution: Inject all required environment values:\nlet view = ProfileView(user: .mock)\n    .environment(\\.colorScheme, .dark)\n    .environment(\\.sizeCategory, .large)\n    .environment(\\.locale, Locale(identifier: \"en_US\"))\n\n2. State and binding:\n- Views with @State may render differently on first vs subsequent renders.\n- @Binding requires a source of truth.\n- Solution: Create wrapper views with fixed state for testing.\n\nstruct SnapshotWrapper: View {\n    @State var text = \"predefined\"\n    var body: some View {\n        SearchField(text: $text)\n    }\n}\n\n3. Async rendering:\n- SwiftUI may not render fully in one pass (lazy stacks, async images).\n- Solution: Use a small delay or ensure all data is synchronously available.\n\n4. Animation interference:\n- withAnimation blocks and implicit animations affect the captured state.\n- Solution: Wrap in a transaction with animation disabled, or use fixed state that bypasses animations.\n\n5. Preview-to-snapshot alignment:\n- SwiftUI previews and snapshot tests can share the same mock data and configurations.\n\n// Shared mock data\nextension User {\n    static let snapshotMock = User(name: \"Alice\", avatar: .placeholder)\n}\n\n// In Previews:\n#Preview { ProfileView(user: .snapshotMock) }\n\n// In Snapshot Tests:\nfunc testProfileView() {\n    assertSnapshot(of: ProfileView(user: .snapshotMock), as: .image(...))\n}\n\n6. Layout behavior:\n- SwiftUI views propose sizes differently than UIKit.\n- .sizeThatFits may produce unexpected results for views that expand.\n- Use .fixed(width:height:) or .device(config:) for predictable sizing.\n\n7. Rendering differences across OS versions:\n- SwiftUI's renderer changes between iOS versions.\n- A view may look slightly different on iOS 17 vs iOS 18.\n- Solution: Pin the simulator version and re-record when upgrading.\n\nAdvanced patterns:\n\n// Protocol for snapshot-testable views\nprotocol SnapshotTestable: View {\n    static var snapshotConfigurations: [SnapshotConfiguration] { get }\n}\n\nstruct SnapshotConfiguration {\n    let name: String\n    let colorScheme: ColorScheme\n    let sizeCategory: ContentSizeCategory\n    let layoutDirection: LayoutDirection\n}\n\n// Automatically test all configurations\nfunc assertAllSnapshots<V: SnapshotTestable>(_ view: V) {\n    for config in V.snapshotConfigurations {\n        let configured = view\n            .environment(\\.colorScheme, config.colorScheme)\n            .environment(\\.sizeCategory, config.sizeCategory)\n            .environment(\\.layoutDirection, config.layoutDirection)\n        assertSnapshot(of: configured, as: .image(...), named: config.name)\n    }\n}\n\nBest practices:\n- Keep snapshot-tested views pure (no side effects, no network calls).\n- Share mock data between previews and snapshot tests.\n- Test components in isolation before testing composed screens.\n- Use environment overrides explicitly rather than relying on system defaults."
  },
  {
    "topic": "snapshot-testing",
    "level": 4,
    "question": "What are perceptual diff tools and how do they improve snapshot testing compared to pixel-perfect comparison?",
    "hint": "Think about how humans perceive visual differences versus how computers compare pixels, and tools that bridge this gap.",
    "answer": "Perceptual diff tools compare images based on how humans perceive visual differences rather than exact pixel values, reducing false positives from insignificant rendering variations.\n\nPixel-perfect comparison problems:\n- A 1-pixel anti-aliasing shift fails the test even though it is invisible to users.\n- Font rendering differences across macOS versions cause widespread failures.\n- Subpixel positioning changes due to floating-point arithmetic create noise.\n- GPU differences affect gradient and shadow rendering at the subpixel level.\n\nHow perceptual diff works:\n\n1. Structural Similarity Index (SSIM):\n- Compares images based on luminance, contrast, and structure.\n- Produces a similarity score from 0 (completely different) to 1 (identical).\n- Small rendering differences score close to 1.0.\n\n2. Delta E (color difference):\n- Measures color difference in perceptually uniform color spaces (CIELAB).\n- Delta E < 1.0 is imperceptible to the human eye.\n- Delta E < 3.0 is barely noticeable.\n\n3. PointFree's perceptualPrecision:\nassertSnapshot(\n    of: view,\n    as: .image(\n        precision: 0.99,          // 99% of pixels must match\n        perceptualPrecision: 0.98  // Each pixel's color within 2% perceptual tolerance\n    )\n)\n\n- precision: The fraction of pixels that must match (after applying perceptualPrecision).\n- perceptualPrecision: How closely each individual pixel must match (1.0 = exact, 0.0 = any color matches).\n\n4. Third-party perceptual diff tools:\n- Kaleidoscope: Visual diff tool for macOS with perceptual comparison.\n- Applitools: Cloud-based visual testing with AI-powered comparison.\n- Percy (BrowserStack): Web-focused but concepts apply.\n\nConfiguring tolerance effectively:\n\n// Too strict — false positives from rendering noise\n.image(precision: 1.0, perceptualPrecision: 1.0)\n\n// Good balance — catches real changes, ignores noise\n.image(precision: 0.995, perceptualPrecision: 0.98)\n\n// Too loose — misses subtle bugs\n.image(precision: 0.9, perceptualPrecision: 0.9)\n\nStrategies:\n- Start strict and loosen only when encountering false positives.\n- Use different tolerances for different test categories (strict for icons, looser for full screens).\n- Log the actual diff percentage when tests fail to calibrate thresholds.\n- Combine perceptual precision with CI environment pinning for best results.\n\nLimitations of perceptual diff:\n- Cannot detect layout shifts that happen to produce similar colors.\n- Very small elements (1-2 pixel icons) may fall below the threshold.\n- Tolerances that are too loose create a blind spot for genuine regressions.\n\nBest practice: Use perceptual diff as a noise filter, not a substitute for careful reference management. The tolerance should be just enough to absorb environmental rendering differences while still catching intentional design changes."
  },
  {
    "topic": "snapshot-testing",
    "level": 5,
    "question": "When should you NOT use snapshot tests? What are the failure modes and anti-patterns of over-relying on snapshot testing?",
    "hint": "Think about maintenance burden, test fragility, review fatigue, what snapshots cannot verify, and when other testing approaches are more appropriate.",
    "answer": "While snapshot testing is powerful, it has significant limitations and failure modes that make it inappropriate in certain situations.\n\nWhen NOT to use snapshot tests:\n\n1. Highly dynamic content:\n- Views that change frequently by design (news feeds, live data, personalized content).\n- Each change requires re-recording, creating constant maintenance.\n- Better approach: Test the data layer with unit tests; verify layout structure with a few stable configurations.\n\n2. Interactive behavior:\n- Snapshots capture a static moment, not user interactions.\n- They cannot verify that a button tap triggers the correct action.\n- Better approach: Unit test the behavior, UI test the interactions.\n\n3. Early/exploratory development:\n- When the UI is changing daily, snapshot tests create friction without value.\n- Better approach: Wait until the design stabilizes before adding snapshot tests.\n\n4. Simple views:\n- A view with a single label does not benefit from snapshot testing.\n- The cost of maintaining the reference outweighs the protection.\n- Better approach: Unit test the data transformation; trust SwiftUI to render a Text correctly.\n\nAnti-patterns:\n\n1. Snapshot everything:\n- Hundreds of snapshot tests create massive reference directories.\n- Git diffs become unreadable (binary files cannot be diffed).\n- Storage bloat: reference + failure + diff images for every test.\n- Review fatigue: Reviewers rubber-stamp snapshot changes without careful inspection.\n\n2. Full-screen snapshots only:\n- A full-screen snapshot of a complex screen is a 'shotgun assertion.'\n- Any change anywhere on the screen fails the test.\n- Hard to determine what specifically changed.\n- Better: Snapshot individual components AND key full-screen states.\n\n3. Not reviewing reference changes:\n- Developers blindly re-record when snapshots fail.\n- Defeats the purpose — regressions get baked into new references.\n- Process fix: Require explicit approval of snapshot changes in PR reviews.\n\n4. Using snapshots as the only test layer:\n- Snapshots verify appearance but not correctness.\n- A view might look right but display the wrong data.\n- Always combine with unit tests for logic and data.\n\n5. Ignoring CI environment drift:\n- References recorded locally fail in CI, leading to chronic failures.\n- Team ignores snapshot failures, treating them as noise.\n\nMaintenance burden reality:\n- Every design system update requires mass re-recording.\n- OS upgrades may require re-recording everything.\n- Teams often disable or delete snapshot tests when the burden becomes too high.\n\nThe right balance:\n- Snapshot test shared design components (buttons, cards, cells) that change infrequently.\n- Snapshot test a few key screens in their most important states.\n- Use text-based snapshots (.dump, .json) for state verification.\n- Limit to ~50-100 image snapshots for a medium-sized app.\n- Treat snapshot tests as a complement to unit and integration tests, never a replacement."
  },
  {
    "topic": "snapshot-testing",
    "level": 5,
    "question": "Design a complete snapshot testing strategy for a design system library used across multiple apps. Cover infrastructure, automation, review process, and scaling concerns.",
    "hint": "Think about how a shared design system has unique requirements: many configurations, multiple consumers, backward compatibility, and the need for a visual catalog.",
    "answer": "A design system library requires a robust snapshot testing strategy because changes affect multiple consuming applications.\n\n1. Test organization:\n\nDesignSystemTests/\n  SnapshotTests/\n    Components/\n      ButtonSnapshotTests.swift\n      CardSnapshotTests.swift\n      InputFieldSnapshotTests.swift\n    Tokens/\n      ColorTokenSnapshotTests.swift\n      TypographySnapshotTests.swift\n    Compositions/\n      FormLayoutSnapshotTests.swift\n  __Snapshots__/\n    ButtonSnapshotTests/\n      testPrimaryButton_light.png\n      testPrimaryButton_dark.png\n\n2. Configuration matrix:\nEvery component must be tested across a standard matrix:\n\nstruct SnapshotMatrix {\n    static let colorSchemes: [ColorScheme] = [.light, .dark]\n    static let sizeCategories: [ContentSizeCategory] = [.small, .large, .accessibilityExtraExtraLarge]\n    static let layoutDirections: [LayoutDirection] = [.leftToRight, .rightToLeft]\n    static let devices: [ViewImageConfig] = [.iPhoneSe, .iPhone13, .iPadPro12_9]\n}\n\nFor a single button component with 3 states (default, pressed, disabled):\n3 states x 2 color schemes x 3 text sizes x 2 directions x 3 devices = 108 snapshots.\n\nThis is too many. Optimize:\n- Full matrix only for critical components (Button, Input, Card).\n- Reduced matrix for less critical components.\n- Use a 'spot check' approach: full matrix for one component per category, minimal for others.\n\n3. Automation infrastructure:\n\n// Base class with matrix testing support\nclass DesignSystemSnapshotTest: XCTestCase {\n    enum MatrixLevel {\n        case full      // All configurations\n        case standard  // Light/dark + 2 text sizes\n        case minimal   // Light mode, default text only\n    }\n    \n    func assertComponentSnapshot<V: View>(\n        _ view: V,\n        matrixLevel: MatrixLevel = .standard,\n        file: StaticString = #file,\n        testName: String = #function,\n        line: UInt = #line\n    ) {\n        let configs = configurations(for: matrixLevel)\n        for config in configs {\n            let configured = view\n                .environment(\\.colorScheme, config.colorScheme)\n                .environment(\\.sizeCategory, config.sizeCategory)\n            assertSnapshot(\n                of: configured,\n                as: .image(layout: .fixed(width: 375, height: 100), traits: config.traits),\n                named: config.name,\n                file: file,\n                testName: testName,\n                line: line\n            )\n        }\n    }\n}\n\n4. CI pipeline:\n\n- Dedicated snapshot CI job that runs on a pinned macOS/Xcode environment.\n- Snapshot recording happens ONLY in CI to eliminate machine-specific differences.\n- Workflow:\n  a. Developer makes a change and pushes.\n  b. CI runs snapshot tests. If they fail, it re-records and creates a commit with updated snapshots.\n  c. PR diff shows the visual changes for review.\n  d. Alternatively, CI generates a visual diff report (HTML gallery comparing old vs new).\n\n5. Visual review process:\n\n- Generate an HTML report showing before/after/diff for changed snapshots.\n- Script: Iterate through changed snapshot files, generate a side-by-side gallery.\n- Require explicit approval from a designer for visual changes.\n- GitHub PR labels: 'visual-change-approved' gate for merging.\n\n6. Backward compatibility:\n\n- When deprecating a component variant, keep its snapshot test until removal.\n- Version the snapshot references: v1/ and v2/ directories if supporting multiple design versions.\n- Run snapshots for all supported theme configurations.\n\n7. Scaling concerns:\n\n- Storage: Hundreds of PNG files bloat the repo. Consider Git LFS for __Snapshots__ directories.\n- Speed: Running 500+ snapshot tests takes time. Parallelize across test classes.\n- Review fatigue: Only show changed snapshots in PR reviews, not all 500.\n- Selective testing: Only run snapshot tests for changed components (detect via git diff).\n\n8. Supplementary strategies:\n\n- .dump snapshots for design token values (colors, spacing, typography).\n- Accessibility audit snapshots: Verify that components pass accessibility contrast ratios.\n- Animation keyframe snapshots: Capture views at animation start, middle, and end states.\n\n9. Documentation generation:\n\n- Use snapshot references as a visual component catalog.\n- Auto-generate a static website from __Snapshots__ showing every component in every state.\n- This serves as living documentation for designers and consuming app developers.\n\nThis strategy balances comprehensive coverage with practical maintainability, using automation to manage the inherent complexity of design system testing."
  },
  {
    "topic": "swiftdata",
    "level": 0,
    "question": "What is the @Model macro in SwiftData, and how does it differ from NSManagedObject in Core Data?",
    "hint": "Think about how SwiftData eliminates boilerplate by leveraging Swift macros introduced in Swift 5.9.",
    "answer": "The @Model macro is a Swift macro that transforms a regular Swift class into a SwiftData-managed persistent model. When you annotate a class with @Model, the macro automatically generates the conformance to the PersistentModel protocol and the Observable protocol, synthesizes property storage backed by SwiftData, and makes all stored properties persistable by default.\n\nUnlike Core Data's NSManagedObject, which requires a separate .xcdatamodeld file, manual subclass generation, and @NSManaged property annotations, @Model works directly on plain Swift classes with no external schema file. You simply write:\n\n@Model\nclass Task {\n    var title: String\n    var isCompleted: Bool\n    var createdAt: Date\n}\n\nThe macro handles everything at compile time: it rewrites stored properties to use SwiftData's backing store, adds change tracking, and makes the class observable for SwiftUI. This means you get type safety at compile time, no stringly-typed key paths, and no need for code generation tools. Core Data's NSManagedObject, by contrast, relies on runtime dynamism, KVO for observation, and a visual model editor."
  },
  {
    "topic": "swiftdata",
    "level": 0,
    "question": "What are ModelContainer and ModelContext in SwiftData, and what role does each play?",
    "hint": "Draw an analogy to Core Data's NSPersistentContainer and NSManagedObjectContext.",
    "answer": "ModelContainer is the object responsible for managing the entire persistence stack in SwiftData. It holds the schema (the set of @Model types), the storage configuration (in-memory, on-disk, or custom store), and creates the underlying database. You initialize it by passing your model types:\n\nlet container = try ModelContainer(for: Task.self, Tag.self)\n\nYou can also pass a ModelConfiguration to control the storage URL, whether it is read-only, or whether it uses CloudKit.\n\nModelContext is the workspace where you create, read, update, and delete model objects. It tracks changes in memory and writes them to the container when you call save(). Every ModelContainer has a mainContext that runs on the main actor, suitable for UI-driven work.\n\nThe relationship mirrors Core Data: ModelContainer is analogous to NSPersistentContainer (it sets up the stack), and ModelContext is analogous to NSManagedObjectContext (it manages a scratchpad of objects). In SwiftUI, you inject the container with the .modelContainer() modifier, and views automatically receive the mainContext through the @Environment(\\.modelContext) property. You can also create additional contexts for background work by calling ModelContext(container)."
  },
  {
    "topic": "swiftdata",
    "level": 0,
    "question": "How does the @Query property wrapper work in SwiftUI, and what does it provide automatically?",
    "hint": "Consider how @Query replaces NSFetchedResultsController and what triggers view updates.",
    "answer": "@Query is a SwiftUI property wrapper that fetches persistent model objects from the ModelContext and keeps the view automatically updated when the underlying data changes. You declare it in a SwiftUI view like this:\n\n@Query(sort: \\Task.createdAt, order: .reverse)\nvar tasks: [Task]\n\nWhen the view appears, @Query executes a fetch against the model context available in the environment. Whenever objects matching the query are inserted, updated, or deleted, SwiftUI automatically re-evaluates the view body — no manual observation or notification handling required.\n\n@Query supports several configuration options: you can pass a filter using #Predicate, specify sort descriptors with SortDescriptor, set a fetchLimit, and provide an animation for changes. It effectively replaces Core Data's NSFetchedResultsController with a declarative, SwiftUI-native API.\n\nUnder the hood, @Query leverages the Observable conformance that @Model provides. The property wrapper subscribes to changes in the model context and triggers view invalidation when relevant mutations occur. This tight integration means your views always display fresh data without any imperative fetch-and-reload cycles."
  },
  {
    "topic": "swiftdata",
    "level": 1,
    "question": "How does #Predicate work in SwiftData, and what advantages does it have over NSPredicate?",
    "hint": "Think about type safety, Swift-native syntax, and compile-time validation.",
    "answer": "#Predicate is a Swift macro that creates type-safe, compile-time-checked filter expressions for SwiftData queries. Instead of writing stringly-typed NSPredicate format strings, you write native Swift expressions:\n\nlet highPriority = #Predicate<Task> { task in\n    task.priority >= 3 && !task.isCompleted\n}\n\nThe key advantages over NSPredicate are:\n\n1. Type safety: The compiler verifies that property names and types are correct. A typo like task.titl would produce a compile-time error, whereas NSPredicate(format: \"titl == %@\", value) would crash at runtime.\n\n2. Swift-native syntax: You use familiar Swift operators (&&, ||, !, ==, >, <) and can reference key paths directly rather than learning a separate predicate format string language.\n\n3. Refactoring support: Since #Predicate uses actual Swift key paths, Xcode refactoring tools (rename, find usages) work correctly across your predicates.\n\n4. Autocompletion: Xcode provides full autocompletion inside the closure, whereas NSPredicate format strings get no IDE assistance.\n\n5. Complex expressions: You can use Swift features like string methods (.contains, .localizedStandardContains), optional chaining, and even combine multiple conditions naturally.\n\nThe #Predicate macro translates your Swift expression into an internal predicate representation that SwiftData can convert into efficient SQL queries for the underlying SQLite store. Not all Swift expressions are supported — only those that can be mapped to database operations — and the compiler will warn you if you use an unsupported expression."
  },
  {
    "topic": "swiftdata",
    "level": 1,
    "question": "How do you define relationships in SwiftData using @Relationship, and how do you configure delete rules?",
    "hint": "Consider how SwiftData infers relationships from property types and when you need to be explicit with @Relationship.",
    "answer": "In SwiftData, relationships are defined by simply declaring properties whose types are other @Model classes. SwiftData automatically infers one-to-one and one-to-many relationships based on whether the property is a single model instance or an array:\n\n@Model\nclass Author {\n    var name: String\n    @Relationship(deleteRule: .cascade, inverse: \\Book.author)\n    var books: [Book]\n}\n\n@Model\nclass Book {\n    var title: String\n    var author: Author?\n}\n\nThe @Relationship macro lets you configure two critical aspects:\n\n1. Delete rules — what happens to related objects when the source is deleted:\n   - .nullify (default): Sets the relationship to nil on related objects. If an Author is deleted, their Books still exist but author becomes nil.\n   - .cascade: Deletes all related objects. Deleting an Author also deletes all their Books.\n   - .deny: Prevents deletion if related objects exist. You cannot delete an Author who still has Books.\n   - .noAction: Does nothing to related objects, which can leave orphaned references.\n\n2. Inverse relationships — the inverse property wrapper tells SwiftData which property on the other side corresponds to this relationship. While SwiftData can often infer inverses automatically when there is only one possible match, you should specify the inverse explicitly when there are multiple relationships between the same types to avoid ambiguity.\n\nFor one-to-many relationships, the \"many\" side uses an array type [Book], while the \"one\" side uses an optional Book? or non-optional Book. SwiftData handles the underlying foreign keys and join tables transparently. Unlike Core Data, there is no need to define relationships in a visual editor — everything is expressed in Swift code."
  },
  {
    "topic": "swiftdata",
    "level": 1,
    "question": "How do SortDescriptor and FetchDescriptor work in SwiftData?",
    "hint": "Think about how FetchDescriptor combines predicates, sorting, and fetch limits into one type-safe object.",
    "answer": "SortDescriptor in SwiftData is a generic, type-safe struct that specifies how to order query results. Unlike Core Data's NSSortDescriptor which uses string key paths, SwiftData's SortDescriptor uses Swift key paths for compile-time safety:\n\nlet sortByDate = SortDescriptor(\\Task.createdAt, order: .reverse)\nlet sortByTitle = SortDescriptor(\\Task.title, comparator: .localizedStandard)\n\nYou can chain multiple SortDescriptors to define primary, secondary, and further sort orders.\n\nFetchDescriptor is a comprehensive type that bundles everything needed for a fetch operation into a single object. It combines:\n\n- predicate: A #Predicate to filter results\n- sortBy: An array of SortDescriptors for ordering\n- fetchLimit: Maximum number of results to return\n- fetchOffset: Number of results to skip (for pagination)\n- includePendingChanges: Whether to include unsaved changes in results\n- propertiesToFetch: Partial fetching for performance (similar to Core Data's propertiesToFetch)\n- relationshipKeyPathsForPrefetching: Eagerly load specified relationships\n\nExample:\n\nvar descriptor = FetchDescriptor<Task>(\n    predicate: #Predicate { $0.isCompleted == false },\n    sortBy: [SortDescriptor(\\.priority, order: .reverse), SortDescriptor(\\.createdAt)]\n)\ndescriptor.fetchLimit = 20\n\nlet tasks = try modelContext.fetch(descriptor)\n\nFetchDescriptor is used with ModelContext.fetch() for programmatic queries, while @Query in SwiftUI views handles fetch descriptors internally. FetchDescriptor also supports fetchCount() to efficiently get the count of matching objects without loading them into memory, and fetchIdentifiers() to get just the PersistentIdentifier values."
  },
  {
    "topic": "swiftdata",
    "level": 2,
    "question": "How do you handle schema migration in SwiftData using VersionedSchema and SchemaMigrationPlan?",
    "hint": "Consider how SwiftData replaces Core Data's mapping models with a code-first migration approach.",
    "answer": "SwiftData provides a structured, code-first migration system through two protocols: VersionedSchema and SchemaMigrationPlan.\n\nVersionedSchema defines a snapshot of your model schema at a specific point in time. Each version is an enum conforming to VersionedSchema:\n\nenum SchemaV1: VersionedSchema {\n    static var versionIdentifier = Schema.Version(1, 0, 0)\n    static var models: [any PersistentModel.Type] { [Task.self] }\n    \n    @Model class Task {\n        var title: String\n        var isCompleted: Bool\n    }\n}\n\nenum SchemaV2: VersionedSchema {\n    static var versionIdentifier = Schema.Version(2, 0, 0)\n    static var models: [any PersistentModel.Type] { [Task.self] }\n    \n    @Model class Task {\n        var title: String\n        var isCompleted: Bool\n        var priority: Int  // new property\n    }\n}\n\nSchemaMigrationPlan defines the ordered sequence of schemas and the migration steps between them:\n\nenum TaskMigrationPlan: SchemaMigrationPlan {\n    static var schemas: [any VersionedSchema.Type] {\n        [SchemaV1.self, SchemaV2.self]\n    }\n    \n    static var stages: [MigrationStage] {\n        [migrateV1toV2]\n    }\n    \n    static let migrateV1toV2 = MigrationStage.custom(\n        fromVersion: SchemaV1.self,\n        toVersion: SchemaV2.self\n    ) { context in\n        let tasks = try context.fetch(FetchDescriptor<SchemaV2.Task>())\n        for task in tasks {\n            task.priority = 0  // default value for existing records\n        }\n        try context.save()\n    }\n}\n\nThere are two types of MigrationStage:\n- .lightweight(fromVersion:toVersion:): For simple changes SwiftData can handle automatically (adding properties with defaults, renaming with @Attribute(originalName:)).\n- .custom(fromVersion:toVersion:willMigrate:didMigrate:): For complex transformations requiring custom logic, with closures that run before or after the schema change.\n\nYou attach the migration plan when creating the container:\n\nlet container = try ModelContainer(\n    for: SchemaV2.Task.self,\n    migrationPlan: TaskMigrationPlan.self\n)\n\nThis approach is entirely code-based, unlike Core Data which uses visual mapping models and XML-based migration configurations."
  },
  {
    "topic": "swiftdata",
    "level": 2,
    "question": "How do you use unique constraints and indexing in SwiftData, and why are they important?",
    "hint": "Think about @Attribute(.unique) and the #Index macro introduced for performance optimization.",
    "answer": "Unique constraints in SwiftData are specified using the @Attribute(.unique) annotation on model properties. This ensures that no two instances of the model can have the same value for that property:\n\n@Model\nclass User {\n    @Attribute(.unique) var email: String\n    var name: String\n    var joinDate: Date\n}\n\nWhen you try to insert a User with an email that already exists, SwiftData performs an upsert by default — it updates the existing record instead of creating a duplicate. This is a significant difference from Core Data, where unique constraints could throw errors or require explicit merge policies.\n\nYou can apply .unique to multiple properties independently, and SwiftData supports compound uniqueness through the #Unique macro on the model itself, though for most cases individual property uniqueness suffices.\n\nIndexing was introduced with the #Index macro to improve query performance on frequently filtered or sorted properties:\n\n@Model\nclass Task {\n    var title: String\n    var priority: Int\n    var createdAt: Date\n    var category: String\n}\n\nYou apply the index at the model level or use @Attribute annotations. Compound indexes can be created for queries that filter on multiple properties together.\n\nIndexes are important because they allow the underlying SQLite database to locate matching rows without scanning the entire table. For a table with thousands of records, an index on a commonly queried property like createdAt or category can reduce query time from O(n) to O(log n).\n\nHowever, indexes come with trade-offs: they consume additional disk space and slightly slow down write operations (inserts, updates, deletes) because the index must be maintained. Therefore, you should only index properties that are frequently used in predicates or sort descriptors, not every property on every model."
  },
  {
    "topic": "swiftdata",
    "level": 2,
    "question": "How does SwiftData integrate with SwiftUI, and what are the key modifiers and property wrappers involved?",
    "hint": "Think about the full chain: .modelContainer modifier, @Environment, @Query, and how they connect.",
    "answer": "SwiftData is designed for deep integration with SwiftUI through a set of modifiers and property wrappers that form a complete data flow:\n\n1. .modelContainer() modifier: Applied to a parent view (usually at the App or WindowGroup level) to inject the persistence stack into the SwiftUI environment:\n\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .modelContainer(for: [Task.self, Tag.self])\n    }\n}\n\nThis creates a ModelContainer and makes its mainContext available to all descendant views. You can also pass a pre-configured container for more control.\n\n2. @Environment(\\.modelContext): Retrieves the ModelContext from the environment for imperative operations:\n\n@Environment(\\.modelContext) private var modelContext\n\nfunc addTask() {\n    let task = Task(title: \"New Task\")\n    modelContext.insert(task)\n}\n\n3. @Query: Declaratively fetches and observes model objects, automatically updating the view:\n\n@Query(filter: #Predicate<Task> { !$0.isCompleted },\n       sort: \\Task.createdAt,\n       order: .reverse)\nvar pendingTasks: [Task]\n\n4. @Bindable: Since @Model classes conform to Observable, you use @Bindable to create two-way bindings to model properties in detail/edit views:\n\nstruct TaskDetailView: View {\n    @Bindable var task: Task\n    var body: some View {\n        TextField(\"Title\", text: $task.title)\n    }\n}\n\n5. Automatic save behavior: By default, SwiftData's mainContext autosaves at appropriate moments (when the app goes to background, on scene phase changes). You can also call modelContext.save() explicitly or disable autosave via ModelContext.autosaveEnabled.\n\nThe Observable conformance generated by @Model means that SwiftUI views automatically track which properties they read and re-render only when those specific properties change. This is more efficient than Core Data's approach with @FetchRequest and NSFetchedResultsController, which relied on notification-based updates."
  },
  {
    "topic": "swiftdata",
    "level": 3,
    "question": "How do you perform background operations in SwiftData, and what are the concurrency considerations?",
    "hint": "Think about ModelActor, the @ModelActor macro, and the rules around passing model objects across actor boundaries.",
    "answer": "SwiftData leverages Swift's structured concurrency model for background operations. Since ModelContext is not Sendable and model objects are tied to a specific context, you cannot simply pass them between actors. SwiftData provides the ModelActor protocol and @ModelActor macro to solve this:\n\n@ModelActor\nactor DataHandler {\n    func importTasks(_ data: [TaskDTO]) throws {\n        for dto in data {\n            let task = Task(title: dto.title, priority: dto.priority)\n            modelContext.insert(task)\n        }\n        try modelContext.save()\n    }\n    \n    func deleteCompleted() throws {\n        let completed = #Predicate<Task> { $0.isCompleted }\n        try modelContext.delete(model: Task.self, where: completed)\n        try modelContext.save()\n    }\n}\n\nThe @ModelActor macro generates an actor that automatically creates its own ModelContext from a shared ModelContainer. The generated initializer takes a ModelContainer parameter:\n\nlet handler = DataHandler(modelContainer: container)\ntry await handler.importTasks(dtos)\n\nKey concurrency rules:\n\n1. Never pass model objects across actor boundaries. Model instances are bound to their ModelContext and are not Sendable. Instead, pass PersistentIdentifier values and re-fetch on the other side:\n\nlet taskID = task.persistentModelID\nawait handler.processTask(id: taskID)\n\n// Inside the actor:\nfunc processTask(id: PersistentIdentifier) throws {\n    guard let task = modelContext.model(for: id) as? Task else { return }\n    // work with task\n}\n\n2. Each ModelActor has its own ModelContext with its own change tracking. Changes saved in a background context are automatically merged into the mainContext because they share the same ModelContainer and underlying store.\n\n3. The mainContext is bound to the @MainActor. All UI operations — inserts, deletes, property changes triggered by user interaction — should happen on the mainContext.\n\n4. For fire-and-forget background work, you can also create a plain ModelContext from the container without the actor pattern, but you must ensure it is only accessed from a single task or serial queue.\n\n5. Autosave is available on background contexts too, but for batch operations it is better to disable it and call save() explicitly after the batch is complete for better performance."
  },
  {
    "topic": "swiftdata",
    "level": 3,
    "question": "How does SwiftData support CloudKit synchronization, and what limitations should you be aware of?",
    "hint": "Consider ModelConfiguration, CKSyncEngine, and the constraints CloudKit imposes on the schema.",
    "answer": "SwiftData supports CloudKit synchronization through ModelConfiguration by specifying a CloudKit container identifier:\n\nlet config = ModelConfiguration(\n    cloudKitDatabase: .private(\"iCloud.com.myapp.container\")\n)\nlet container = try ModelContainer(for: Task.self, configurations: config)\n\nThis enables automatic sync of your SwiftData models to CloudKit's private database using the underlying CKSyncEngine (or NSPersistentCloudKitContainer infrastructure). Changes made locally are pushed to CloudKit, and changes from other devices are pulled and merged automatically.\n\nYou can also specify .public for the public database or .none to disable CloudKit for a specific configuration.\n\nKey limitations and considerations:\n\n1. No unique constraints: CloudKit does not support unique constraints because concurrent devices could create conflicting records. If your model uses @Attribute(.unique), you cannot use it with CloudKit sync. You must remove uniqueness or handle deduplication manually.\n\n2. All relationships must be optional: CloudKit sync requires that relationship properties be optional, because related objects may sync at different times. A Book's author might arrive before the Author object itself.\n\n3. No required (non-optional) properties without defaults: Every property must either be optional or have a default value, since partially synced records need to be representable.\n\n4. Delete rules: .deny delete rules are problematic with CloudKit because the state of related objects may differ across devices due to sync timing.\n\n5. Schema evolution: CloudKit has its own schema management. You can add new fields and new record types, but you cannot delete fields or rename them. This constrains your migration options — additive changes only.\n\n6. Conflict resolution: CloudKit uses last-writer-wins by default. If two devices modify the same record offline and then sync, the most recent change takes precedence. SwiftData does not expose fine-grained merge policies for CloudKit.\n\n7. Performance: Initial sync of large datasets can be slow. CloudKit has rate limits and payload size limits (1MB per record, 10MB for assets).\n\n8. Testing: You need a real iCloud account and network connection to test sync behavior. The CloudKit dashboard in the Apple Developer portal helps inspect synced records.\n\n9. Multiple configurations: You can use multiple ModelConfigurations — one synced to CloudKit and one local-only — to keep sensitive or large data off the cloud while syncing the rest."
  },
  {
    "topic": "swiftdata",
    "level": 3,
    "question": "What is history tracking in SwiftData, and how can it be used to detect and respond to changes?",
    "hint": "Think about the persistent history tracking feature and how it enables responding to changes from other contexts or processes.",
    "answer": "History tracking in SwiftData provides a persistent, ordered log of all changes (inserts, updates, deletes) made to the store across all contexts and processes. This is built on top of Core Data's NSPersistentHistoryTracking and is enabled through the ModelContainer configuration.\n\nHistory tracking is essential for several scenarios:\n\n1. Multi-process coordination: If your app has an app extension (widget, share extension) that writes to the same store, the main app needs to know what changed. History tracking provides a transaction log that the main app can read to merge external changes.\n\n2. Remote change notifications: When combined with CloudKit, persistent history helps process remote changes that arrive via push notifications. The system stores a history of transactions that can be fetched and processed sequentially.\n\n3. Background processing: When a background ModelActor saves changes, the main context can use history tracking to efficiently discover and merge only the new changes rather than re-fetching everything.\n\nTo work with history, you use the ModelContext's transaction history API. You can fetch transactions that occurred after a given token (timestamp marker):\n\nlet transactions = try modelContext.fetchHistory(\n    HistoryDescriptor(after: lastProcessedToken)\n)\n\nfor transaction in transactions {\n    for change in transaction.changes {\n        switch change {\n        case .insert(let model):\n            // handle insertion\n        case .update(let model):\n            // handle update\n        case .delete(let identifier):\n            // handle deletion\n        }\n    }\n}\n\nAfter processing, you save the latest token so subsequent fetches only return new transactions. You should also periodically purge old history to prevent unbounded growth of the history tables, using methods to delete transactions older than a specified date.\n\nHistory tracking adds some overhead to every write operation since each mutation must also be recorded in the history tables. However, this overhead is minimal compared to the benefit of reliable cross-context and cross-process change detection. It eliminates the need for polling or full re-fetches to detect external modifications."
  },
  {
    "topic": "swiftdata",
    "level": 4,
    "question": "How does SwiftData's custom data store feature work, and what are the requirements for implementing one?",
    "hint": "Think about the DataStore protocol introduced to allow non-SQLite backends, and what operations you must implement.",
    "answer": "Starting with iOS 17/macOS 14 and refined further, SwiftData introduced the DataStore protocol that allows you to replace the default SQLite-backed store with a completely custom persistence backend. This means you can back SwiftData models with a JSON file, a remote API, an in-memory store, a different database engine, or any other storage mechanism while keeping the full @Model, @Query, and SwiftUI integration.\n\nTo implement a custom data store, you conform to the DataStore protocol:\n\nfinal class JSONDataStore: DataStore {\n    typealias Configuration = JSONStoreConfiguration\n    typealias Snapshot = DefaultSnapshot\n    \n    var configuration: JSONStoreConfiguration\n    var storeIdentifier: String { configuration.name }\n    \n    init(_ configuration: JSONStoreConfiguration, migrationPlan: (any SchemaMigrationPlan.Type)?) {\n        self.configuration = configuration\n    }\n    \n    func fetch<T>(_ request: DataStoreFetchRequest<T>) throws -> DataStoreFetchResult<T, DefaultSnapshot> {\n        // Read from your JSON file, apply predicates and sorts\n    }\n    \n    func save(_ request: DataStoreSaveRequest) throws -> DataStoreSaveResult {\n        // Write inserts, updates, and deletes to your JSON file\n    }\n}\n\nYou also need a custom configuration type conforming to DataStoreConfiguration:\n\nstruct JSONStoreConfiguration: DataStoreConfiguration {\n    var name: String\n    var schema: Schema?\n    var fileURL: URL\n    \n    static func == (lhs: Self, rhs: Self) -> Bool {\n        lhs.name == rhs.name\n    }\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n    }\n}\n\nKey requirements and considerations:\n\n1. You must implement fetch() to translate FetchDescriptor predicates and sort descriptors into queries against your backend. For non-SQL backends, this may mean evaluating predicates in memory.\n\n2. You must implement save() to process three sets of changes: inserted snapshots, updated snapshots, and deleted persistent identifiers.\n\n3. Snapshot management: You work with DefaultSnapshot or a custom Snapshot type that captures the state of model objects. The snapshot is a serializable representation of the model's property values.\n\n4. Identifier management: You must generate and manage PersistentIdentifier values for your objects, ensuring they remain stable across app launches.\n\n5. History tracking: If you want to support history, you implement the optional history-related methods on DataStore.\n\n6. Migration: Your custom store can integrate with VersionedSchema and SchemaMigrationPlan, or handle migration internally.\n\nThis feature is powerful for testing (in-memory stores), prototyping (JSON file stores), or integrating with existing backends (REST APIs, Realm, or other databases), while maintaining compatibility with the full SwiftData and SwiftUI ecosystem."
  },
  {
    "topic": "swiftdata",
    "level": 4,
    "question": "What are the key architectural differences between SwiftData and Core Data, and when might you still choose Core Data over SwiftData?",
    "hint": "Consider maturity, advanced features like derived attributes, sectioned fetch requests, abstract entities, and deployment targets.",
    "answer": "SwiftData and Core Data share the same underlying SQLite storage engine, but they differ significantly in architecture and developer experience:\n\nArchitectural differences:\n\n1. Schema definition: Core Data uses a visual .xcdatamodeld editor with XML-based schema definitions. SwiftData uses @Model-annotated Swift classes — the schema is the code itself.\n\n2. Observation: Core Data relies on NSFetchedResultsController (UIKit) or @FetchRequest (SwiftUI) with KVO and NSManagedObjectContextObjectsDidChange notifications. SwiftData uses Swift's Observation framework, making every @Model automatically Observable.\n\n3. Type safety: Core Data uses stringly-typed NSPredicate and NSSortDescriptor. SwiftData uses #Predicate and SortDescriptor with Swift key paths, catching errors at compile time.\n\n4. Concurrency: Core Data requires careful management of perform() and performAndWait() blocks on contexts. SwiftData uses @ModelActor with Swift's structured concurrency, making actor isolation explicit.\n\n5. Code generation: Core Data requires generating NSManagedObject subclasses (manually or with Xcode). SwiftData generates everything via macros at compile time.\n\nReasons to still choose Core Data:\n\n1. Deployment targets: SwiftData requires iOS 17+/macOS 14+. If you support older OS versions, Core Data is your only option.\n\n2. Abstract entities: Core Data supports abstract entities for inheritance hierarchies. SwiftData's support for model inheritance is more limited.\n\n3. Derived attributes: Core Data's derived attributes (e.g., automatically computing a count or normalized value) have no direct SwiftData equivalent.\n\n4. Sectioned results: NSFetchedResultsController supports sectionNameKeyPath for sectioned lists natively. SwiftData's @Query does not provide built-in sectioning — you must group results manually.\n\n5. Batch operations: Core Data's NSBatchInsertRequest, NSBatchUpdateRequest, and NSBatchDeleteRequest bypass the context for high-performance bulk operations. SwiftData added context.delete(model:where:) but batch insert and update are less mature.\n\n6. Multiple persistent stores with different entity mappings: Core Data's NSPersistentStoreCoordinator allows sophisticated multi-store configurations. SwiftData supports multiple configurations but with less granularity.\n\n7. Mature tooling: Core Data has extensive debugging tools (com.apple.CoreData.SQLDebug, Instruments Core Data template), migration assistant, and nearly 20 years of community knowledge.\n\n8. Existing codebase: Migrating a large Core Data app to SwiftData is non-trivial and may not be justified unless you need SwiftData-specific features.\n\nIn practice, new projects targeting iOS 17+ should default to SwiftData for its simpler API and better Swift integration, while existing Core Data projects should migrate incrementally. Both can coexist in the same app since they share the same underlying store format."
  },
  {
    "topic": "swiftdata",
    "level": 4,
    "question": "How do you handle complex predicate composition and dynamic queries in SwiftData?",
    "hint": "Consider how to build predicates conditionally at runtime, combine multiple predicates, and pass dynamic parameters to @Query.",
    "answer": "Complex predicate composition in SwiftData requires several techniques because #Predicate macros are evaluated at compile time, making dynamic composition less straightforward than Core Data's NSCompoundPredicate:\n\n1. Parameterized predicates: You can capture external variables in #Predicate closures:\n\nfunc tasksPredicate(minPriority: Int, showCompleted: Bool) -> Predicate<Task> {\n    return #Predicate<Task> { task in\n        task.priority >= minPriority &&\n        (showCompleted || !task.isCompleted)\n    }\n}\n\n2. Dynamic @Query with init: Since @Query parameters are fixed at declaration, you make them dynamic by passing values through the view's initializer:\n\nstruct TaskListView: View {\n    @Query var tasks: [Task]\n    \n    init(minPriority: Int, showCompleted: Bool) {\n        let predicate = #Predicate<Task> { task in\n            task.priority >= minPriority &&\n            (showCompleted || !task.isCompleted)\n        }\n        _tasks = Query(filter: predicate, sort: \\Task.createdAt)\n    }\n}\n\nThe parent view controls the query by passing different parameters:\n\nTaskListView(minPriority: filterPriority, showCompleted: showAll)\n\nWhen parameters change, SwiftUI creates a new TaskListView identity, which re-initializes the @Query with new filter values.\n\n3. Combining predicates: For composing multiple optional predicates, you can use conditional logic within a single #Predicate:\n\nfunc buildPredicate(searchText: String, category: String?, isUrgent: Bool?) -> Predicate<Task> {\n    return #Predicate<Task> { task in\n        task.title.localizedStandardContains(searchText) &&\n        (category == nil || task.category == category) &&\n        (isUrgent == nil || task.isUrgent == isUrgent)\n    }\n}\n\n4. FetchDescriptor for programmatic queries: When @Query is too rigid, use ModelContext.fetch with FetchDescriptor directly:\n\nvar descriptor = FetchDescriptor<Task>()\ndescriptor.predicate = buildPredicate(searchText: query, category: selectedCategory, isUrgent: nil)\ndescriptor.sortBy = [SortDescriptor(\\.createdAt, order: .reverse)]\ndescriptor.fetchLimit = 50\nlet results = try modelContext.fetch(descriptor)\n\n5. Limitations and workarounds: #Predicate does not support all Swift expressions. Operations like regular expressions, complex string manipulation, or custom function calls cannot be translated to SQL. For these cases, you may need to fetch a broader set and filter in memory, or restructure your data model to support the query pattern natively (e.g., adding a normalized search field).\n\n6. Optional relationship traversal: Predicates can traverse relationships but must handle optionality carefully. You can filter tasks by their project's name: #Predicate<Task> { $0.project?.name == projectName }.\n\nThe general pattern is to encapsulate predicate-building logic in helper functions that return Predicate<T>, then pass those predicates to @Query initializers or FetchDescriptor instances depending on whether the query is declarative or imperative."
  },
  {
    "topic": "swiftdata",
    "level": 5,
    "question": "How would you design a SwiftData architecture for an app that needs offline-first operation with server synchronization, conflict resolution, and efficient incremental sync?",
    "hint": "Consider combining persistent history tracking, background ModelActors, custom merge strategies, and server reconciliation beyond CloudKit's last-writer-wins.",
    "answer": "Designing an offline-first SwiftData architecture with custom server sync requires a multi-layered approach:\n\n1. Local data layer with change tracking:\n\nAdd sync metadata to every model:\n\n@Model\nclass Task {\n    @Attribute(.unique) var serverID: String?\n    var title: String\n    var updatedAt: Date\n    var syncStatus: SyncStatus  // .synced, .pendingUpload, .pendingDeletion, .conflicted\n    var vectorClock: [String: Int]  // device-id: counter for conflict detection\n}\n\nUse an enum or int for syncStatus so SwiftData can persist and query it efficiently.\n\n2. Change journal using persistent history:\n\nEnable history tracking on the ModelContainer. Use SwiftData's history API to maintain a high-water mark (last processed history token). A background sync actor periodically fetches new transactions since the last token:\n\n@ModelActor\nactor SyncEngine {\n    private var lastToken: HistoryToken?\n    \n    func collectPendingChanges() throws -> ChangeSet {\n        let transactions = try modelContext.fetchHistory(\n            HistoryDescriptor(after: lastToken)\n        )\n        var changes = ChangeSet()\n        for transaction in transactions {\n            for change in transaction.changes {\n                changes.record(change)\n            }\n        }\n        lastToken = transactions.last?.token\n        return changes\n    }\n}\n\n3. Sync protocol design:\n\nImplement a pull-then-push strategy:\n- Pull: Request server changes since last sync timestamp. Apply to local store, marking conflicts.\n- Push: Upload locally changed objects (syncStatus == .pendingUpload). On success, update syncStatus to .synced.\n- Delete: Send pending deletions, then remove local tombstones.\n\n4. Conflict resolution with vector clocks:\n\nInstead of CloudKit's last-writer-wins, implement semantic conflict resolution:\n\nfunc resolveConflict(local: Task, remote: TaskDTO) -> Task {\n    // Compare vector clocks\n    if local.vectorClock.dominates(remote.vectorClock) {\n        return local  // local is strictly newer\n    } else if remote.vectorClock.dominates(local.vectorClock) {\n        applyRemote(remote, to: local)\n        return local\n    } else {\n        // True conflict — apply field-level merge\n        return fieldLevelMerge(local: local, remote: remote)\n    }\n}\n\nfunc fieldLevelMerge(local: Task, remote: TaskDTO) -> Task {\n    // Per-field last-writer-wins using field-level timestamps\n    local.title = remote.titleUpdatedAt > local.titleUpdatedAt ? remote.title : local.title\n    local.priority = remote.priorityUpdatedAt > local.priorityUpdatedAt ? remote.priority : local.priority\n    local.syncStatus = .synced\n    return local\n}\n\n5. Efficient incremental sync:\n\nUse cursor-based pagination for the pull phase to handle large datasets without memory pressure:\n\nfunc pullChanges() async throws {\n    var cursor: String? = loadLastSyncCursor()\n    repeat {\n        let response = try await api.fetchChanges(since: cursor, limit: 100)\n        try await processRemoteChanges(response.changes)\n        cursor = response.nextCursor\n        saveLastSyncCursor(cursor)\n    } while cursor != nil\n}\n\n6. Background processing with ModelActor:\n\nAll sync operations run on a dedicated @ModelActor to avoid blocking the UI. Use PersistentIdentifier to pass references between the main context and sync actor. The sync actor's context changes automatically merge to the main context through the shared container.\n\n7. Network-aware scheduling:\n\nUse NWPathMonitor to detect connectivity. Queue changes when offline and trigger sync when the network becomes available. Use BGProcessingTask for periodic background sync.\n\n8. Deduplication on first sync:\n\nWhen a device syncs for the first time with an existing server dataset, use serverID-based matching to prevent duplicates. SwiftData's @Attribute(.unique) on serverID handles upsert behavior automatically.\n\n9. Schema evolution:\n\nCoordinate schema changes between client and server. Use VersionedSchema for local migrations and API versioning for server compatibility. The server should accept both old and new field names during a transition period.\n\nThis architecture gives you full control over conflict resolution, works with any backend (not just CloudKit), handles offline operation gracefully, and scales to large datasets through incremental sync. The trade-off is significantly more code than CloudKit's automatic sync, but the flexibility is necessary for apps with complex business logic around data ownership and merging."
  },
  {
    "topic": "swiftdata",
    "level": 5,
    "question": "How would you implement an efficient full-text search system in a SwiftData app that supports large datasets, search-as-you-type, and relevance ranking?",
    "hint": "Consider the limitations of #Predicate for text search, SQLite FTS, denormalized search indexes, and combining SwiftData with lower-level capabilities.",
    "answer": "SwiftData's #Predicate supports basic string matching with localizedStandardContains, but this translates to SQL LIKE queries that perform full table scans — unsuitable for large datasets or search-as-you-type UX. Building an efficient full-text search requires a layered approach:\n\n1. Denormalized search index model:\n\nCreate a separate @Model that stores pre-processed, searchable text:\n\n@Model\nclass SearchIndex {\n    @Attribute(.unique) var entityID: String\n    var entityType: String\n    var normalizedTitle: String  // lowercased, diacritics removed\n    var normalizedBody: String\n    var searchTokens: String  // space-separated normalized words\n    var relevanceBoost: Double  // manual boost factor\n}\n\nWhen a Task is created or updated, a background actor updates the corresponding SearchIndex entry with normalized text (lowercased, diacritics stripped using String's folding(options:locale:)).\n\n2. Token-based prefix matching:\n\nFor search-as-you-type, split the query into tokens and match each as a prefix:\n\nfunc searchPredicate(query: String) -> Predicate<SearchIndex> {\n    let normalizedQuery = query.folding(options: [.diacriticInsensitive, .caseInsensitive], locale: .current)\n    return #Predicate<SearchIndex> { index in\n        index.searchTokens.localizedStandardContains(normalizedQuery)\n    }\n}\n\nThis works for moderate datasets (tens of thousands of records) with an index on searchTokens.\n\n3. SQLite FTS integration for large datasets:\n\nFor hundreds of thousands of records, you need SQLite's FTS5 engine. Since SwiftData sits on top of SQLite, you can access it through a parallel connection:\n\n@ModelActor\nactor SearchEngine {\n    private var db: OpaquePointer?  // direct SQLite connection\n    \n    init(modelContainer: ModelContainer) {\n        // Open a read-only SQLite connection to the same database file\n        let url = modelContainer.configurations.first?.url\n        sqlite3_open_v2(url?.path, &db, SQLITE_OPEN_READONLY, nil)\n        \n        // Create FTS virtual table if needed (on a writable connection)\n        // CREATE VIRTUAL TABLE search_fts USING fts5(title, body, content=ZTASK, content_rowid=Z_PK)\n    }\n    \n    func search(query: String) throws -> [PersistentIdentifier] {\n        // Execute FTS5 query: SELECT rowid, rank FROM search_fts WHERE search_fts MATCH ?\n        // Map rowids back to PersistentIdentifiers\n    }\n}\n\nFTS5 provides sub-millisecond full-text search with ranking (BM25), prefix queries, phrase matching, and boolean operators. The challenge is maintaining the FTS index in sync with SwiftData changes.\n\n4. Keeping FTS in sync:\n\nUse persistent history tracking to detect SwiftData mutations and update the FTS index:\n\nfunc updateSearchIndex() throws {\n    let transactions = try modelContext.fetchHistory(after: lastToken)\n    for transaction in transactions {\n        for change in transaction.changes {\n            switch change {\n            case .insert(let model), .update(let model):\n                upsertFTSEntry(for: model)\n            case .delete(let id):\n                deleteFTSEntry(for: id)\n            }\n        }\n    }\n}\n\n5. Relevance ranking:\n\nCombine FTS5's BM25 score with custom signals:\n\nstruct SearchResult {\n    let identifier: PersistentIdentifier\n    let ftsScore: Double\n    let recencyScore: Double\n    let boostScore: Double\n    \n    var combinedScore: Double {\n        ftsScore * 0.6 + recencyScore * 0.25 + boostScore * 0.15\n    }\n}\n\nRecency score can be computed from the object's updatedAt timestamp. Boost score can reflect user-defined importance or frequency of access.\n\n6. Search-as-you-type debouncing:\n\nIn the SwiftUI layer, use .task(id:) with debouncing:\n\n@State private var searchText = \"\"\n@State private var searchResults: [Task] = []\n\nvar body: some View {\n    List(searchResults) { task in ... }\n    .searchable(text: $searchText)\n    .task(id: searchText) {\n        try? await Task.sleep(for: .milliseconds(300))\n        guard !Task.isCancelled else { return }\n        let ids = try? await searchEngine.search(query: searchText)\n        if let ids {\n            searchResults = ids.compactMap { modelContext.model(for: $0) as? Task }\n        }\n    }\n}\n\nThe .task(id:) modifier cancels the previous task when searchText changes, providing natural debouncing.\n\n7. Memory management:\n\nFor large result sets, use fetchLimit and fetchOffset on the SwiftData side. Only resolve PersistentIdentifiers into full model objects for visible rows. This lazy loading pattern prevents memory spikes when a search matches thousands of records.\n\n8. Testing strategy:\n\nUse an in-memory ModelContainer for unit tests. For FTS integration tests, create a temporary on-disk store and verify that search results match expected rankings. Test with realistic data volumes to catch performance regressions.\n\nThis architecture provides sub-100ms search on datasets with hundreds of thousands of records, gracefully degrades with the simpler #Predicate approach for smaller datasets, and integrates cleanly with SwiftData's model lifecycle and SwiftUI's reactive patterns."
  },
  {
    "topic": "swiftdata",
    "level": 5,
    "question": "How would you architect a SwiftData-based app for testability, including unit testing models, integration testing persistence, and mocking the data layer?",
    "hint": "Consider in-memory containers, protocol abstractions over ModelContext, dependency injection of data services, and testing @Query-driven views.",
    "answer": "Building a testable SwiftData architecture requires careful abstraction at multiple levels:\n\n1. Protocol-based data service layer:\n\nNever let views or view models interact with ModelContext directly. Define protocols that abstract persistence operations:\n\nprotocol TaskRepository {\n    func fetchAll(sortedBy: SortDescriptor<Task>) throws -> [Task]\n    func fetch(matching: Predicate<Task>) throws -> [Task]\n    func add(_ task: Task) throws\n    func delete(_ task: Task) throws\n    func save() throws\n}\n\nclass SwiftDataTaskRepository: TaskRepository {\n    private let modelContext: ModelContext\n    \n    init(modelContext: ModelContext) {\n        self.modelContext = modelContext\n    }\n    \n    func fetchAll(sortedBy sort: SortDescriptor<Task>) throws -> [Task] {\n        let descriptor = FetchDescriptor<Task>(sortBy: [sort])\n        return try modelContext.fetch(descriptor)\n    }\n    \n    func add(_ task: Task) throws {\n        modelContext.insert(task)\n        try modelContext.save()\n    }\n    // ...\n}\n\n2. In-memory ModelContainer for tests:\n\nSwiftData's ModelConfiguration supports isStoredInMemoryOnly, which creates an ephemeral store perfect for testing:\n\nclass TaskRepositoryTests: XCTestCase {\n    var container: ModelContainer!\n    var context: ModelContext!\n    var sut: SwiftDataTaskRepository!\n    \n    override func setUp() {\n        let config = ModelConfiguration(isStoredInMemoryOnly: true)\n        container = try! ModelContainer(for: Task.self, configurations: config)\n        context = ModelContext(container)\n        context.autosaveEnabled = false\n        sut = SwiftDataTaskRepository(modelContext: context)\n    }\n    \n    func testAddTask() throws {\n        let task = Task(title: \"Test\", priority: 1)\n        try sut.add(task)\n        \n        let fetched = try sut.fetchAll(sortedBy: SortDescriptor(\\.createdAt))\n        XCTAssertEqual(fetched.count, 1)\n        XCTAssertEqual(fetched.first?.title, \"Test\")\n    }\n    \n    func testDeleteTask() throws {\n        let task = Task(title: \"To Delete\", priority: 0)\n        try sut.add(task)\n        try sut.delete(task)\n        \n        let fetched = try sut.fetchAll(sortedBy: SortDescriptor(\\.createdAt))\n        XCTAssertTrue(fetched.isEmpty)\n    }\n}\n\n3. Mock repository for view model tests:\n\nclass MockTaskRepository: TaskRepository {\n    var tasks: [Task] = []\n    var addCallCount = 0\n    var deleteCallCount = 0\n    var shouldThrowOnSave = false\n    \n    func fetchAll(sortedBy: SortDescriptor<Task>) throws -> [Task] {\n        return tasks\n    }\n    \n    func add(_ task: Task) throws {\n        addCallCount += 1\n        tasks.append(task)\n        if shouldThrowOnSave { throw TestError.saveFailed }\n    }\n    \n    func delete(_ task: Task) throws {\n        deleteCallCount += 1\n        tasks.removeAll { $0.title == task.title }\n    }\n    \n    func save() throws {\n        if shouldThrowOnSave { throw TestError.saveFailed }\n    }\n}\n\nThis lets you test view model logic without any persistence:\n\nfunc testViewModelAddsTask() async {\n    let mockRepo = MockTaskRepository()\n    let viewModel = TaskListViewModel(repository: mockRepo)\n    \n    await viewModel.addTask(title: \"New Task\")\n    \n    XCTAssertEqual(mockRepo.addCallCount, 1)\n    XCTAssertEqual(mockRepo.tasks.first?.title, \"New Task\")\n}\n\n4. Testing @Query-driven views:\n\n@Query views are harder to unit test because the property wrapper requires a SwiftUI environment with a model container. Use ViewInspector or write integration-style tests:\n\nfunc testTaskListViewDisplaysTasks() {\n    let config = ModelConfiguration(isStoredInMemoryOnly: true)\n    let container = try! ModelContainer(for: Task.self, configurations: config)\n    let context = container.mainContext\n    \n    context.insert(Task(title: \"Task 1\", priority: 1))\n    context.insert(Task(title: \"Task 2\", priority: 2))\n    try! context.save()\n    \n    let view = TaskListView()\n        .modelContainer(container)\n    \n    // Use ViewInspector or snapshot testing to verify\n}\n\nAlternatively, separate the list rendering from the data fetching. Have a pure view that takes [Task] as a parameter and a container view that uses @Query:\n\n// Pure view — easy to test and preview\nstruct TaskListContent: View {\n    let tasks: [Task]\n    var body: some View {\n        ForEach(tasks) { TaskRow(task: $0) }\n    }\n}\n\n// Data-connected view — thin wrapper\nstruct TaskListView: View {\n    @Query(sort: \\Task.createdAt) var tasks: [Task]\n    var body: some View {\n        TaskListContent(tasks: tasks)\n    }\n}\n\n5. Testing migrations:\n\nfunc testV1toV2Migration() throws {\n    // Create a V1 store with test data\n    let url = FileManager.default.temporaryDirectory.appending(path: UUID().uuidString + \".store\")\n    let v1Config = ModelConfiguration(url: url)\n    let v1Container = try ModelContainer(for: SchemaV1.Task.self, configurations: v1Config)\n    let v1Context = ModelContext(v1Container)\n    v1Context.insert(SchemaV1.Task(title: \"Old Task\"))\n    try v1Context.save()\n    \n    // Reopen with V2 schema and migration plan\n    let v2Container = try ModelContainer(\n        for: SchemaV2.Task.self,\n        migrationPlan: TaskMigrationPlan.self,\n        configurations: ModelConfiguration(url: url)\n    )\n    let v2Context = ModelContext(v2Container)\n    let tasks = try v2Context.fetch(FetchDescriptor<SchemaV2.Task>())\n    \n    XCTAssertEqual(tasks.first?.priority, 0)  // default from migration\n    try FileManager.default.removeItem(at: url)\n}\n\n6. Testing ModelActor background operations:\n\nfunc testBackgroundImport() async throws {\n    let config = ModelConfiguration(isStoredInMemoryOnly: true)\n    let container = try ModelContainer(for: Task.self, configurations: config)\n    let handler = DataHandler(modelContainer: container)\n    \n    let dtos = (0..<100).map { TaskDTO(title: \"Task \\($0)\", priority: $0 % 5) }\n    try await handler.importTasks(dtos)\n    \n    let context = ModelContext(container)\n    let count = try context.fetchCount(FetchDescriptor<Task>())\n    XCTAssertEqual(count, 100)\n}\n\n7. Dependency injection strategy:\n\nUse a DI container or environment-based injection so the data layer can be swapped in tests:\n\n@MainActor\nclass AppDependencies: ObservableObject {\n    let taskRepository: TaskRepository\n    \n    init(taskRepository: TaskRepository) {\n        self.taskRepository = taskRepository\n    }\n    \n    static func live(container: ModelContainer) -> AppDependencies {\n        AppDependencies(taskRepository: SwiftDataTaskRepository(modelContext: container.mainContext))\n    }\n    \n    static func mock() -> AppDependencies {\n        AppDependencies(taskRepository: MockTaskRepository())\n    }\n}\n\nThis architecture ensures that business logic is fully testable without persistence, integration tests verify actual SwiftData behavior with in-memory stores, migration tests catch schema evolution issues before release, and UI tests can use pre-populated containers. The key principle is that SwiftData is an implementation detail hidden behind protocols — the rest of the app never knows or cares whether data comes from SQLite, memory, or a mock."
  },
  {
    "topic": "coredata",
    "level": 0,
    "question": "What is NSPersistentContainer and what role does it play in a Core Data stack?",
    "hint": "Think about what components you need to set up before you can read or write data with Core Data.",
    "answer": "NSPersistentContainer is a convenience class introduced in iOS 10 that encapsulates the entire Core Data stack. It bundles together three key components: the NSManagedObjectModel (which describes your entities and their relationships), the NSPersistentStoreCoordinator (which mediates between the model and the actual storage on disk), and at least one NSManagedObjectContext (exposed via its viewContext property for main-queue work).\n\nBefore NSPersistentContainer existed, developers had to manually create and wire up each of these objects. Now you simply initialize it with your data model name, call loadPersistentStores(completionHandler:), and you have a fully configured stack. The container also provides a performBackgroundTask(_:) method that creates a private-queue context for background work, and a newBackgroundContext() method for reusable background contexts. This dramatically reduces boilerplate and is the recommended way to bootstrap Core Data in modern apps."
  },
  {
    "topic": "coredata",
    "level": 0,
    "question": "What is an NSManagedObject, and how do you typically create and use one?",
    "hint": "Consider how Core Data represents rows from a database as objects in memory.",
    "answer": "NSManagedObject is the base class for all Core Data model objects. Each instance represents a single record (row) in a persistent store and is associated with an NSEntityDescription that defines its attributes and relationships. Unlike plain Swift classes, NSManagedObject properties are backed by a key-value coding mechanism rather than normal instance variables, which enables features like faulting, change tracking, and undo support.\n\nYou create a new NSManagedObject by calling its designated initializer init(context:) or by using the convenience method on NSEntityDescription. Modern Core Data projects typically use Xcode-generated NSManagedObject subclasses with @NSManaged properties, which provide type-safe accessors. For example, if you have a Person entity with a name attribute, Xcode generates a Person class with an @NSManaged var name: String? property.\n\nKey behaviors include: the object is automatically registered with its context upon creation, all changes are tracked by that context, and changes are not persisted until you call context.save(). You can also access its objectID (a unique, persistent identifier) and its entity description at runtime."
  },
  {
    "topic": "coredata",
    "level": 0,
    "question": "What is NSFetchRequest and how do you use it to retrieve data from Core Data?",
    "hint": "Think about how you query a database — you need to specify what entity you want and optionally filter or sort the results.",
    "answer": "NSFetchRequest is the object that describes a query against a Core Data persistent store. At minimum, you must set its entity (or use the convenience initializer NSFetchRequest<T>(entityName:)) to specify which entity type you want to fetch. You then execute it against an NSManagedObjectContext using context.fetch(_:).\n\nKey properties you can configure include:\n- predicate: An NSPredicate that filters which objects are returned (e.g., NSPredicate(format: \"age > %d\", 18)).\n- sortDescriptors: An array of NSSortDescriptor objects that determine the order of results.\n- fetchLimit: Caps the maximum number of results returned.\n- fetchOffset: Skips a number of results, useful for pagination.\n- fetchBatchSize: Controls how many objects are fully materialized at once, which is critical for memory efficiency with large result sets.\n- resultType: Can be set to return managed objects (default), object IDs only, dictionaries, or just a count.\n- propertiesToFetch: When using dictionary result type, limits which attributes are loaded.\n\nA typical usage looks like: create the request, set a predicate and sort descriptors, then call try context.fetch(request). The returned array contains NSManagedObject instances (or subclasses) that match your criteria."
  },
  {
    "topic": "coredata",
    "level": 1,
    "question": "Explain Core Data relationships and the four delete rules. When would you use each?",
    "hint": "Consider what should happen to related objects when you delete a parent — should children be deleted, orphaned, or should the deletion be blocked?",
    "answer": "Core Data relationships connect entities to each other and can be to-one or to-many. Best practice is to always define an inverse relationship so Core Data can maintain referential integrity.\n\nThe four delete rules control what happens to related objects when the source object is deleted:\n\n1. Cascade: Deleting the source automatically deletes all related objects. Use this for strong ownership — for example, deleting an Album cascades to delete all its Photos, because photos have no meaning without their album.\n\n2. Nullify: Deleting the source sets the relationship on related objects to nil. This is the most common rule. For example, deleting a Department nullifies the department property on all its Employees, leaving employees intact but unassigned.\n\n3. Deny: The source object cannot be deleted as long as it has related objects. The delete operation will fail with a validation error. Use this to enforce constraints — for example, prevent deleting a Team if it still has Members. You must remove all members first.\n\n4. No Action: Core Data does nothing to related objects. The related objects will still reference the deleted object's ID, which can lead to dangling references and crashes if accessed. This is rarely appropriate and is mainly used when you manage consistency manually.\n\nChoosing the right delete rule depends on the ownership semantics of the relationship. Cascade for parent-child ownership, Nullify for loose associations, Deny for required dependencies, and No Action only when you have a specific reason to manage cleanup yourself."
  },
  {
    "topic": "coredata",
    "level": 1,
    "question": "What is NSPredicate in the context of Core Data, and what are some common predicate patterns?",
    "hint": "Think of NSPredicate as the WHERE clause of a SQL query, but expressed in a more object-oriented syntax.",
    "answer": "NSPredicate is a Foundation class used to define logical conditions for filtering objects. In Core Data, you assign a predicate to an NSFetchRequest to limit which managed objects are returned from the persistent store.\n\nCommon predicate patterns include:\n\n- Simple comparison: NSPredicate(format: \"age >= %d\", 21) — filters on a numeric attribute.\n- String matching: NSPredicate(format: \"name CONTAINS[cd] %@\", searchText) — the [cd] modifier makes it case-insensitive and diacritic-insensitive.\n- Relationship traversal: NSPredicate(format: \"department.name == %@\", \"Engineering\") — uses key paths to filter through relationships.\n- Collection operators: NSPredicate(format: \"ANY tasks.isCompleted == YES\") — checks if at least one related object matches.\n- IN operator: NSPredicate(format: \"status IN %@\", [\"active\", \"pending\"]) — matches against a set of values.\n- BETWEEN: NSPredicate(format: \"date BETWEEN %@\", [startDate, endDate]).\n- Compound predicates: You can combine predicates with NSCompoundPredicate using AND, OR, NOT operations, or use format strings like \"age > 18 AND name BEGINSWITH 'A'\".\n- SUBQUERY: For complex relationship queries — SUBQUERY(tasks, $task, $task.priority > 5).@count > 0.\n\nPerformance considerations: predicates that can be translated to SQL (most simple comparisons and string operations) execute in the SQLite store directly, while block-based predicates (NSPredicate(block:)) require all objects to be fetched into memory first, making them unsuitable for Core Data fetch requests against SQLite stores."
  },
  {
    "topic": "coredata",
    "level": 1,
    "question": "What is NSFetchedResultsController and why is it commonly used with UITableView or UICollectionView?",
    "hint": "Think about what happens when your underlying data changes — how do you keep a table view in sync with the data store efficiently?",
    "answer": "NSFetchedResultsController is a controller object that efficiently bridges Core Data fetch results with UIKit table views or collection views. You initialize it with an NSFetchRequest (which must have at least one sort descriptor), an NSManagedObjectContext, a sectionNameKeyPath (optional, for grouping into sections), and a cache name (optional, for performance).\n\nIts primary benefits are:\n\n1. Efficient data bridging: It performs the initial fetch and provides results organized into sections and rows via fetchedObjects, sections, and object(at:) methods. This maps directly to UITableViewDataSource requirements like numberOfSections, numberOfRowsInSection, and cellForRowAt.\n\n2. Automatic change tracking: By conforming to NSFetchedResultsControllerDelegate, you receive callbacks when objects are inserted, deleted, updated, or moved. The delegate methods (controller(_:didChange:at:for:newIndexPath:)) provide exactly the information needed to call tableView.insertRows, deleteRows, and moveRow, enabling animated, incremental UI updates without reloading the entire table.\n\n3. Memory efficiency: It respects the fetchBatchSize of the underlying fetch request, so it does not load all objects into memory at once.\n\n4. Section support: The sectionNameKeyPath groups results into sections automatically and provides section index titles for quick navigation.\n\nIn SwiftUI, NSFetchedResultsController is less commonly used directly because the @FetchRequest property wrapper provides similar functionality. However, for complex use cases or when sharing logic with UIKit, it remains valuable. It only works with a main-queue context (viewContext) since UI updates must happen on the main thread."
  },
  {
    "topic": "coredata",
    "level": 2,
    "question": "Explain the difference between lightweight and heavyweight migration in Core Data. When can you use lightweight migration?",
    "hint": "Consider what happens when you change your data model between app versions — adding an attribute is simple, but renaming an entity or transforming data requires more work.",
    "answer": "When you modify your Core Data model (the .xcdatamodeld file) between app versions, the persistent store on disk may no longer match the new model. Migration is the process of updating the store to match the new schema.\n\nLightweight migration (also called automatic migration) is handled entirely by Core Data with no custom code. You enable it by setting shouldInferMappingModelAutomatically and shouldMigrateStoreAutomatically to true on NSPersistentStoreDescription (or in the options dictionary). Core Data can infer the mapping for these changes:\n- Adding or removing entities\n- Adding or removing attributes (new attributes must be optional or have a default value)\n- Making an attribute optional or non-optional\n- Renaming entities or attributes (you must set the Renaming Identifier in the new model to the old name)\n- Adding or removing relationships\n- Changing a to-one relationship to to-many (or vice versa)\n- Changing relationship delete rules\n- Adding or removing indexes\n\nHeavyweight migration (also called custom or manual migration) is required when changes cannot be automatically inferred. This includes:\n- Splitting an entity into two entities\n- Merging two entities into one\n- Transforming attribute data (e.g., splitting a fullName attribute into firstName and lastName)\n- Migrating data across relationships in complex ways\n\nFor heavyweight migration, you create an NSMappingModel (either in Xcode's mapping model editor or programmatically) with NSEntityMapping and NSPropertyMapping objects. You can also write custom NSEntityMigrationPolicy subclasses that implement createDestinationInstances(forSource:in:manager:) to perform arbitrary data transformations during migration.\n\nBest practice is to design model changes to stay within lightweight migration boundaries whenever possible, as heavyweight migrations are complex, error-prone, and can be very slow on large data sets. For very large stores, consider progressive or staged migration approaches."
  },
  {
    "topic": "coredata",
    "level": 2,
    "question": "How does Core Data context concurrency work? Explain the perform(_:) and performAndWait(_:) methods and when to use each.",
    "hint": "Think about thread safety — each context is tied to a specific queue, and you must ensure all access happens on that queue.",
    "answer": "Every NSManagedObjectContext is associated with a concurrency type specified at initialization: .mainQueueConcurrencyType (bound to the main thread) or .privateQueueConcurrencyType (bound to a private background queue). The golden rule is that you must never access a context or its managed objects from a thread other than the one the context is bound to.\n\nTo enforce this safely, NSManagedObjectContext provides two methods:\n\n1. perform(_:): Asynchronously dispatches a closure onto the context's queue. The closure executes at some future point. Use this when you want to do background work without blocking the calling thread — for example, saving changes on a background context without freezing the UI.\n\n2. performAndWait(_:): Synchronously dispatches a closure onto the context's queue and blocks the calling thread until it completes. Use this when you need the result immediately — for example, fetching objects and returning them to the caller. Note that performAndWait is reentrant (safe to nest calls), while perform is not.\n\nPractical guidelines:\n- The viewContext from NSPersistentContainer is a main-queue context. You can access it directly from the main thread, but should use perform/performAndWait if called from an uncertain context.\n- Background contexts created via newBackgroundContext() or performBackgroundTask(_:) are private-queue contexts. Always wrap their usage in perform or performAndWait.\n- Never pass NSManagedObject instances between contexts or threads. Instead, pass the objectID and re-fetch using context.object(with:) on the target context.\n- In Swift 5.5+, you can combine async/await with perform by using the async variant: context.perform { ... } which returns the result asynchronously.\n\nViolating these concurrency rules leads to hard-to-debug crashes, data corruption, or undefined behavior. Enable -com.apple.CoreData.ConcurrencyDebug 1 launch argument during development to catch violations."
  },
  {
    "topic": "coredata",
    "level": 2,
    "question": "What are parent-child managed object contexts? Explain how they work and a practical use case.",
    "hint": "Consider a scenario where you want to make a set of changes that you can either commit or discard entirely — like an editing screen with a Cancel button.",
    "answer": "Parent-child contexts are a Core Data pattern where one NSManagedObjectContext (the child) is set as a child of another context (the parent) via the parent property. When a child context saves, its changes are pushed up to the parent context — not directly to the persistent store. The parent context must then save separately to persist changes to disk.\n\nHow the flow works:\n1. Create a child context with .privateQueueConcurrencyType (or .mainQueueConcurrencyType).\n2. Set childContext.parent = parentContext.\n3. Perform edits in the child context.\n4. Call childContext.save() — this pushes changes into the parent's in-memory state.\n5. Call parentContext.save() — this actually writes to the persistent store.\n\nIf you skip step 5 or discard the child context, the changes are lost — the persistent store is untouched.\n\nPractical use cases:\n\n1. Edit-and-cancel workflows: Present an editing form backed by a child context. If the user taps Save, save the child context then the parent. If the user taps Cancel, simply discard the child context — no changes leak into the parent.\n\n2. Background processing: Create a private-queue child context for background imports. Changes are pushed to the main-queue parent when the child saves, keeping the UI context up to date without merge notifications.\n\n3. Nested undo grouping: Each child context provides an isolated scope for changes that can be committed or rolled back independently.\n\nImportant caveats:\n- Child contexts do not see changes made in the parent after the child was created unless you call child.refreshAllObjects() or re-fetch.\n- Objects created in a child context have temporary objectIDs until the parent saves to the store. If you need permanent IDs earlier, call obtainPermanentIDs(for:).\n- Deeply nested context chains (grandchild contexts) are possible but add complexity and performance overhead. In most cases, one level of nesting is sufficient."
  },
  {
    "topic": "coredata",
    "level": 3,
    "question": "What are merge policies in Core Data? Describe the built-in policies and when you would choose each.",
    "hint": "Think about what happens when two contexts modify the same object and both try to save — whose changes win?",
    "answer": "Merge policies (NSMergePolicy) determine how Core Data resolves conflicts when saving a context whose changes clash with changes already in the persistent store. A conflict occurs when the same managed object has been modified in both the context being saved and the store (typically because another context saved first).\n\nThe built-in policies are:\n\n1. NSErrorMergePolicy (default): The save fails with an NSError containing the conflicting objects. No automatic resolution occurs. Use this when you want full control over conflict resolution and are willing to handle errors manually. It is the safest option but requires the most code.\n\n2. NSMergeByPropertyStoreTrumpMergePolicy: For each conflicting property, the store's (persisted) value wins. Unchanged properties in the context are preserved. Use this when external data (like a server sync) takes precedence and you want the latest persisted version to dominate.\n\n3. NSMergeByPropertyObjectTrumpMergePolicy: For each conflicting property, the in-memory context's value wins. Properties that the context did not modify retain the store's values. This is the most commonly used policy — it allows the current user's edits to take precedence while preserving other changes.\n\n4. NSOverwriteMergePolicy: The context's version completely overwrites the store's version for all properties, even those the context did not modify. Use this sparingly — it can obliterate concurrent changes. It might be appropriate for full-object replacement scenarios like a clean server sync overwrite.\n\n5. NSRollbackMergePolicy: The store's version completely overwrites the context's version. All in-memory changes are discarded. Use this when you always want the persisted state to be authoritative.\n\nPractical guidance:\n- Set the merge policy on each context: context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy.\n- For apps with NSPersistentCloudKitContainer (CloudKit sync), Apple recommends NSMergeByPropertyObjectTrumpMergePolicy to handle sync conflicts gracefully.\n- You can also create custom merge policies by subclassing NSMergePolicy and overriding resolve(mergeConflicts:), but this is rarely necessary.\n- Always pair merge policies with listening for NSManagedObjectContextDidSave notifications and calling mergeChanges(fromContextDidSave:) to keep contexts in sync."
  },
  {
    "topic": "coredata",
    "level": 3,
    "question": "Explain batch operations in Core Data (NSBatchInsertRequest, NSBatchUpdateRequest, NSBatchDeleteRequest). How do they differ from normal operations?",
    "hint": "Think about what happens when you need to insert 100,000 objects — doing it one by one through a managed object context would be extremely slow.",
    "answer": "Batch operations execute directly against the persistent store (SQLite) without loading objects into memory or going through the managed object context. This makes them dramatically faster and more memory-efficient for large-scale operations.\n\nNSBatchInsertRequest (iOS 13+): Inserts large numbers of objects directly into the store. You provide data via a dictionary array or a closure-based handler (dictionaryHandler or managedObjectHandler) that is called repeatedly until you signal completion. This is ideal for importing large JSON datasets from a server.\n\nNSBatchUpdateRequest (iOS 8+): Updates attributes on many objects without fetching them. You specify the entity, a predicate to filter which objects to update, and propertiesToUpdate as a dictionary mapping attribute names to new values. For example, marking all messages as read: set a predicate for isRead == false and propertiesToUpdate = [\"isRead\": true].\n\nNSBatchDeleteRequest (iOS 9+): Deletes objects matching a fetch request without loading them into memory. You create it from an NSFetchRequest and execute it. Useful for purging old data or clearing caches.\n\nCritical differences from normal operations:\n1. No validation: Managed object validation rules are not enforced.\n2. No change tracking: The context is unaware of the changes, so in-memory objects may be stale.\n3. No cascade: Relationship delete rules (like Cascade) are NOT triggered by NSBatchDeleteRequest.\n4. No notifications: willSave/didSave and NSManagedObjectContextDidSave notifications are not posted.\n5. No merge: Other contexts are not automatically updated.\n\nTo synchronize after a batch operation, you should:\n1. Set resultType to .resultTypeObjectIDs on the batch request.\n2. Extract the changed object IDs from the result.\n3. Call NSManagedObjectContext.mergeChanges(fromRemoteContextSave:into:) with those IDs to update your view context.\n\nExample pattern:\nlet result = try context.execute(batchDeleteRequest) as? NSBatchDeleteResult\nlet objectIDs = result?.result as? [NSManagedObjectID] ?? []\nNSManagedObjectContext.mergeChanges(fromRemoteContextSave: [NSDeletedObjectsKey: objectIDs], into: [viewContext])"
  },
  {
    "topic": "coredata",
    "level": 3,
    "question": "What is faulting in Core Data, and how does prefetching (relationshipKeyPathsForPrefetching) help with performance?",
    "hint": "Think about lazy loading — Core Data does not load all data into memory at once. What happens when you access a property on a fault?",
    "answer": "Faulting is Core Data's mechanism for lazy loading. When you fetch objects, Core Data may return fault objects — lightweight placeholders that know the object's ID and entity but have not loaded their attribute data from the store. When you first access a property on a fault, Core Data transparently fires the fault by executing a store read to load the actual data. This conserves memory because only objects whose data is actually accessed get fully materialized.\n\nThere are two types of faults:\n1. Managed object faults: The object exists in the context but its attributes are not loaded. Accessing any attribute fires the fault and loads all attributes for that object.\n2. Relationship faults: A to-one relationship returns a fault object for the related entity. A to-many relationship returns a fault collection that fires when enumerated. Each related object may itself be a fault.\n\nThe problem with faulting — N+1 queries: If you fetch 100 Employee objects and then access employee.department.name for each one, Core Data fires 100 individual faults for the Department relationship. This is extremely slow due to the per-fault round trip to the store.\n\nPrefetching solves this. On your NSFetchRequest, set relationshipKeyPathsForPrefetching to an array of relationship key paths:\nrequest.relationshipKeyPathsForPrefetching = [\"department\", \"department.company\"]\n\nThis tells Core Data to batch-load the related objects in a single efficient query during the initial fetch, preventing individual fault firing later.\n\nAdditional performance tools:\n- fetchBatchSize: Controls how many objects are fully faulted at a time when iterating results. Setting this to 20-50 is common for table views.\n- returnsObjectsAsFaults: Set to false to prevent the fetched objects themselves from being faults (they will be fully materialized immediately). Useful when you know you will access every object's data.\n- refreshObject(_:mergeChanges:): Manually turns an object back into a fault to reclaim memory, passing false discards unsaved changes.\n- context.refreshAllObjects(): Re-faults all registered objects in the context.\n\nFaulting is generally beneficial, but understanding it is critical for diagnosing performance issues. Use Instruments' Core Data template to detect excessive fault firing."
  },
  {
    "topic": "coredata",
    "level": 4,
    "question": "How does NSPersistentCloudKitContainer work for syncing Core Data with CloudKit? What are its limitations and best practices?",
    "hint": "Think about how local changes need to be mirrored to a cloud database that other devices can access, and the constraints CloudKit imposes.",
    "answer": "NSPersistentCloudKitContainer is a subclass of NSPersistentContainer that automatically mirrors a Core Data store to a CloudKit private or shared database. Introduced in iOS 13, it handles sync transparently — local changes are pushed to CloudKit, and remote changes are pulled and merged into the local store.\n\nHow it works:\n1. You configure an NSPersistentStoreDescription with cloudKitContainerOptions pointing to your CloudKit container identifier.\n2. The container sets up a CKDatabaseSubscription and uses push notifications (silent) to detect remote changes.\n3. Local saves trigger an export operation that creates CKRecord objects from your managed objects and uploads them.\n4. Remote changes are imported, and the container posts NSPersistentStoreRemoteChange notifications so your app can react.\n\nSetup requirements:\n- Enable CloudKit capability and Background Modes (remote notifications) in your target.\n- Each entity maps to a CKRecord type. Attributes map to CKRecord fields.\n- All attributes must be optional (or have default values) because CloudKit records may arrive partially.\n- Enable persistent history tracking on the store description (this is set automatically).\n\nLimitations:\n- Unique constraints are not supported — CloudKit has no concept of unique keys, so duplicate records can occur.\n- Cascade delete rules may not propagate reliably across devices with timing differences.\n- Deny delete rules are local-only and may not prevent deletion on another device.\n- CloudKit has record size limits (1 MB per record, assets up to 250 MB).\n- Initial sync of large datasets can be slow and is not transactional.\n- Only supports SQLite stores, not in-memory or binary.\n- Ordered relationships are not supported.\n\nBest practices:\n- Set mergePolicy to NSMergeByPropertyObjectTrumpMergePolicy on the viewContext.\n- Set viewContext.automaticallyMergesChangesFromParent = true.\n- Listen for NSPersistentStoreRemoteChange notifications to refresh UI.\n- Use initializeCloudKitSchema(options:) during development to create the CloudKit schema.\n- Design your model to tolerate eventual consistency — objects may arrive out of order.\n- For shared databases (iOS 15+), use CKShare integration via NSPersistentCloudKitContainer.share(_:to:completion:).\n- Test extensively with multiple devices and slow/offline network conditions."
  },
  {
    "topic": "coredata",
    "level": 4,
    "question": "What is persistent history tracking in Core Data, and how do you use it to keep multiple targets (app, extensions, widgets) in sync?",
    "hint": "Consider an app with a share extension and a widget — all three processes write to the same Core Data store. How does each one know what the others changed?",
    "answer": "Persistent history tracking (NSPersistentHistoryTracking) is a Core Data feature that records a sequential log of all transactions (inserts, updates, deletes) made to a persistent store. Each transaction gets a unique token, and any consumer can query the history from a given token forward to discover what changed since it last checked.\n\nEnabling it:\nSet the NSPersistentHistoryTrackingKey option to true on your NSPersistentStoreDescription:\ndescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)\nAlso enable NSPersistentStoreRemoteChangeNotificationPostOptionKey to receive notifications when another process modifies the store.\n\nThe workflow for multi-target sync:\n1. Each target (app, extension, widget) stores its last processed NSPersistentHistoryToken, typically in UserDefaults with an app group suite.\n2. When a target receives an NSPersistentStoreRemoteChange notification (or at launch), it creates an NSPersistentHistoryChangeRequest.fetchHistory(after: lastToken).\n3. Execute this request against the context to get an NSPersistentHistoryResult containing an array of NSPersistentHistoryTransaction objects.\n4. Each transaction contains an array of NSPersistentHistoryChange objects describing individual object changes (insert/update/delete) with the entity name, objectID, and updated properties.\n5. Merge these changes into your view context using mergeChanges(fromContextDidSave:) with the transaction's objectIDNotification().\n6. Update the stored token to the last processed transaction's token.\n7. Periodically purge old history that all targets have processed using NSPersistentHistoryChangeRequest.deleteHistory(before: oldestToken).\n\nKey considerations:\n- All targets must use the same app group container for the store file.\n- Each target should use a unique transaction author (context.transactionAuthor = \"app\" or \"widget\") so it can filter out its own transactions.\n- History purging is important — without it, the history log grows unbounded and wastes disk space.\n- To purge safely, track the last processed token for each target and only purge history older than the oldest token across all targets.\n- This mechanism is also used internally by NSPersistentCloudKitContainer to track what needs to be synced to CloudKit."
  },
  {
    "topic": "coredata",
    "level": 4,
    "question": "What are derived attributes in Core Data, and how do they improve performance compared to manually computed values?",
    "hint": "Think about storing a computed value like a count or a normalized string that the database maintains automatically when related data changes.",
    "answer": "Derived attributes (introduced in iOS 13) are entity attributes whose values are automatically computed and maintained by the persistent store based on a derivation expression. Instead of computing values in application code and manually keeping them in sync, the store itself updates the derived value whenever the underlying data changes during a save.\n\nYou define a derived attribute in the Core Data model editor by specifying a Derivation Expression. Common expressions include:\n\n1. Canonical/normalized strings: A lowercased version of a name for case-insensitive searching:\n   - Derivation: canonical:(name)\n   - Creates a normalized string attribute updated whenever 'name' changes.\n\n2. Count of a to-many relationship: The number of related objects:\n   - Derivation: count:(items)\n   - Automatically updates when items are added or removed.\n\n3. Sum, min, max of related attributes:\n   - Derivation: sum:(lineItems.amount)\n\n4. Current timestamp:\n   - Derivation: now()\n   - Sets the value to the current date/time on each save.\n\nPerformance advantages over manual computation:\n1. Store-level efficiency: The derivation is evaluated at the SQL level during save, avoiding the need to load related objects into memory. For a count derivation, the store runs a SQL COUNT query rather than faulting all related objects.\n2. Consistency: The value is always correct after a save — no risk of forgetting to update it in some code path.\n3. Query optimization: Because the derived value is a real stored attribute with an index, you can use it in predicates and sort descriptors efficiently. Without it, you would need to fetch all objects and compute the value in memory.\n4. Reduced code: Eliminates manual KVO observation, notification handling, or willSave/didSave overrides to maintain computed properties.\n\nLimitations:\n- Derived attributes are read-only — setting them manually has no effect (the store overwrites on save).\n- The derivation expression syntax is limited to a predefined set of functions.\n- They only update on save, so in-memory values may be stale until the context is saved and the object is refreshed.\n- Not all expressions are supported on all store types (primarily designed for SQLite stores).\n- You cannot use derived attributes in NSPredicate with NSPersistentCloudKitContainer in all cases, as CloudKit has its own query limitations."
  },
  {
    "topic": "coredata",
    "level": 5,
    "question": "Design a robust Core Data architecture for an app that performs large background imports, supports real-time UI updates, and must handle merge conflicts gracefully. Explain the context hierarchy, threading strategy, and conflict resolution approach.",
    "hint": "Think about separating read (UI) and write (import) concerns, how changes propagate between contexts, and what happens when a user edits an object that is simultaneously being updated by a background import.",
    "answer": "A production-grade architecture for this scenario involves multiple coordinated contexts with clear roles:\n\nContext hierarchy:\n1. viewContext (main queue): The single source of truth for all UI. Obtained from NSPersistentContainer.viewContext. Set automaticallyMergesChangesFromParent = true and mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy. This ensures user edits take precedence if a conflict arises during merge.\n\n2. Import context (private queue): Created via container.newBackgroundContext() for each import operation. Set mergePolicy = NSMergeByPropertyStoreTrumpMergePolicy so that if two imports conflict, the latest persisted data wins. Set transactionAuthor for persistent history tracking.\n\n3. Edit context (private queue child of viewContext): For user editing workflows, create a child context (parent = viewContext). Edits are isolated — saving pushes to viewContext, which then saves to the store. Discarding the child context cancels all edits cleanly.\n\nThreading strategy:\n- All import work happens inside importContext.perform { } blocks. Large imports are broken into batches (e.g., 500-1000 objects per save) to keep memory bounded and provide incremental UI updates.\n- Use NSBatchInsertRequest for truly massive imports (100K+ objects), then merge the result's objectIDs into the viewContext using NSManagedObjectContext.mergeChanges(fromRemoteContextSave:into:).\n- The viewContext never performs heavy work. It only receives merged changes via automaticallyMergesChangesFromParent or manual mergeChanges calls.\n- For fetch-heavy UI (e.g., search), use a dedicated read-only background context to avoid blocking the main thread during fetch execution, then pass objectIDs to the main context.\n\nConflict resolution:\n- viewContext uses NSMergeByPropertyObjectTrumpMergePolicy: user intent is preserved. If the user modifies an object's 'title' while a background import updates its 'lastSyncDate', both changes survive because the policy merges at the property level.\n- Import contexts use NSMergeByPropertyStoreTrumpMergePolicy: if two import batches conflict, the already-persisted version wins, avoiding data loss from interleaved background saves.\n- For critical business data, implement custom conflict resolution by catching save errors with NSErrorMergePolicy on a dedicated context, inspecting NSConstraintConflict or NSMergeConflict objects, and resolving manually.\n\nAdditional production considerations:\n- Enable persistent history tracking for cross-process sync (extensions, widgets).\n- Use fetchBatchSize (20-50) on all UI-facing fetch requests.\n- Set stalenessInterval on the viewContext to 0 (or a small value) to avoid stale data.\n- Use NSFetchedResultsController with the viewContext for table/collection view data sources.\n- Monitor with -com.apple.CoreData.SQLDebug 1 and Instruments' Core Data template.\n- Implement a retry mechanism for save failures, especially in import contexts where transient SQLite busy errors can occur under heavy concurrent access."
  },
  {
    "topic": "coredata",
    "level": 5,
    "question": "Explain how you would implement a multi-step Core Data migration strategy for a complex app that has gone through many model versions. Address performance, data integrity, and error recovery.",
    "hint": "Consider a scenario where the app has had 15+ model versions and a user upgrading from version 2 to version 15 cannot do a single lightweight migration — you need a chain of incremental migrations.",
    "answer": "A multi-step (progressive) migration strategy handles the case where lightweight migration cannot bridge the gap between distant model versions, and a single heavyweight mapping model would be too complex and fragile.\n\nArchitecture:\n\n1. Ordered model version chain: Maintain an explicit ordered list of all model versions: [V1, V2, V3, ..., V15]. Each version is represented by its .mom file (compiled .xcdatamodel). At startup, detect the store's current version by checking NSPersistentStoreCoordinator.metadataForPersistentStore and comparing against each model using NSManagedObjectModel.isConfiguration(withName:compatibleWithStoreMetadata:).\n\n2. Incremental migration steps: Define migration steps between consecutive versions. Each step is either:\n   - Lightweight: No mapping model needed. Core Data infers the changes automatically.\n   - Custom: A versioned NSMappingModel (V3toV4.xcmappingmodel) with optional NSEntityMigrationPolicy subclasses for data transformation.\n\n3. Migration manager: Build a MigrationManager class that:\n   a. Determines the store's current model version.\n   b. Walks the version chain from current to target, executing each step sequentially.\n   c. For each step, creates an NSMigrationManager with source and destination models, finds or infers the mapping model, and calls migrateStore(from:sourceType:options:with:toDestinationURL:destinationType:destinationOptions:).\n   d. NSMigrationManager migrates to a new temporary file, then atomically replaces the original.\n\nPerformance considerations:\n- Migrate to a temporary file first, then use FileManager.replaceItemAt to atomically swap. This prevents corruption if the process is killed mid-migration.\n- For very large stores, each migration step may take significant time. Show a progress UI — NSMigrationManager exposes a progress property (0.0 to 1.0) that you can observe.\n- Consider WAL checkpoint (PRAGMA wal_checkpoint(TRUNCATE)) before migration to ensure all data is in the main database file.\n- If certain migration steps are purely additive, mark them as lightweight to avoid the overhead of loading a mapping model.\n\nData integrity:\n- Before starting migration, create a backup copy of the store file (and its -wal and -shm files).\n- Validate the migrated store by opening it with the target model and running a sanity-check fetch.\n- Use unique constraints (where possible) to catch duplicates that may arise from migration bugs.\n- Log each migration step (source version, destination version, duration) for debugging production issues.\n\nError recovery:\n- If any step fails, restore from the backup copy and present an error to the user.\n- For unrecoverable scenarios (corrupt store), provide an option to start fresh with an empty store, optionally archiving the corrupt file for support analysis.\n- Ship migration integration tests that exercise the full chain from each historical version to current, using store snapshots from each release.\n\nAdvanced patterns:\n- Lazy migration: Instead of migrating the entire store at launch, migrate on first access. This is complex but avoids long startup delays.\n- Store splitting: If the store is very large, consider migrating to a new store format where hot data (frequently accessed) is in one store and cold data (historical) is in another, using NSPersistentContainer with multiple store descriptions.\n- Version mapping registry: Use a dictionary-based registry that maps (sourceVersion, destinationVersion) to migration closures, making it easy to add new versions without modifying the manager's control flow."
  },
  {
    "topic": "coredata",
    "level": 5,
    "question": "How would you optimize a Core Data-backed app that displays thousands of items in a list with complex filtering, sorting, and search? Address faulting behavior, memory management, predicate optimization, and background fetching.",
    "hint": "Think about a mail app showing thousands of messages with full-text search, multiple sort options, and filter chips — all needing to feel instant.",
    "answer": "Optimizing a Core Data-backed list with thousands of items and complex queries requires a multi-layered approach across fetching, memory, indexing, and UI integration.\n\nFetch request optimization:\n- Set fetchBatchSize to match approximately 2-3 screens worth of cells (e.g., 50). This is the single most impactful optimization. Core Data will fault objects in batches of this size as you scroll, avoiding both loading everything up front and firing individual faults per row.\n- Use returnsObjectsAsFaults = true (the default). Combined with fetchBatchSize, this means objects beyond the current batch remain as faults, consuming minimal memory.\n- For search, use NSPredicate with CONTAINS[cd] for user-facing queries. For better performance, add a derived attribute with canonical:(searchableField) and search against the normalized version using BEGINSWITH (which can use an index).\n- Add database indexes on attributes used in predicates and sort descriptors via the Core Data model editor (check the 'Indexed' box). This is critical for sort performance on large datasets.\n- Use compound indexes (available via NSFetchIndexDescription) for queries that filter and sort on multiple attributes simultaneously.\n\nPredicate optimization:\n- Order compound predicates so the most selective (eliminating the most rows) comes first. SQLite evaluates left to right and short-circuits.\n- Avoid LIKE with leading wildcards (LIKE '*term') as it cannot use indexes. Prefer BEGINSWITH or CONTAINS with proper indexing.\n- For complex multi-filter UIs (e.g., filter chips), build NSCompoundPredicate dynamically from active filters rather than concatenating format strings.\n- Use SUBQUERY sparingly — it is powerful but generates complex SQL. Test with -com.apple.CoreData.SQLDebug 1 to verify the generated SQL is efficient.\n- For full-text search across multiple fields, consider a separate denormalized searchText attribute that concatenates searchable fields, indexed for efficient querying.\n\nNSFetchedResultsController strategy:\n- Use NSFetchedResultsController for the main list. It handles section computation, caching, and incremental change notifications.\n- Enable the cache (cacheName parameter) for repeated fetches with the same request. Invalidate the cache when the predicate or sort changes (deleteCache(withName:)).\n- Implement the diffable data source variant (NSDiffableDataSourceSnapshot from the controller's snapshot) for smoother, more correct animated updates.\n\nMemory management:\n- Monitor memory using Instruments' Allocations and Core Data templates.\n- If the user scrolls through thousands of items, faults will accumulate. Periodically call context.refreshAllObjects() during natural pauses (e.g., when the user stops scrolling) to re-fault objects and reclaim memory, but only if there are no unsaved changes.\n- For image or blob attributes, store them in a separate entity with a relationship, or use allowsExternalBinaryDataStorage. This prevents large data from being loaded when the parent object is faulted in.\n- Set the context's stalenessInterval to a reasonable value (e.g., 30 seconds) to balance freshness against re-fetching overhead.\n\nBackground fetching:\n- For expensive searches, perform the fetch on a background context to avoid blocking the main thread. Fetch objectIDs only (resultType = .managedObjectIDResultType), then use those IDs to construct a predicate (SELF IN %@) for a fast main-context fetch that populates the NSFetchedResultsController.\n- Alternatively, use an asynchronous fetch request (NSAsynchronousFetchRequest) which executes on a background queue and delivers results via a completion handler. However, this has limited adoption and NSFetchedResultsController does not directly support it.\n\nUI-level optimizations:\n- Debounce search input (e.g., 300ms delay) to avoid re-fetching on every keystroke.\n- Use prefetchRowsAt in UITableView/UICollectionView to trigger relationship prefetching ahead of visible cells.\n- For SwiftUI, use @FetchRequest with dynamic predicates via NSPredicate updates, or wrap NSFetchedResultsController in an ObservableObject for finer control.\n- Implement section index titles via sectionIndexTitles(for:) for quick alphabetical navigation in large lists.\n\nMonitoring and profiling:\n- Use -com.apple.CoreData.SQLDebug 1 (or 2, 3 for more detail) to inspect generated SQL queries.\n- Use -com.apple.CoreData.ConcurrencyDebug 1 to catch threading violations.\n- Profile with Instruments' Core Data Fetches, Core Data Faults, and Core Data Saves instruments to identify bottlenecks.\n- Watch for N+1 fault patterns in Instruments and resolve with relationshipKeyPathsForPrefetching."
  },
  {
    "topic": "persistence",
    "level": 0,
    "question": "What is UserDefaults and what types of data can you store in it?",
    "hint": "Think about the property list types that UserDefaults natively supports.",
    "answer": "UserDefaults is a lightweight key-value storage system backed by a property list (.plist) file on disk. It is designed for storing small amounts of user preferences and app configuration.\n\nNatively supported types include:\n- Bool, Int, Float, Double (numeric primitives)\n- String\n- Data\n- Date\n- URL\n- Array (of property list types)\n- Dictionary (with String keys and property list values)\n\nYou can also store any object that conforms to Codable by first encoding it to Data using JSONEncoder or PropertyListEncoder, then saving the resulting Data to UserDefaults. UserDefaults synchronizes in-memory cache with disk automatically, and reads are fast because the entire plist is loaded into memory at launch. Because of this, it should not be used for large datasets — it is best suited for preferences like theme selection, onboarding completion flags, or last-used settings."
  },
  {
    "topic": "persistence",
    "level": 0,
    "question": "What is the app sandbox on iOS and how does it affect file storage?",
    "hint": "Consider the directory structure each app gets and why apps cannot access each other's files.",
    "answer": "The app sandbox is a security mechanism that restricts each iOS app to its own isolated file system container. Every app gets a unique directory structure that includes:\n\n- Documents/ — User-generated content that should be backed up to iCloud. Visible in the Files app if UIFileSharingEnabled is set.\n- Library/ — App-specific support files. Contains subdirectories like Library/Caches/ (not backed up, can be purged by the system) and Library/Preferences/ (where UserDefaults plists are stored).\n- Library/Application Support/ — App-created data files that should be backed up but not exposed to the user.\n- tmp/ — Temporary files that may be deleted by the system when the app is not running.\n\nKey implications:\n- An app cannot read or write files belonging to another app unless explicitly shared via App Groups, document providers, or other IPC mechanisms.\n- The system enforces these boundaries at the kernel level, so there is no way to bypass them on a non-jailbroken device.\n- Choosing the correct directory matters for backup behavior, storage limits, and data lifecycle."
  },
  {
    "topic": "persistence",
    "level": 0,
    "question": "How do you use FileManager to write and read a text file in the Documents directory?",
    "hint": "Think about how you get the path to the Documents directory and the String methods for file I/O.",
    "answer": "You use FileManager.default to locate the Documents directory and then use String or Data methods to write and read:\n\nWriting:\nlet docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\nlet fileURL = docs.appendingPathComponent(\"notes.txt\")\ntry \"Hello, World!\".write(to: fileURL, atomically: true, encoding: .utf8)\n\nReading:\nlet content = try String(contentsOf: fileURL, encoding: .utf8)\n\nThe atomically parameter writes to a temporary file first, then renames it to the destination. This prevents data corruption if the app crashes mid-write.\n\nFor binary data, use Data methods instead:\ntry data.write(to: fileURL, options: [.atomic])\nlet loaded = try Data(contentsOf: fileURL)\n\nYou can also use FileManager to create directories (createDirectory(at:withIntermediateDirectories:)), check existence (fileExists(atPath:)), delete files (removeItem(at:)), and enumerate directory contents (contentsOfDirectory(at:includingPropertiesForKeys:))."
  },
  {
    "topic": "persistence",
    "level": 1,
    "question": "What are the limitations of UserDefaults and when should you avoid using it?",
    "hint": "Consider what happens when UserDefaults stores large amounts of data and how it loads into memory.",
    "answer": "UserDefaults has several important limitations:\n\n1. Memory overhead — The entire UserDefaults plist is loaded into memory at app launch. Storing large blobs (images, large JSON payloads) increases launch time and memory pressure.\n\n2. No querying — It is a flat key-value store with no support for filtering, sorting, or relational queries. If you need to search through stored data, you need a database.\n\n3. Not encrypted — Data is stored as a plain plist file in Library/Preferences/. Sensitive information like tokens or passwords must never go in UserDefaults; use Keychain instead.\n\n4. Thread safety caveat — While reads and writes are thread-safe individually, there is no transactional guarantee. Concurrent read-modify-write cycles can produce race conditions.\n\n5. No schema or migration — There is no built-in versioning. If you change the structure of stored data, you must handle migration manually.\n\n6. Synchronization timing — Although calling synchronize() is rarely needed (the system auto-syncs), there is no guarantee of immediate disk persistence, which matters if the process is killed abruptly.\n\nAvoid UserDefaults for: large collections of model objects, binary data, sensitive credentials, or anything exceeding a few hundred kilobytes total."
  },
  {
    "topic": "persistence",
    "level": 1,
    "question": "Explain the difference between NSCoding and NSSecureCoding. Why was NSSecureCoding introduced?",
    "hint": "Think about what happens during unarchiving if the class type is not validated before decoding.",
    "answer": "NSCoding defines two methods — encode(with:) and init(coder:) — that let objects serialize and deserialize themselves. However, classic NSCoding with NSKeyedUnarchiver has a critical security flaw: the unarchiver instantiates objects before the caller can verify their class. An attacker could craft a malicious archive containing an unexpected class, and the mere act of decoding it could trigger dangerous initializers or side effects.\n\nNSSecureCoding addresses this by requiring class validation at decode time. A class must:\n1. Declare static var supportsSecureCoding: Bool { true }\n2. Use decodeObject(of:forKey:) instead of decodeObject(forKey:), specifying the expected class.\n\nThe unarchiver checks the class in the archive against the expected class before instantiation. If they do not match, decoding fails safely instead of creating an unexpected object.\n\nUsage example:\nlet data = try NSKeyedArchiver.archivedData(withRootObject: obj, requiringSecureCoding: true)\nlet decoded = try NSKeyedUnarchiver.unarchivedObject(ofClass: MyClass.self, from: data)\n\nApple now requires NSSecureCoding for most system APIs (e.g., NSUserActivity, drag and drop, state restoration). In modern Swift code, Codable is generally preferred for new types, but NSSecureCoding remains important when interoperating with Objective-C frameworks."
  },
  {
    "topic": "persistence",
    "level": 1,
    "question": "What is the suiteName parameter in UserDefaults and how does it relate to App Groups?",
    "hint": "Think about how multiple apps or extensions from the same developer can share preferences.",
    "answer": "UserDefaults(suiteName:) creates or accesses a separate UserDefaults domain backed by its own plist file, distinct from UserDefaults.standard.\n\nWhen you pass a regular string as the suite name, it creates a custom domain stored in your app's Library/Preferences/ directory. This is useful for organizing preferences into logical groups within a single app.\n\nThe real power comes with App Groups. When you configure an App Group capability (e.g., group.com.mycompany.myapp) in your provisioning profile and entitlements, you can use that group identifier as the suiteName:\n\nlet shared = UserDefaults(suiteName: \"group.com.mycompany.myapp\")\nshared?.set(42, forKey: \"sharedValue\")\n\nThis creates a plist in a shared container directory accessible to all apps and extensions that belong to the same App Group. Common use cases include:\n- Sharing state between a main app and its widgets (WidgetKit reads data this way)\n- Sharing preferences between a main app and a Today extension, Share extension, or keyboard extension\n- Sharing configuration between multiple apps from the same developer\n\nThe shared container is located outside any single app's sandbox, at a path managed by the system. Each member of the group must declare the same App Group entitlement to access it. UserDefaults.standard is unaffected — it remains private to each app."
  },
  {
    "topic": "persistence",
    "level": 2,
    "question": "How do you store and retrieve a password securely in the iOS Keychain using the Security framework?",
    "hint": "Think about SecItemAdd, SecItemCopyMatching, and the query dictionaries they require.",
    "answer": "The iOS Keychain uses C-level Security framework functions with CFDictionary queries. Here is the typical flow:\n\nStoring a password:\nlet password = \"secret123\".data(using: .utf8)!\nlet addQuery: [String: Any] = [\n    kSecClass as String: kSecClassGenericPassword,\n    kSecAttrAccount as String: \"user@example.com\",\n    kSecAttrService as String: \"com.myapp.auth\",\n    kSecValueData as String: password\n]\nSecItemDelete(addQuery as CFDictionary) // Remove old entry if exists\nlet status = SecItemAdd(addQuery as CFDictionary, nil)\nguard status == errSecSuccess else { /* handle error */ }\n\nRetrieving a password:\nlet searchQuery: [String: Any] = [\n    kSecClass as String: kSecClassGenericPassword,\n    kSecAttrAccount as String: \"user@example.com\",\n    kSecAttrService as String: \"com.myapp.auth\",\n    kSecReturnData as String: true,\n    kSecMatchLimit as String: kSecMatchLimitOne\n]\nvar result: AnyObject?\nlet status = SecItemCopyMatching(searchQuery as CFDictionary, &result)\nif status == errSecSuccess, let data = result as? Data {\n    let password = String(data: data, encoding: .utf8)\n}\n\nKey points:\n- kSecClass determines the item type (generic password, internet password, certificate, key).\n- kSecAttrAccount and kSecAttrService together form the unique identifier for generic passwords.\n- Keychain items persist across app reinstalls (unless the device is erased), unlike UserDefaults which is deleted with the app.\n- Data is encrypted by the Secure Enclave and protected by the device passcode.\n- Use SecItemUpdate to modify existing items and SecItemDelete to remove them."
  },
  {
    "topic": "persistence",
    "level": 2,
    "question": "Explain how Codable works for persistence. How would you save and load an array of Codable model objects to a JSON file on disk?",
    "hint": "Think about JSONEncoder, JSONDecoder, and writing Data to a file URL.",
    "answer": "Codable is a type alias for Encodable & Decodable. When a struct or class conforms to Codable, the compiler auto-synthesizes encode(to:) and init(from:) as long as all stored properties are themselves Codable.\n\nSaving an array to a JSON file:\nstruct Task: Codable {\n    let id: UUID\n    let title: String\n    let isCompleted: Bool\n}\n\nlet tasks: [Task] = [Task(id: UUID(), title: \"Buy milk\", isCompleted: false)]\nlet encoder = JSONEncoder()\nencoder.outputFormatting = [.prettyPrinted, .sortedKeys]\nlet data = try encoder.encode(tasks)\nlet url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n    .appendingPathComponent(\"tasks.json\")\ntry data.write(to: url, options: [.atomic])\n\nLoading from the file:\nlet loadedData = try Data(contentsOf: url)\nlet decoder = JSONDecoder()\nlet loadedTasks = try decoder.decode([Task].self, from: loadedData)\n\nCustomization options:\n- Use CodingKeys enum to map JSON keys to different property names.\n- Use dateDecodingStrategy/dateEncodingStrategy for Date formatting.\n- Use keyDecodingStrategy = .convertFromSnakeCase to auto-map snake_case JSON to camelCase Swift properties.\n- Implement custom init(from:) for complex transformations or default values.\n\nYou can also use PropertyListEncoder/PropertyListDecoder for plist format. Codable is the preferred modern approach over NSCoding because it works with Swift value types, is type-safe, and does not require NSObject inheritance."
  },
  {
    "topic": "persistence",
    "level": 2,
    "question": "What is NSCache and how does it differ from a regular Dictionary for caching purposes?",
    "hint": "Think about memory pressure, thread safety, and eviction policies.",
    "answer": "NSCache is a mutable collection similar to Dictionary but specifically designed for temporary caching with automatic eviction. Key differences from Dictionary:\n\n1. Auto-eviction under memory pressure — NSCache automatically removes entries when the system is low on memory. You do not need to subscribe to UIApplication.didReceiveMemoryWarningNotification and manually purge.\n\n2. Thread safety — NSCache is thread-safe out of the box. Multiple threads can read and write simultaneously without external synchronization. Dictionary requires manual locking or serial queue access.\n\n3. Cost-based limits — You can set totalCostLimit and countLimit. When adding objects with setObject(_:forKey:cost:), NSCache uses the cost to decide which items to evict first. For example, you could use byte count as cost for image caching.\n\n4. Keys are not copied — Unlike NSDictionary (which copies keys), NSCache retains keys. This means you can use objects that do not conform to NSCopying as keys.\n\n5. No enumeration — NSCache does not support iterating over its contents, which is intentional since items can be evicted at any time.\n\nExample:\nlet cache = NSCache<NSString, UIImage>()\ncache.totalCostLimit = 50 * 1024 * 1024 // 50 MB\ncache.countLimit = 100\ncache.setObject(image, forKey: \"avatar_123\" as NSString, cost: imageData.count)\nlet cached = cache.object(forKey: \"avatar_123\" as NSString)\n\nNSCache is ideal for in-memory caches (decoded images, computed results) where you want the system to manage lifecycle automatically. It is not for persistent storage — everything is lost when the process exits."
  },
  {
    "topic": "persistence",
    "level": 3,
    "question": "What are the different NSFileProtection levels available on iOS and when would you use each one?",
    "hint": "Think about when files become accessible relative to the device lock state and first unlock after boot.",
    "answer": "iOS file protection uses hardware encryption keys tied to the device passcode. There are four levels, set via FileManager attributes or Data.WritingOptions:\n\n1. .complete (NSFileProtectionComplete) — File is only accessible when the device is unlocked. The encryption key is discarded from memory when the device locks. Use for highly sensitive data like health records or financial documents. Downside: background tasks cannot read these files when the device is locked.\n\n2. .completeUnlessOpen (NSFileProtectionCompleteUnlessOpen) — File can be created and written while locked, but once closed, it cannot be reopened until the device is unlocked. Uses asymmetric cryptography: a public key creates the file, but the private key (available only when unlocked) is needed to open it. Ideal for downloads that complete in the background.\n\n3. .completeUntilFirstUserAuthentication (NSFileProtectionCompleteUntilFirstUserAuthentication) — This is the default for most files. The file is inaccessible only before the user unlocks the device for the first time after a reboot. After that first unlock, the key remains in memory even when the device locks again. Good for apps that need background access (push notifications, background fetch) but still want protection at rest.\n\n4. .none (NSFileProtectionNone) — No file protection. File is always accessible regardless of lock state. Only use for non-sensitive data that must be available immediately after boot, before any user interaction.\n\nSetting protection:\ntry data.write(to: url, options: [.atomic, .completeFileProtection])\n// or\ntry FileManager.default.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: path)\n\nKeychain items have analogous accessibility levels (kSecAttrAccessibleWhenUnlocked, kSecAttrAccessibleAfterFirstUnlock, etc.) that control when the item's decryption key is available."
  },
  {
    "topic": "persistence",
    "level": 3,
    "question": "How does URLCache work and how can you configure a custom caching policy for network responses?",
    "hint": "Think about URLCache.shared, storage capacities, and CachePolicy on URLRequest.",
    "answer": "URLCache provides a composite in-memory and on-disk cache for URL responses, used automatically by URLSession.\n\nConfiguration:\nlet cache = URLCache(\n    memoryCapacity: 20 * 1024 * 1024,   // 20 MB in memory\n    diskCapacity: 100 * 1024 * 1024,     // 100 MB on disk\n    diskPath: \"myAppCache\"\n)\nURLCache.shared = cache\n\nHow it works:\n- When URLSession receives a response, it may store a CachedURLResponse based on the server's Cache-Control headers.\n- On subsequent requests, the cache is consulted before hitting the network.\n- In-memory cache is checked first (faster), then disk cache.\n\nControlling behavior per request via URLRequest.CachePolicy:\n- .useProtocolCachePolicy (default) — Follows HTTP caching headers (Cache-Control, Expires, ETag, Last-Modified).\n- .returnCacheDataElseLoad — Returns cached data if available regardless of age; only loads from network if no cache exists. Good for offline-first UX.\n- .returnCacheDataDontLoad — Only returns cached data; fails if nothing is cached. Useful for strict offline mode.\n- .reloadIgnoringLocalCacheData — Always fetches from network, ignoring cache. Use when fresh data is critical.\n- .reloadRevalidatingCacheData — Always validates with server using conditional requests (If-None-Match, If-Modified-Since).\n\nManual cache management:\nURLCache.shared.removeCachedResponse(for: dataTask)\nURLCache.shared.removeAllCachedResponses()\nURLCache.shared.removeCachedResponses(since: date)\n\nYou can also manually store responses:\nlet cachedResponse = CachedURLResponse(response: response, data: data)\nURLCache.shared.storeCachedResponse(cachedResponse, for: request)\n\nURLCache respects the shared app container in App Groups if configured, allowing extensions to share cached responses with the main app."
  },
  {
    "topic": "persistence",
    "level": 3,
    "question": "What are Keychain access groups and how do you share Keychain items between multiple apps?",
    "hint": "Think about the keychain-access-groups entitlement and the kSecAttrAccessGroup attribute.",
    "answer": "Keychain access groups allow multiple apps from the same development team to share Keychain items. By default, each app can only access its own Keychain items, scoped by its bundle seed ID (Team ID + bundle identifier).\n\nHow sharing works:\n\n1. Entitlement setup — Each app that needs to share must include the same group identifier in its keychain-access-groups entitlement. The group has the format: $(TeamID).com.mycompany.shared\n\n2. Storing to a shared group:\nlet query: [String: Any] = [\n    kSecClass as String: kSecClassGenericPassword,\n    kSecAttrAccount as String: \"sharedToken\",\n    kSecAttrService as String: \"com.mycompany.auth\",\n    kSecAttrAccessGroup as String: \"ABC123TEAM.com.mycompany.shared\",\n    kSecValueData as String: tokenData\n]\nSecItemAdd(query as CFDictionary, nil)\n\n3. Retrieving from the shared group — The same kSecAttrAccessGroup value must be specified in the search query from any participating app.\n\nAccess group resolution order:\n- If kSecAttrAccessGroup is not specified, the item is stored in the app's default access group (first entry in keychain-access-groups).\n- The system checks that the specified group is in the app's entitlements before allowing access.\n\nKey differences from App Groups:\n- App Groups share a file system container (UserDefaults, files). Keychain access groups share encrypted Keychain items.\n- Both require the same Team ID. App Groups use the group.* prefix; Keychain groups use the TeamID.* prefix.\n- Keychain items survive app deletion; App Group container files do not (on iOS 15+, containers may be cleaned up).\n\nCommon use case: A suite of apps (banking app, trading app, wallet app) sharing an authentication token so the user does not have to log in separately to each app."
  },
  {
    "topic": "persistence",
    "level": 4,
    "question": "How would you use SQLite directly in an iOS app without CoreData? What are the advantages and trade-offs compared to file-based persistence?",
    "hint": "Think about the C API (sqlite3_open, sqlite3_exec, sqlite3_prepare_v2), wrapper libraries, and when a relational database is justified.",
    "answer": "SQLite is an embedded relational database engine included in iOS. You can use it directly via the C API or through Swift wrappers.\n\nDirect C API usage:\nvar db: OpaquePointer?\nsqlite3_open(dbPath, &db)\nsqlite3_exec(db, \"CREATE TABLE IF NOT EXISTS tasks (id TEXT PRIMARY KEY, title TEXT, completed INTEGER)\", nil, nil, nil)\n\nvar stmt: OpaquePointer?\nsqlite3_prepare_v2(db, \"INSERT INTO tasks (id, title, completed) VALUES (?, ?, ?)\", -1, &stmt, nil)\nsqlite3_bind_text(stmt, 1, id, -1, SQLITE_TRANSIENT)\nsqlite3_bind_text(stmt, 2, title, -1, SQLITE_TRANSIENT)\nsqlite3_bind_int(stmt, 3, completed ? 1 : 0)\nsqlite3_step(stmt)\nsqlite3_finalize(stmt)\nsqlite3_close(db)\n\nPopular Swift wrappers:\n- SQLite.swift — Type-safe query builder with Swift expressions.\n- GRDB.swift — Full-featured library with record mapping, migrations, WAL mode, and observation (database changes trigger SwiftUI updates via ValueObservation).\n- FMDB — Objective-C wrapper, still widely used.\n\nAdvantages over file-based persistence:\n- Complex queries — WHERE, JOIN, GROUP BY, ORDER BY, aggregate functions. Property lists and JSON files require loading everything into memory to filter.\n- Partial reads — You can fetch only the rows you need instead of deserializing an entire file.\n- ACID transactions — Atomicity, consistency, isolation, durability. File writes can corrupt data if interrupted.\n- Indexing — Queries on indexed columns are O(log n) instead of O(n).\n- Concurrency — WAL (Write-Ahead Logging) mode allows concurrent readers with a single writer without blocking.\n\nTrade-offs:\n- Added complexity — Schema design, migrations, query construction.\n- Overhead for simple data — If you just need to store a few preferences or a small list, UserDefaults or a JSON file is simpler.\n- No object graph management — Unlike CoreData, you must handle relationships, change tracking, and memory management manually.\n- Binary size — SQLite is already included in iOS, so no additional binary size cost.\n\nSQLite is ideal when you have structured data with thousands of records, need efficient querying, or require transactional integrity without the abstraction overhead of CoreData."
  },
  {
    "topic": "persistence",
    "level": 4,
    "question": "How do you share files and structured data between a main app and its extensions using App Groups? What are the pitfalls of concurrent access?",
    "hint": "Think about the shared container URL, file coordination, and what happens when a widget and the main app write simultaneously.",
    "answer": "App Groups provide a shared container directory accessible to all members of the group. You get the container URL via:\n\nlet sharedURL = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: \"group.com.mycompany.myapp\")!\nlet dataURL = sharedURL.appendingPathComponent(\"shared_data.json\")\n\nCommon patterns:\n- Shared UserDefaults: UserDefaults(suiteName: \"group.com.mycompany.myapp\") for lightweight key-value data.\n- Shared files: Write JSON, plists, or SQLite databases to the shared container for richer data.\n- Shared SQLite: Place the .sqlite file in the shared container so both the app and widget can query it.\n\nConcurrent access pitfalls:\n\n1. File corruption — If the main app writes a JSON file while a widget extension reads it, the reader may see a partially written file. Use atomic writes (Data.WritingOptions.atomic) so the file is replaced atomically via rename().\n\n2. SQLite locking — SQLite handles concurrent access via file locks, but extensions have limited runtime. If the main app holds a write lock, the extension's query may time out. Use WAL mode (PRAGMA journal_mode=WAL) for better concurrency — it allows concurrent reads during writes.\n\n3. NSFileCoordinator — For file-based sharing, Apple recommends using NSFileCoordinator and NSFilePresenter to coordinate access. The coordinator serializes reads and writes:\nlet coordinator = NSFileCoordinator()\nvar error: NSError?\ncoordinator.coordinate(writingItemAt: dataURL, options: [], error: &error) { url in\n    try? data.write(to: url, options: .atomic)\n}\nHowever, NSFileCoordinator can cause deadlocks if misused and adds significant complexity.\n\n4. UserDefaults race conditions — Two processes can overwrite each other's changes. UserDefaults does not provide locking. For widgets, the recommended pattern is to have only the main app write and the extension only read.\n\n5. Extension termination — Extensions can be killed at any time by the system. Long-running writes may be interrupted. Always use atomic writes and keep write operations small.\n\nBest practices:\n- Designate one writer (the main app) and make extensions read-only when possible.\n- Use GRDB or SQLite with WAL mode for structured shared data.\n- Keep shared data small — widgets should read pre-computed snapshots, not raw data.\n- Use Darwin notifications (CFNotificationCenterGetDarwinNotifyCenter) to signal between processes that data has changed."
  },
  {
    "topic": "persistence",
    "level": 5,
    "question": "Design a robust offline-first persistence layer for an iOS app that must handle large datasets, support background sync, survive process termination, and encrypt sensitive fields. What storage technologies would you combine and why?",
    "hint": "Think about layering SQLite, Keychain, file protection, background tasks, and conflict resolution strategies.",
    "answer": "A production-grade offline-first persistence layer requires combining multiple storage technologies, each used for its strengths:\n\n1. Primary data store — SQLite via GRDB.swift or a similar wrapper.\n- Use WAL mode for concurrent read/write access (main thread reads while background queue syncs).\n- Define a migration system: each schema version gets a numbered migration. Run migrations at app launch before any reads.\n- Use FTS5 (Full-Text Search) for searchable content.\n- Implement database observation (GRDB's ValueObservation) to drive SwiftUI views reactively.\n\n2. Encryption — SQLCipher for full-database encryption, or column-level encryption for specific sensitive fields.\n- Store the database encryption key in the Keychain with kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly so it is available for background sync but does not migrate to new devices.\n- For column-level encryption, use CryptoKit (AES-GCM) to encrypt individual fields before writing them to SQLite. Store the field encryption key in Keychain.\n\n3. File storage — Large binary assets (images, PDFs) stored as files in Library/Application Support/, referenced by file paths in the database.\n- Set NSFileProtectionCompleteUntilFirstUserAuthentication on the directory so background tasks can access files.\n- Use content-addressable storage (filename = SHA-256 hash) to deduplicate identical files.\n\n4. Sync engine architecture:\n- Each record has a localModifiedAt timestamp and a syncStatus enum (synced, pendingUpload, pendingDeletion, conflict).\n- Background sync uses BGProcessingTask (for long syncs) and BGAppRefreshTask (for quick checks).\n- The sync process: fetch remote changes since last sync token, merge into local DB using last-writer-wins or vector clocks, then push local pending changes.\n- Use NSFileProtection levels that allow background access, and handle URLSession background transfers for large uploads.\n\n5. Conflict resolution:\n- For simple cases, server-wins or client-wins with a merge timestamp.\n- For rich content, field-level merging: compare individual fields and keep the most recent change per field.\n- Store a conflict log so the user can manually resolve if needed.\n\n6. Caching layer:\n- NSCache for decoded images and frequently accessed objects.\n- URLCache configured with appropriate disk capacity for API responses.\n- ETag/Last-Modified headers to minimize redundant downloads.\n\n7. Metadata and preferences:\n- UserDefaults for sync tokens, last sync date, feature flags.\n- Keychain for auth tokens, encryption keys, and user credentials.\n\n8. Data integrity:\n- Wrap multi-table mutations in SQLite transactions.\n- Use atomic file writes for all disk operations.\n- Implement a corruption recovery strategy: detect SQLite corruption via integrity_check, fall back to a backup copy, and trigger a full re-sync from the server.\n\nThis layered approach gives you fast local queries, encrypted sensitive data, resilient background sync, and graceful handling of conflicts and edge cases like process termination mid-write."
  },
  {
    "topic": "architecture",
    "level": 0,
    "question": "What is the MVC pattern in iOS, and what role does each component play?",
    "hint": "Think about the three layers Apple's UIKit framework naturally encourages: one for data, one for display, and one that sits between them.",
    "answer": "MVC stands for Model-View-Controller.\n\n- Model: Represents the data and business logic of the application. It is independent of the UI and manages the app's state, data validation, and persistence.\n- View: Everything the user sees on screen — UILabels, UIButtons, UITableViews, etc. Views are responsible for displaying data and capturing user interactions, but they should not contain business logic.\n- Controller: The intermediary (UIViewController in iOS) that coordinates between the Model and the View. It receives user input from the View, updates the Model accordingly, and refreshes the View when the Model changes.\n\nIn Apple's version of MVC, the Controller tends to have direct references to both the Model and the View, which often leads to the 'Massive View Controller' problem where too much logic accumulates in the controller."
  },
  {
    "topic": "architecture",
    "level": 0,
    "question": "What is the 'Massive View Controller' problem, and why does it occur in iOS development?",
    "hint": "Consider what happens when a single UIViewController handles networking, data formatting, layout, navigation, and user interaction all at once.",
    "answer": "The Massive View Controller (or 'fat view controller') problem occurs when UIViewControllers accumulate too many responsibilities, becoming excessively large and difficult to maintain.\n\nIt happens because in Apple's MVC, the ViewController sits between the Model and View and naturally becomes the dumping ground for:\n- Networking and API calls\n- Data formatting and transformation\n- Navigation logic\n- Delegate and data source implementations (e.g., UITableViewDelegate)\n- Business logic and validation\n- Animation and presentation code\n\nThis violates the Single Responsibility Principle. A ViewController might grow to thousands of lines, making it hard to read, test, and reuse.\n\nSolutions include:\n- Extracting logic into separate objects (ViewModels, Coordinators, Services)\n- Using child view controllers for complex layouts\n- Moving data source logic into separate objects\n- Adopting patterns like MVVM, VIPER, or Clean Architecture that enforce better separation of concerns."
  },
  {
    "topic": "architecture",
    "level": 0,
    "question": "What does 'separation of concerns' mean in iOS app architecture?",
    "hint": "Think about how you would organize a kitchen — cooking tools in one place, cleaning supplies in another, food storage separate from both.",
    "answer": "Separation of concerns is a design principle where each module, class, or component in an application handles one specific aspect of the app's functionality.\n\nIn iOS development, this means:\n- UI code (views, layouts, animations) should be separate from business logic.\n- Networking code should not live inside view controllers.\n- Data persistence logic should be isolated from the presentation layer.\n- Navigation should be handled independently from the screens themselves.\n\nBenefits of separation of concerns:\n- Testability: Each component can be unit tested in isolation.\n- Maintainability: Changes in one area (e.g., switching from Core Data to Realm) don't ripple through the entire codebase.\n- Reusability: Components with focused responsibilities can be reused in different contexts.\n- Readability: Developers can understand a component without needing to understand the entire system.\n\nArchitectural patterns like MVVM, VIPER, and Clean Architecture all exist to enforce separation of concerns in structured ways."
  },
  {
    "topic": "architecture",
    "level": 0,
    "question": "What is the MVVM pattern, and how does it differ from MVC?",
    "hint": "The key difference is an additional layer that sits between the View and the Model, exposing data in a way the View can directly bind to.",
    "answer": "MVVM stands for Model-View-ViewModel.\n\n- Model: Same as MVC — holds data and business logic.\n- View: The UI layer, which in iOS includes both UIViews and UIViewControllers (or SwiftUI Views). The View observes the ViewModel for changes.\n- ViewModel: A new layer that doesn't exist in MVC. It takes raw data from the Model, transforms it into a format the View can display, and exposes it via observable properties. It contains presentation logic but has no reference to UIKit or SwiftUI views.\n\nKey differences from MVC:\n1. The ViewModel replaces much of the Controller's responsibility, keeping ViewControllers thin.\n2. The ViewModel is UI-framework-agnostic, making it highly testable without needing to instantiate views.\n3. Data binding (via Combine, KVO, or closures) allows the View to reactively update when the ViewModel changes, reducing imperative glue code.\n4. The View owns the ViewModel, but the ViewModel does not know about the View (unlike MVC where the Controller directly manipulates the View).\n\nMVVM is particularly well-suited for SwiftUI, where views are declarative and naturally bind to observable state."
  },
  {
    "topic": "architecture",
    "level": 1,
    "question": "Explain the Coordinator pattern and how it solves navigation-related problems in iOS apps.",
    "hint": "Think about who decides which screen to show next — should a ViewController know about every other screen it can navigate to?",
    "answer": "The Coordinator pattern extracts navigation logic out of ViewControllers into dedicated Coordinator objects.\n\nProblem it solves:\nIn a typical iOS app, ViewControllers push, present, or instantiate other ViewControllers directly. This creates tight coupling — ViewController A must know about ViewController B, its initializer, and how to present it. This makes ViewControllers hard to reuse and test.\n\nHow it works:\n1. A Coordinator is an object responsible for creating ViewControllers, injecting their dependencies, and managing navigation flow.\n2. Each Coordinator has a start() method that kicks off its flow.\n3. ViewControllers communicate user actions back to the Coordinator via delegates or closures (e.g., 'user tapped login').\n4. The Coordinator decides which screen to show next and handles the push/present/dismiss logic.\n5. Coordinators can have child coordinators for sub-flows (e.g., an AuthCoordinator for login/signup, a MainCoordinator for the main tab flow).\n\nBenefits:\n- ViewControllers become reusable since they don't know about other screens.\n- Navigation logic is centralized and easier to modify.\n- Deep linking becomes simpler since Coordinators can be told to navigate to any point.\n- Testing navigation flows is straightforward — you test the Coordinator, not the ViewController.\n\nMVVM-C is the common combination of MVVM with Coordinators, where ViewModels delegate navigation events to Coordinators."
  },
  {
    "topic": "architecture",
    "level": 1,
    "question": "What is the Repository pattern, and how is it typically used in iOS applications?",
    "hint": "Consider a layer that acts as a single source of truth for data, hiding whether the data comes from a network API, a local database, or an in-memory cache.",
    "answer": "The Repository pattern provides an abstraction layer between the domain/business logic and the data access layer. It acts as a centralized data broker that mediates between different data sources.\n\nHow it works in iOS:\n1. Define a repository protocol that exposes data operations (fetch, save, delete) without revealing the underlying data source.\n2. The concrete implementation decides whether to fetch from a remote API, local cache (Core Data, Realm, UserDefaults), or in-memory store.\n3. ViewModels or Use Cases depend on the repository protocol, not the concrete implementation.\n\nExample structure:\n- UserRepository (protocol): defines fetchUser(id:), saveUser(_:), deleteUser(_:)\n- DefaultUserRepository (class): implements the protocol, coordinates between UserAPIService and UserCacheService\n- It might first check the cache, return cached data, then fetch fresh data from the API and update the cache.\n\nBenefits:\n- Swappable data sources: You can switch from Core Data to Realm without changing any ViewModel code.\n- Testability: In tests, provide a MockUserRepository that returns predefined data.\n- Single source of truth: The repository manages caching strategies, conflict resolution, and data freshness in one place.\n- Separation of concerns: Business logic doesn't need to know about URLSession, Core Data contexts, or SQL queries.\n\nThe Repository pattern is a cornerstone of Clean Architecture and is frequently used alongside MVVM or VIPER."
  },
  {
    "topic": "architecture",
    "level": 1,
    "question": "How do SOLID principles apply to iOS development? Give a concrete example of each principle.",
    "hint": "Think of each letter: S for single job per class, O for extending without modifying, L for substitutability, I for small protocols, D for depending on abstractions.",
    "answer": "SOLID principles are five design principles that guide maintainable and scalable software. Here's how each applies to iOS:\n\nS — Single Responsibility Principle:\nA class should have only one reason to change. A ViewController should not handle networking, parsing, and navigation. Instead, extract networking into a Service, parsing into a Mapper, and navigation into a Coordinator.\n\nO — Open/Closed Principle:\nClasses should be open for extension but closed for modification. Instead of adding switch cases to a formatting function every time a new type is added, use a protocol (e.g., Formattable) so new types conform to it without modifying existing code.\n\nL — Liskov Substitution Principle:\nSubtypes must be substitutable for their base types. If a function accepts an Animal protocol, both Dog and Cat conforming types must work correctly without the function needing to check the specific type. Violating this often shows up as force-casting in iOS (e.g., cell as! CustomCell).\n\nI — Interface Segregation Principle:\nClients should not be forced to depend on methods they don't use. Instead of one massive DataManagerProtocol with 20 methods, split into UserFetching, UserSaving, and UserDeleting protocols. A ViewModel that only reads users depends only on UserFetching.\n\nD — Dependency Inversion Principle:\nHigh-level modules should depend on abstractions, not concrete implementations. A ViewModel should depend on a UserRepository protocol, not a CoreDataUserRepository class. This enables swapping implementations and simplifies testing."
  },
  {
    "topic": "architecture",
    "level": 1,
    "question": "What is the Service Layer pattern, and when would you use it in an iOS app?",
    "hint": "Think of a layer that encapsulates specific business operations — it's not about data storage (that's Repository) but about orchestrating actions.",
    "answer": "The Service Layer pattern defines a set of operations that encapsulate the application's business logic and coordinate work between multiple components.\n\nIn iOS, services typically handle:\n- Networking: An APIService or NetworkService that wraps URLSession and handles request construction, authentication headers, and response parsing.\n- Authentication: An AuthService that manages login, logout, token refresh, and session state.\n- Analytics: An AnalyticsService that abstracts over multiple analytics providers (Firebase, Mixpanel).\n- Location: A LocationService that wraps CLLocationManager and provides a clean async API.\n\nHow it fits in architecture:\n- ViewModels call Services to perform operations (e.g., authService.login(email:password:)).\n- Services call Repositories for data persistence needs.\n- Services can coordinate multiple repositories (e.g., an OrderService might update both OrderRepository and InventoryRepository).\n\nKey characteristics:\n- Defined by protocols for testability and flexibility.\n- Stateless or managing minimal state (like auth tokens).\n- Reusable across multiple ViewModels or features.\n- Abstract away third-party SDK details (e.g., wrapping Firebase behind a protocol).\n\nWhen to use it:\n- When business logic spans multiple data sources or requires orchestration.\n- When you want to isolate third-party dependencies behind clean interfaces.\n- When multiple ViewModels share the same business operation.\n\nThe Service Layer sits between the presentation layer (ViewModels) and the data layer (Repositories), providing a clean API for business operations."
  },
  {
    "topic": "architecture",
    "level": 2,
    "question": "Explain the VIPER architecture. What are its five components, and how do they communicate?",
    "hint": "Each letter stands for a layer: think about who holds the view, who holds the business rules, who talks to the data layer, who creates everything, and who handles navigation.",
    "answer": "VIPER is a Clean Architecture adaptation for iOS with five distinct layers:\n\nV — View:\nThe passive UI layer (UIViewController or SwiftUI View). It displays data provided by the Presenter and forwards user actions to the Presenter. It never contains business logic or data formatting.\n\nI — Interactor:\nContains the business logic. It fetches data from entities/services, applies business rules, and returns results to the Presenter. It is completely UI-independent and highly testable.\n\nP — Presenter:\nThe middleman. It receives user actions from the View, asks the Interactor to perform business logic, formats the Interactor's results into view-friendly data, and tells the View to update. It also tells the Router when navigation is needed.\n\nE — Entity:\nPlain data models (structs) used by the Interactor. They represent the core data of the application without any framework dependencies.\n\nR — Router (or Wireframe):\nHandles navigation and module assembly. It creates all VIPER components, wires them together, and manages transitions to other modules.\n\nCommunication flow:\n1. View → Presenter: User tapped a button.\n2. Presenter → Interactor: Fetch the user's orders.\n3. Interactor → Presenter: Here are the raw order entities.\n4. Presenter → View: Here are formatted order view models, update the UI.\n5. Presenter → Router: Navigate to order detail for order ID 42.\n\nEach layer communicates through protocols, ensuring loose coupling. The View holds a strong reference to the Presenter, the Presenter holds strong references to the Interactor and Router, and the Interactor holds a weak reference back to the Presenter (to avoid retain cycles).\n\nVIPER is verbose but provides excellent testability and separation of concerns, making it suitable for large teams and complex modules."
  },
  {
    "topic": "architecture",
    "level": 2,
    "question": "What is Clean Architecture (VIP cycle) as described by Uncle Bob, and how does it map to iOS?",
    "hint": "Think about concentric circles where dependencies point inward, and the innermost circle (entities) knows nothing about the outer circles (UI, frameworks).",
    "answer": "Clean Architecture organizes code into concentric layers with a strict dependency rule: outer layers can depend on inner layers, but inner layers must never depend on outer layers.\n\nThe layers from inside out:\n1. Entities: Core business objects and rules that are app-independent. They would exist even without an iOS app.\n2. Use Cases (Interactors): Application-specific business rules. They orchestrate entities and define what the app can do (e.g., PlaceOrderUseCase).\n3. Interface Adapters: Convert data between the format used by Use Cases and the format used by external layers. This includes Presenters, ViewModels, and Repository implementations.\n4. Frameworks & Drivers: The outermost layer — UIKit, SwiftUI, Core Data, URLSession, third-party SDKs. These are details that can be swapped.\n\nThe Dependency Rule:\nSource code dependencies must always point inward. A Use Case defines a repository protocol (in its own layer), and the concrete implementation lives in the outer layer. This is the Dependency Inversion Principle in practice.\n\nVIP Cycle in iOS (Clean Swift by Raymond Law):\n- ViewController → Interactor: sends requests (user actions).\n- Interactor → Presenter: sends responses (processed data).\n- Presenter → ViewController: sends view models (formatted for display).\nThis forms a unidirectional cycle, making data flow predictable.\n\nBenefits:\n- Framework independence: The business logic doesn't depend on UIKit, so it's portable and testable.\n- Testability: Each layer can be tested by mocking the adjacent layer's protocol.\n- Flexibility: Swapping Core Data for Realm only affects the outer layer.\n\nThe trade-off is significant boilerplate, which is why it's typically reserved for large-scale apps where long-term maintainability outweighs initial development speed."
  },
  {
    "topic": "architecture",
    "level": 2,
    "question": "How does modular architecture work in iOS, and what are the benefits of structuring an app using Swift Package Manager (SPM) modules?",
    "hint": "Think about splitting a monolithic app into independent packages — each owning a feature, a shared utility, or a core domain — and how SPM enforces access boundaries.",
    "answer": "Modular architecture breaks an iOS app into discrete, independently compilable modules instead of keeping everything in a single monolithic target.\n\nCommon module categories:\n- Feature modules: Each feature (Home, Profile, Payments) is its own SPM package or framework.\n- Core modules: Shared business logic, domain models, and use cases.\n- Infrastructure modules: Networking, persistence, analytics — framework wrappers.\n- Design system module: Reusable UI components, colors, fonts, and styling.\n- App module: The thin shell that composes all modules together and handles app lifecycle.\n\nHow SPM enables this:\n- Each module is a Swift Package with its own Package.swift defining dependencies.\n- SPM enforces access control: only types marked public are visible to consumers.\n- Dependencies between modules are explicit and one-directional.\n- Each module can have its own test target.\n\nBenefits:\n1. Build times: Only changed modules recompile. Xcode can parallelize module builds.\n2. Enforced boundaries: A developer cannot accidentally access internal implementation details of another module.\n3. Team scalability: Different teams own different modules with clear interfaces.\n4. Testability: Modules can be tested in isolation, and integration tests verify the composition.\n5. Reusability: Modules can be shared across multiple apps (e.g., a shared Design module).\n6. Feature toggles: Feature modules can be conditionally included or excluded.\n\nChallenges:\n- Defining clean interfaces between modules requires upfront design.\n- Circular dependencies must be avoided (extract shared types into a common module).\n- Debugging across module boundaries can be more complex.\n- Initial setup takes time compared to a monolithic project."
  },
  {
    "topic": "architecture",
    "level": 2,
    "question": "Describe the Coordinator pattern combined with MVVM (MVVM-C). How does the Coordinator interact with the ViewModel and the View?",
    "hint": "Think about who creates the ViewModel, who the ViewModel notifies when navigation is needed, and who ultimately performs the push or present.",
    "answer": "MVVM-C combines MVVM with the Coordinator pattern to add structured navigation management.\n\nComponent responsibilities:\n- View (ViewController/SwiftUI View): Displays data from the ViewModel and forwards user actions.\n- ViewModel: Holds presentation logic, transforms Model data, exposes observable state. When a navigation-triggering action occurs, it notifies the Coordinator.\n- Coordinator: Creates ViewControllers and ViewModels, injects dependencies, and performs navigation (push, present, dismiss). It also manages child coordinators for sub-flows.\n\nInteraction flow:\n1. The Coordinator creates a ViewModel, injecting any required services.\n2. The Coordinator creates a ViewController, passing the ViewModel to it.\n3. The Coordinator pushes/presents the ViewController.\n4. The user interacts with the View, which calls ViewModel methods.\n5. When the ViewModel determines navigation is needed (e.g., user tapped an item), it calls a closure or delegate method that the Coordinator provided.\n6. The Coordinator then creates the next ViewModel/ViewController pair and navigates.\n\nCommunication approaches (ViewModel → Coordinator):\n- Closures: viewModel.onItemSelected = { [weak self] item in self?.showDetail(for: item) }\n- Delegate: The Coordinator conforms to a ViewModelDelegate protocol.\n- Reactive: The Coordinator subscribes to a navigation event publisher on the ViewModel.\n\nChild Coordinators:\nComplex flows use a parent-child hierarchy. An AppCoordinator starts an AuthCoordinator or MainTabCoordinator. When a child flow completes, it calls back to the parent, which removes the child and starts the next flow.\n\nBenefits over plain MVVM:\n- ViewModels and ViewControllers are decoupled from navigation.\n- Deep linking is handled centrally by coordinators.\n- Flow logic (e.g., onboarding → main, or auth → dashboard) is explicit and testable."
  },
  {
    "topic": "architecture",
    "level": 3,
    "question": "Explain The Composable Architecture (TCA) by Point-Free. What are its core components, and how does it handle side effects?",
    "hint": "Think about a Store that holds State, an Action enum, a Reducer that produces new state, and an Effect type that wraps async work.",
    "answer": "The Composable Architecture (TCA) is a library by Point-Free for building applications in a consistent, composable, and testable way using unidirectional data flow.\n\nCore components:\n\n1. State: A struct that holds all the data a feature needs to render its UI and perform its logic. It is a value type and must be Equatable.\n\n2. Action: An enum that represents all possible events — user actions (buttonTapped), delegate actions from child features, and effects returning results (dataLoaded(Result<Data, Error>)).\n\n3. Reducer: A function (now expressed via the @Reducer macro) that takes the current State and an Action, mutates the State, and returns an Effect. This is the only place state mutations happen.\n\n4. Store: A reference type that holds the current State and dispatches Actions. Views observe the Store (via @ObservedObject or the newer @Bindable) and send actions to it.\n\n5. Effect: Represents side effects — network requests, timers, database operations. Effects are returned from the Reducer and produce Actions that are fed back into the Reducer. They are built on Combine or Swift concurrency.\n\nSide effect handling:\n- The Reducer is a pure function — it only mutates state and declares what side effects to run.\n- Side effects are expressed as Effect values returned from the reducer.\n- Effects run asynchronously and produce new Actions when they complete.\n- This makes everything deterministic and testable: in tests, you can assert exact state changes and verify which effects were produced.\n\nComposition:\n- Features are composed using Scope reducers, allowing a parent to embed child features.\n- The pullback/scope mechanism maps child state/actions into parent state/actions.\n\nDependency management:\n- TCA provides @Dependency for injecting dependencies (API clients, date generators, UUID generators).\n- In tests, dependencies are automatically overridden with failing implementations unless explicitly provided.\n\nTesting:\n- TestStore allows step-by-step assertions: send an action, assert state changes, receive effect actions, assert again.\n- Non-exhaustive testing mode allows focusing on specific state changes.\n\nTrade-offs:\n- Steep learning curve.\n- Verbose for simple features.\n- Strong opinions may conflict with existing codebases.\n- Excellent for complex features requiring predictable state management."
  },
  {
    "topic": "architecture",
    "level": 3,
    "question": "What is unidirectional data flow, and how does Redux-style architecture work in iOS? Compare it with bidirectional binding in MVVM.",
    "hint": "In unidirectional flow, data moves in one direction: Action → Reducer → State → View → Action. In MVVM, bindings can create bidirectional data flow between View and ViewModel.",
    "answer": "Unidirectional data flow (UDF) is an architectural pattern where data flows in a single direction through the application, forming a predictable cycle.\n\nThe Redux cycle in iOS:\n1. State: A single immutable struct representing the entire app (or feature) state.\n2. Action: A value (usually an enum case) describing something that happened.\n3. Reducer: A pure function — (State, Action) → State — that produces a new state given the current state and an action.\n4. Store: Holds the current state, dispatches actions to the reducer, and notifies subscribers (views) of state changes.\n5. Middleware/Effects: Handles side effects (networking, persistence) and dispatches new actions when complete.\n\nFlow: View sends Action → Store dispatches to Reducer → Reducer produces new State → Store updates → View re-renders.\n\nComparison with bidirectional MVVM:\n\nMVVM with bindings:\n- View ↔ ViewModel: Data flows both ways. A @Published property updates the view, and a @Binding or text field directly mutates the ViewModel.\n- Pros: Less boilerplate, feels natural with SwiftUI's two-way bindings.\n- Cons: State changes can be hard to trace. Multiple sources of mutation make debugging complex. Race conditions with multiple bindings.\n\nUnidirectional (Redux-style):\n- View → Action → Reducer → State → View: State can only change through actions processed by the reducer.\n- Pros: State changes are predictable and traceable. Time-travel debugging is possible. Every mutation is logged as an action. Easier to reason about in complex features.\n- Cons: More boilerplate (actions for every event). Simple forms require explicit action handling for each field. Learning curve.\n\nWhen to choose UDF:\n- Complex features with many interdependent state changes.\n- Features requiring detailed logging, debugging, or undo/redo.\n- Teams that benefit from strict conventions.\n\nWhen MVVM is sufficient:\n- Simple CRUD screens.\n- Small teams comfortable with reactive bindings.\n- Features where bidirectional binding reduces complexity rather than adding it."
  },
  {
    "topic": "architecture",
    "level": 3,
    "question": "How would you implement a protocol-oriented architecture in Swift for an iOS app? What advantages does it offer over class-based inheritance hierarchies?",
    "hint": "Think about how protocols with default extensions, protocol composition, and associated types replace deep class hierarchies.",
    "answer": "Protocol-oriented architecture uses protocols as the primary abstraction mechanism instead of class inheritance.\n\nImplementation approach:\n\n1. Define behaviors as protocols:\nprotocol Loadable { func load() async throws -> Data }\nprotocol Cacheable { func cache(_ data: Data) }\nprotocol Refreshable { var refreshInterval: TimeInterval { get } }\n\n2. Provide default implementations via extensions:\nextension Refreshable { var refreshInterval: TimeInterval { 300 } }\n\n3. Compose capabilities:\nstruct UserService: Loadable, Cacheable, Refreshable { ... }\nThe type adopts exactly the capabilities it needs — no more, no less.\n\n4. Use protocol composition for dependency declarations:\nfunc configure(service: Loadable & Cacheable) — the function only requires what it uses.\n\n5. Use associated types for generic protocols:\nprotocol Repository { associatedtype Entity; func fetch(id: String) async throws -> Entity }\n\nAdvantages over class inheritance:\n\n1. No single-inheritance limitation: A type can conform to many protocols, whereas a class can only inherit from one superclass.\n2. Value type compatibility: Structs and enums can conform to protocols, enabling value semantics with shared behavior.\n3. Interface Segregation: Protocols can be small and focused. Clients depend only on the protocols they use.\n4. Testability: Protocols make it trivial to create mock/stub implementations for testing.\n5. No fragile base class problem: Changes to a protocol extension don't unexpectedly break conforming types the way changes to a superclass can.\n6. Explicit conformance: It's clear which capabilities a type has by reading its declaration.\n7. Retroactive conformance: You can extend existing types (even from frameworks) to conform to your protocols.\n\nLimitations to be aware of:\n- Protocols with associated types cannot be used as existential types directly (requires 'any' keyword or type erasure).\n- Default implementations can be surprising if a conforming type doesn't realize a method has a default.\n- Protocol witnesses are dynamically dispatched, which can have minor performance implications compared to static dispatch.\n- Overly granular protocols can lead to protocol explosion."
  },
  {
    "topic": "architecture",
    "level": 3,
    "question": "Explain routing and navigation patterns in iOS, including deep linking and universal links. How do they interact with architectural patterns?",
    "hint": "Think about how a URL like 'myapp://orders/123' gets translated into a series of navigations, and which architectural component should own that translation.",
    "answer": "Routing in iOS involves translating navigation intents (user actions, deep links, push notifications) into screen transitions.\n\nDeep Linking:\n- Custom URL schemes: myapp://orders/123 — registered in Info.plist. The app receives the URL in application(_:open:options:) or scene(_:openURLContexts:).\n- Universal Links: https://myapp.com/orders/123 — associated with your domain via an apple-app-site-association file. The system verifies your domain owns the link. Handled in application(_:continue:restorationHandler:) or scene(_:continue:).\n\nRouting architecture:\n\n1. URL Parser: Converts a URL string into a typed Route enum.\nenum Route { case orderDetail(id: String), case profile, case settings }\n\n2. Router/Coordinator: Takes a Route and performs the navigation. It knows how to construct the correct ViewController stack.\n\n3. Navigation state management: The router must handle:\n- App not running (cold start): Build the entire navigation stack.\n- App in background: Modify the existing stack to show the target screen.\n- App in foreground: Push or present on top of the current context.\n\nIntegration with architectures:\n\n- MVVM-C: Coordinators own routing. The AppCoordinator parses the URL, then delegates to the appropriate child coordinator (e.g., OrdersCoordinator.showDetail(id:)).\n- VIPER: The Router/Wireframe component handles navigation for its module. Cross-module navigation is coordinated by a top-level router.\n- TCA: Navigation state is part of the app state. Deep links dispatch actions that modify navigation state, and the view tree reacts to state changes.\n- SwiftUI NavigationStack: Navigation paths can be represented as arrays of Route values, making deep linking a matter of setting the path array.\n\nChallenges:\n- Maintaining the correct navigation stack during deep links (especially with tab bars and modal presentations).\n- Handling authentication gates — if a deep link targets an authenticated screen, redirect to login first.\n- Testing deep link flows end-to-end.\n- Universal link fallback when the app isn't installed (redirect to App Store or web)."
  },
  {
    "topic": "architecture",
    "level": 4,
    "question": "What is micro-features architecture, and how does it differ from standard modular architecture? How do you handle inter-feature communication?",
    "hint": "Think about each feature being fully self-contained with its own interface, implementation, and test targets — and features communicating only through well-defined contracts.",
    "answer": "Micro-features architecture (popularized by Tuist) takes modular architecture further by making each feature a fully autonomous unit with standardized internal structure.\n\nStandard modular architecture vs micro-features:\n\nStandard modular: Feature modules may share a common structure but it's not enforced. Dependencies between features can be direct.\n\nMicro-features: Each feature is split into multiple targets:\n- FeatureInterface: A lightweight module containing only protocols, public models, and the feature's API. No implementation.\n- Feature: The implementation module — views, view models, coordinators, services. Depends on its own FeatureInterface.\n- FeatureTesting: Mocks and stubs for the feature's interface, used by other features' tests.\n- FeatureTests: Unit and integration tests for the implementation.\n- FeatureExample: A standalone app target that runs the feature in isolation for development and UI testing.\n\nInter-feature communication:\n\n1. Dependency on interfaces only: Feature A depends on FeatureBInterface, never on FeatureB directly. This prevents transitive dependency bloat and circular dependencies.\n\n2. Dependency injection at composition root: The App target is the only place that knows about all concrete implementations. It wires FeatureBInterface to FeatureB's concrete implementation.\n\n3. Event bus or notification-based: Features publish domain events. Other features subscribe to events they care about. Useful for cross-cutting concerns like analytics.\n\n4. Coordinator/router contracts: Navigation between features is handled through route definitions in the interface module. A central router resolves routes to concrete screens.\n\nBenefits:\n- Features compile independently and fast.\n- Example apps enable rapid development and demo.\n- New developers can work on a feature without understanding the whole app.\n- Clear dependency graph prevents architectural erosion.\n- Features can be extracted into separate apps or SDKs.\n\nChallenges:\n- Significant initial setup and tooling (Tuist helps automate this).\n- Interface design requires careful thought upfront.\n- Shared state across features needs explicit coordination.\n- More targets mean more configuration management."
  },
  {
    "topic": "architecture",
    "level": 4,
    "question": "How would you design a plugin architecture for an iOS application? What are the trade-offs compared to static feature composition?",
    "hint": "Think about dynamically loading features at runtime, defining a stable host API that plugins conform to, and the limitations Apple imposes on dynamic code loading.",
    "answer": "A plugin architecture allows features to be added, removed, or updated independently of the host application through a well-defined extension mechanism.\n\nDesign approach for iOS:\n\n1. Define a plugin protocol:\nprotocol AppPlugin {\n    var identifier: String { get }\n    var name: String { get }\n    func initialize(with context: PluginContext)\n    func viewController() -> UIViewController\n    func handleDeepLink(_ url: URL) -> Bool\n}\n\n2. Plugin context: The host provides a PluginContext with access to shared services (networking, auth, analytics, navigation) that plugins can use.\n\n3. Plugin registry: A central PluginManager discovers, registers, and manages plugin lifecycle.\nclass PluginManager {\n    func register(_ plugin: AppPlugin)\n    func plugin(for identifier: String) -> AppPlugin?\n    func allPlugins() -> [AppPlugin]\n}\n\n4. Static plugin loading (practical for iOS): Since Apple restricts dynamic code loading (no dlopen for App Store apps), plugins are compiled into the app as separate modules/frameworks.\n- Each plugin is an SPM package or framework conforming to the plugin protocol.\n- The app's composition root registers all plugins at launch.\n- Feature flags can enable/disable plugins without code changes.\n\n5. Dynamic configuration: While code is static, plugin behavior can be dynamic through remote config — enabling/disabling features, ordering menu items, or adjusting plugin-specific settings.\n\nTrade-offs vs static composition:\n\nPlugin architecture pros:\n- Standardized feature integration pattern.\n- Features are truly independent — each has a uniform interface.\n- Easy to enable/disable features via configuration.\n- Onboarding new features follows a template.\n\nPlugin architecture cons:\n- Performance overhead from indirection and protocol dispatch.\n- Plugin API must be stable — changing it requires updating all plugins.\n- Deep integration between features is harder (everything goes through the plugin context).\n- Over-engineering risk for apps with tightly coupled features.\n- Apple's restrictions prevent true runtime plugin loading for App Store apps (unlike macOS where bundles can be loaded dynamically).\n\nStatic composition pros:\n- Simpler, direct integration. Compile-time safety.\n- Better performance — no dynamic dispatch overhead.\n- IDE support (refactoring, find usages) works seamlessly.\n\nPlugin architecture is best suited for apps with many loosely-coupled features, especially in large organizations where different teams own different plugins."
  },
  {
    "topic": "architecture",
    "level": 4,
    "question": "How does event-driven architecture work in an iOS application? Compare notification-based, delegate-based, and reactive (Combine) approaches for inter-component communication.",
    "hint": "Consider the trade-offs in coupling, type safety, discoverability, memory management, and debugging across these three approaches.",
    "answer": "Event-driven architecture structures the app around events (significant occurrences) that components emit and react to, rather than direct method calls.\n\nThree approaches in iOS:\n\n1. NotificationCenter (notification-based):\n- Publishers post notifications with optional userInfo dictionaries.\n- Observers register for specific notification names.\n- Pros: Fully decoupled — publisher and observer don't know about each other. Works across any layer. Good for app-wide events (user logged out, theme changed).\n- Cons: No type safety — userInfo is [AnyHashable: Any]. Easy to misspell notification names. Hard to trace data flow. No compile-time guarantee that anyone is listening. Memory leaks if observers aren't removed (pre-iOS 9 or with block-based observers).\n\n2. Delegation (delegate-based):\n- A protocol defines the events a component can emit.\n- The consumer sets itself as the delegate.\n- Pros: Type-safe. Clear contract. Easy to discover via protocol conformance. One-to-one relationship is explicit.\n- Cons: Only supports one observer (one-to-one). Can lead to large delegate protocols (violates ISP). Tight coupling between two specific components (though through a protocol). Weak delegate references require careful memory management.\n\n3. Combine (reactive streams):\n- Publishers (PassthroughSubject, CurrentValueSubject, @Published) emit typed values.\n- Subscribers use sink, assign, or other operators to react.\n- Pros: Type-safe. Supports one-to-many. Rich operator set for transformation, filtering, debouncing, combining. Backpressure support. Integrates with SwiftUI. Compose complex event chains declaratively.\n- Cons: Learning curve. Debugging publisher chains is non-trivial. Subscription management (storing AnyCancellables). Potential for memory leaks with strong reference captures. Overhead for simple use cases.\n\nComparison matrix:\n\n| Aspect | Notification | Delegate | Combine |\n|---|---|---|---|\n| Coupling | None | Low (protocol) | Low (publisher) |\n| Type safety | None | Full | Full |\n| Cardinality | Many-to-many | One-to-one | One-to-many |\n| Discoverability | Poor | Good | Moderate |\n| Debugging | Difficult | Easy | Moderate |\n| Memory | Manual removal | Weak refs | Cancellables |\n\nBest practices:\n- Use Combine for data streams and reactive UI updates.\n- Use delegates for close parent-child relationships (e.g., a custom component reporting to its owner).\n- Use NotificationCenter sparingly for truly app-wide, fire-and-forget events.\n- Modern approach: AsyncSequence / AsyncStream from Swift Concurrency as an alternative to Combine for async event streams."
  },
  {
    "topic": "architecture",
    "level": 4,
    "question": "Explain the dependency rule in Clean Architecture. What happens when you need the inner layer to trigger something in the outer layer, and how do you resolve this without violating the rule?",
    "hint": "The inner layer defines a protocol (port), and the outer layer provides the implementation (adapter). The dependency still points inward.",
    "answer": "The dependency rule states that source code dependencies must only point inward — outer layers can depend on inner layers, but inner layers must never reference anything in outer layers.\n\nLayers (inner to outer):\n1. Entities (domain models and core business rules)\n2. Use Cases (application-specific business logic)\n3. Interface Adapters (presenters, controllers, gateways)\n4. Frameworks & Drivers (UI, database, network, external services)\n\nThe problem:\nA Use Case needs to persist data (which requires Core Data, an outer layer) or present results (which requires UIKit, another outer layer). If the Use Case imports Core Data, the dependency rule is violated.\n\nThe solution — Dependency Inversion Principle:\n\n1. The inner layer defines a protocol (port) describing what it needs:\n// In Use Cases layer\nprotocol OrderRepository {\n    func save(_ order: Order) async throws\n    func fetch(id: String) async throws -> Order\n}\n\n2. The outer layer provides a concrete implementation (adapter):\n// In Frameworks layer\nclass CoreDataOrderRepository: OrderRepository {\n    func save(_ order: Order) async throws { /* Core Data logic */ }\n    func fetch(id: String) async throws -> Order { /* Core Data logic */ }\n}\n\n3. At the composition root (app startup), the concrete implementation is injected:\nlet useCase = PlaceOrderUseCase(repository: CoreDataOrderRepository())\n\nThe same applies to presentation:\n// In Use Cases layer\nprotocol OrderPresenterOutput {\n    func presentOrderConfirmation(_ order: Order)\n}\n\n// In Interface Adapters layer\nclass OrderPresenter: OrderPresenterOutput {\n    func presentOrderConfirmation(_ order: Order) { /* format and update view */ }\n}\n\nWhy this works:\n- The Use Case layer defines the protocol, so it owns the abstraction.\n- The Frameworks layer depends on the Use Case layer (by conforming to its protocol).\n- The dependency arrow points inward: Frameworks → Use Cases → Entities.\n- The Use Case doesn't know about Core Data, UIKit, or any framework.\n\nThis enables:\n- Swapping Core Data for Realm without touching any Use Case code.\n- Testing Use Cases with in-memory mock repositories.\n- Running business logic in a playground or command-line tool without UIKit.\n\nCommon violation to watch for:\nImporting Foundation or UIKit types in entity/use case layers. Even using URL or Date from Foundation can create framework coupling. Purists use their own domain types, though pragmatically most iOS teams accept Foundation as a 'language-level' dependency."
  },
  {
    "topic": "architecture",
    "level": 5,
    "question": "How would you architect a large-scale iOS application (50+ developers, 100+ features) to maximize build performance, team autonomy, and code quality? Discuss module boundaries, dependency graphs, CI implications, and governance.",
    "hint": "Think about the full stack: code organization, build system, CI pipeline design, dependency governance, and how architectural decisions affect developer experience at scale.",
    "answer": "Architecting at this scale requires decisions across multiple dimensions:\n\n1. Module Strategy:\n- Adopt micro-features architecture with strict layering: FeatureInterface, Feature, FeatureTesting, FeatureTests, FeatureExample.\n- Use a dependency graph where features only depend on other features' Interface modules, never their implementations.\n- Shared layers: DesignSystem (UI components), Core (domain models, shared protocols), Networking, Analytics, Auth.\n- Enforce a maximum module depth (e.g., no more than 3 transitive dependencies between any feature and Core) to prevent deep dependency chains.\n\n2. Dependency Graph Governance:\n- Use Tuist or a custom tool to generate and visualize the dependency graph.\n- Implement CI checks that reject PRs introducing circular dependencies or violating layering rules.\n- Define module ownership in a CODEOWNERS file — each module has a designated team.\n- Create an Architecture Decision Record (ADR) process for new module proposals.\n- Regularly audit the dependency graph for unnecessary coupling.\n\n3. Build Performance:\n- With 100+ modules, build times depend on the critical path in the dependency graph. Keep the graph wide and shallow.\n- Use binary caching (Tuist's cache or custom solutions) to avoid recompiling unchanged modules.\n- CI runs only tests for affected modules (determine via dependency graph + git diff).\n- Prebuilt frameworks for stable shared modules (DesignSystem, Networking) distributed via artifact storage.\n- Xcode's explicit module builds and mergeable libraries (introduced in Xcode 15) can improve link times.\n\n4. CI/CD Pipeline:\n- Tiered pipeline: fast lint/compile check (< 5 min), unit tests for affected modules (< 15 min), full integration tests (< 30 min), UI tests (nightly).\n- Feature-level example apps enable isolated testing without building the entire app.\n- Trunk-based development with feature flags. Short-lived branches merge to main frequently.\n- Merge queue to serialize merges and prevent broken main.\n\n5. Team Autonomy:\n- Feature teams own their modules end-to-end: code, tests, CI configuration, documentation.\n- Platform team owns shared modules, build infrastructure, and architectural tooling.\n- Interface changes require cross-team review (enforced via CODEOWNERS on Interface modules).\n- Internal SDK versioning for shared modules — teams can pin to stable versions while upgrades are rolled out.\n\n6. Code Quality:\n- Shared SwiftLint configuration distributed as a module.\n- Automated architecture tests (e.g., no UIKit imports in domain layers, no direct feature-to-feature dependencies).\n- Module-level code coverage thresholds enforced in CI.\n- Shared testing utilities in a TestSupport module (mock factories, assertion helpers).\n\n7. Navigation:\n- Centralized route registry where each feature registers its routes during app launch.\n- Features expose navigation contracts through their Interface module.\n- A NavigationCoordinator at the app level resolves routes to feature screens.\n\n8. State and Data:\n- Features own their local state. Shared state (user session, app configuration) lives in Core modules exposed via protocols.\n- Event bus for cross-feature communication (user updated profile, order placed).\n- Offline-first strategy defined per feature, with shared sync infrastructure.\n\nKey trade-offs:\n- This level of architecture requires significant tooling investment (Tuist, custom CI scripts, dependency graph analysis).\n- Over-modularization creates friction for small changes that span many modules.\n- Developer onboarding is harder — new developers need to understand the module system, not just the code.\n- The architecture itself must be actively maintained — it degrades without governance.\n\nSuccess metrics: module build time p95, time from PR to merge, cross-module dependency count, test coverage per module, developer satisfaction surveys."
  },
  {
    "topic": "architecture",
    "level": 5,
    "question": "Compare Clean Swift (VIP), VIPER, and TCA in depth. When would you choose each, and what are the hidden costs of each approach at scale?",
    "hint": "Consider boilerplate, testability, team onboarding, refactoring cost, SwiftUI compatibility, state management complexity, and how each handles side effects.",
    "answer": "Deep comparison of three heavyweight iOS architectures:\n\nClean Swift (VIP):\n- Cycle: ViewController → Interactor → Presenter → ViewController.\n- Each scene has: ViewController, Interactor, Presenter, Worker, Models (Request/Response/ViewModel), Router.\n- State: Distributed across ViewController (display state) and Interactor (business state).\n- Side effects: Workers handle async operations, return results to Interactor.\n- Testing: Each component is testable via protocol spies. Test the boundary between each component.\n- Boilerplate: High. Each scene requires 6-8 files. Templates (Xcode or Sourcery) are essential.\n- Hidden costs at scale: Template drift — teams customize templates differently, leading to inconsistency. The unidirectional cycle makes simple data passing verbose. Renaming a field requires changes across Request, Response, ViewModel, and all three components. SwiftUI compatibility is awkward — the pattern was designed for UIKit.\n\nVIPER:\n- Components: View, Interactor, Presenter, Entity, Router.\n- Data flow: View ↔ Presenter ↔ Interactor, Router for navigation.\n- State: Interactor holds business state, Presenter holds view-ready state.\n- Side effects: Interactor manages async work directly or via service objects.\n- Testing: Each component testable via protocols. Presenter tests are the most valuable.\n- Boilerplate: Very high. 5+ files per module, each with a protocol and implementation.\n- Hidden costs at scale: Protocol explosion — each module defines 5+ protocols. Navigating the codebase requires jumping between many files. The pattern doesn't prescribe state management, leading to inconsistent approaches across teams. Reactive bindings between Presenter and View are manual (or require Combine integration that isn't part of the original pattern). New developers often struggle with the indirection.\n\nTCA:\n- Components: State, Action, Reducer, Store, View.\n- Data flow: Strictly unidirectional. View → Action → Reducer → State → View.\n- State: Centralized in a single State struct per feature. Composable via parent-child scoping.\n- Side effects: Explicitly modeled as Effect values returned from the Reducer. Fully controlled and testable.\n- Testing: TestStore provides exhaustive assertion API. Every state change and effect must be accounted for.\n- Boilerplate: Moderate but different — fewer files, but Actions and Reducers can grow large.\n- Hidden costs at scale: Steep learning curve. Debugging complex reducer compositions requires understanding the library internals. Performance tuning is necessary — fine-grained scoping is critical to prevent unnecessary view updates. Library coupling — your architecture is tied to a third-party library. Major TCA version updates (0.x → 1.0) required significant migration effort. SwiftUI-first — UIKit integration is possible but not natural.\n\nWhen to choose each:\n\nClean Swift: When the team comes from an enterprise background comfortable with codegen templates. When working with UIKit in a large, established codebase. When you want strict separation without a third-party library dependency.\n\nVIPER: When building a modular app where each feature/module is developed by a different team. When navigation logic is complex and must be isolated. When the team has experience with the pattern. Best for UIKit-based projects.\n\nTCA: When building a new SwiftUI-first application. When state management complexity is the primary challenge. When the team values exhaustive testing and deterministic behavior. When you want opinionated, consistent architecture enforced by the framework itself.\n\nPerformance considerations:\n- VIP and VIPER have minimal runtime overhead — they're just architectural organization.\n- TCA has measurable overhead from store observation, view store subscriptions, and effect management. Profiling is necessary for scroll-heavy or animation-heavy features.\n\nMigration cost:\n- VIP → VIPER: Moderate (similar concepts, different wiring).\n- VIP/VIPER → TCA: High (fundamental paradigm shift from imperative to declarative state management).\n- TCA → anything else: Very high (deep library coupling)."
  },
  {
    "topic": "architecture",
    "level": 5,
    "question": "How does the Single Responsibility Principle apply specifically to ViewModels in MVVM? What are the signs a ViewModel has too many responsibilities, and how do you refactor it?",
    "hint": "Think about ViewModels that handle data fetching, input validation, formatting, navigation, analytics, error handling, and pagination all at once.",
    "answer": "A ViewModel should have one reason to change: the presentation logic for a specific view. When it takes on additional responsibilities, it becomes a 'Massive ViewModel' — the same problem as Massive View Controller, just relocated.\n\nSigns of an overloaded ViewModel:\n1. Line count exceeding 300-400 lines.\n2. Multiple unrelated @Published properties (user data, form validation, network state, pagination, analytics).\n3. The ViewModel imports frameworks it shouldn't (UIKit, CoreLocation, StoreKit).\n4. It coordinates multiple unrelated data flows.\n5. Changing one feature (e.g., pagination) risks breaking another (e.g., form validation).\n6. It's difficult to write focused unit tests — tests require extensive setup for unrelated dependencies.\n7. Multiple developers frequently have merge conflicts in the same ViewModel file.\n\nRefactoring strategies:\n\n1. Extract Use Cases / Interactors:\nBefore: ViewModel calls APIService, parses response, maps to display model.\nAfter: FetchOrdersUseCase handles the orchestration. ViewModel calls useCase.execute() and maps the result.\n\n2. Extract sub-ViewModels:\nA complex screen (e.g., profile with editable fields, order history, settings) can have:\n- ProfileHeaderViewModel (display name, avatar)\n- OrderHistoryViewModel (fetch/paginate orders)\n- ProfileSettingsViewModel (toggle preferences)\nThe parent ProfileViewModel composes these or the View directly owns multiple ViewModels.\n\n3. Extract formatting into dedicated Formatters:\nBefore: ViewModel has dateString, priceString, addressString computed properties with formatting logic.\nAfter: OrderFormatter, PriceFormatter, AddressFormatter are injected or used as static utilities.\n\n4. Extract navigation into a Coordinator:\nBefore: ViewModel has showDetail(), showFilter(), navigateToCheckout() methods that call router methods and track navigation state.\nAfter: ViewModel exposes navigation intents (onItemSelected, onFilterTapped). The Coordinator observes and handles navigation.\n\n5. Extract analytics into a dedicated tracker:\nBefore: ViewModel calls analyticsService.track() in multiple methods.\nAfter: A ScreenAnalyticsTracker observes ViewModel events and handles tracking. Or use middleware in a reactive pipeline.\n\n6. Extract pagination into a reusable PaginationHandler:\nBefore: ViewModel manages currentPage, isLoadingMore, hasNextPage, loadMore().\nAfter: Generic Paginator<Item> handles pagination logic. ViewModel delegates to it.\n\n7. Extract validation into a Validator:\nBefore: ViewModel has isEmailValid, isPasswordStrong, isFormValid computed properties.\nAfter: FormValidator or field-specific validators encapsulate rules.\n\nAfter refactoring, the ViewModel's role becomes:\n- Composing sub-components (use cases, formatters, validators).\n- Exposing @Published state for the View to observe.\n- Translating user actions into use case calls.\n- Mapping use case results to view state.\n\nThe ViewModel should read like a table of contents for the feature — you can see what happens, but the details live elsewhere.\n\nTesting improvement:\n- Before: Tests require mocking 5+ dependencies for a single test case.\n- After: Each extracted component has focused tests. ViewModel tests verify orchestration with stubbed components."
  },
  {
    "topic": "architecture",
    "level": 5,
    "question": "Describe how you would implement Clean Architecture with the dependency rule strictly enforced in an SPM-based modular iOS project. Show the package structure and explain how you handle cross-cutting concerns like logging and analytics.",
    "hint": "Think about which SPM package owns each protocol, which owns each implementation, and how the composition root wires them. Cross-cutting concerns need special treatment to avoid violating the dependency rule.",
    "answer": "Package structure for a strictly layered Clean Architecture:\n\n1. Domain package (innermost layer):\n- Contains: Entity structs, Use Case protocols, Repository protocols, Domain errors.\n- Dependencies: None (zero external imports, minimal Foundation usage).\n- Example types: User, Order, FetchOrdersUseCase (protocol), OrderRepository (protocol).\n\n2. UseCases package:\n- Contains: Concrete Use Case implementations.\n- Dependencies: Domain package only.\n- Example: DefaultFetchOrdersUseCase: FetchOrdersUseCase — calls OrderRepository.fetch() defined in Domain.\n\n3. DataLayer package:\n- Contains: Concrete Repository implementations, API models (DTOs), mappers (DTO → Entity), persistence implementations.\n- Dependencies: Domain package (to conform to repository protocols), NetworkingInterface.\n- Example: APIOrderRepository: OrderRepository — uses NetworkClient to fetch, maps OrderDTO → Order.\n\n4. NetworkingInterface package:\n- Contains: NetworkClient protocol, Request/Response types.\n- Dependencies: None.\n\n5. Networking package:\n- Contains: URLSession-based NetworkClient implementation.\n- Dependencies: NetworkingInterface.\n\n6. Presentation package:\n- Contains: ViewModels, view state types, formatters.\n- Dependencies: Domain package (uses Use Case protocols).\n\n7. UI package:\n- Contains: SwiftUI Views, UIKit ViewControllers.\n- Dependencies: Presentation package.\n\n8. App package (composition root):\n- Contains: AppDelegate/App entry point, DI container setup, all wiring.\n- Dependencies: All packages. This is the only package that sees concrete implementations.\n\nSPM Package.swift for Domain:\nlet package = Package(\n    name: \"Domain\",\n    products: [.library(name: \"Domain\", targets: [\"Domain\"])],\n    targets: [.target(name: \"Domain\", dependencies: [])]\n)\n\nCross-cutting concerns (logging, analytics):\n\nThe challenge: Logging and analytics are needed everywhere, but they're implementation details (outer layer). Inner layers cannot depend on them directly.\n\nSolution 1 — Protocol in Domain, implementation in Infrastructure:\n// In Domain:\nprotocol Logger { func log(_ message: String, level: LogLevel) }\nprotocol AnalyticsTracker { func track(_ event: AnalyticsEvent) }\n\n// In Infrastructure:\nclass OSLogLogger: Logger { ... }\nclass FirebaseAnalyticsTracker: AnalyticsTracker { ... }\n\nUse Cases accept Logger as an injected dependency. The composition root provides the concrete implementation.\n\nSolution 2 — Decorator pattern:\nWrap use cases with logging/analytics decorators at the composition root:\nclass LoggingFetchOrdersUseCase: FetchOrdersUseCase {\n    private let wrapped: FetchOrdersUseCase\n    private let logger: Logger\n    func execute() async throws -> [Order] {\n        logger.log(\"Fetching orders...\", level: .info)\n        let result = try await wrapped.execute()\n        logger.log(\"Fetched \\(result.count) orders\", level: .info)\n        return result\n    }\n}\n\nWiring at composition root:\nlet useCase = LoggingFetchOrdersUseCase(\n    wrapped: DefaultFetchOrdersUseCase(repository: apiOrderRepo),\n    logger: osLogLogger\n)\n\nThis keeps the real Use Case completely unaware of logging.\n\nSolution 3 — Middleware / Interceptor:\nFor analytics, use a middleware layer that intercepts actions or events:\nclass AnalyticsMiddleware {\n    func intercept<T>(_ action: String, work: () async throws -> T) async rethrows -> T {\n        tracker.track(.actionStarted(action))\n        let result = try await work()\n        tracker.track(.actionCompleted(action))\n        return result\n    }\n}\n\nEnforcement:\n- SPM's dependency declarations make violations a compile error. If Domain doesn't list Networking as a dependency, it cannot import it.\n- CI can verify no package adds unauthorized dependencies.\n- The dependency graph is: App → [UI, Presentation, DataLayer, Networking, UseCases, Domain]. UI → Presentation → Domain. DataLayer → Domain + NetworkingInterface. Networking → NetworkingInterface.\n- No horizontal dependencies between DataLayer and Presentation — they only share Domain."
  },
  {
    "topic": "architecture",
    "level": 2,
    "question": "How does the Interface Segregation Principle apply to protocol design in Swift? Give an example of a protocol that violates it and show how to refactor it.",
    "hint": "Think about a large protocol that forces conforming types to implement methods they don't need, and how splitting it into smaller protocols fixes this.",
    "answer": "The Interface Segregation Principle (ISP) states that no client should be forced to depend on methods it does not use. In Swift, this directly applies to protocol design.\n\nViolation example:\nprotocol DataManager {\n    func fetchUsers() async throws -> [User]\n    func saveUser(_ user: User) async throws\n    func deleteUser(id: String) async throws\n    func fetchOrders() async throws -> [Order]\n    func saveOrder(_ order: Order) async throws\n    func deleteOrder(id: String) async throws\n    func uploadImage(_ data: Data) async throws -> URL\n    func clearCache()\n}\n\nProblems:\n- A UserListViewModel only needs fetchUsers(), but it depends on the entire DataManager protocol with 8 methods.\n- A MockDataManager for testing must implement all 8 methods, even if the test only exercises one.\n- Changes to order-related methods force recompilation of user-related code.\n- Adding new entity types keeps bloating this single protocol.\n\nRefactored with ISP:\nprotocol UserFetching {\n    func fetchUsers() async throws -> [User]\n}\n\nprotocol UserPersisting {\n    func saveUser(_ user: User) async throws\n    func deleteUser(id: String) async throws\n}\n\nprotocol OrderFetching {\n    func fetchOrders() async throws -> [Order]\n}\n\nprotocol OrderPersisting {\n    func saveOrder(_ order: Order) async throws\n    func deleteOrder(id: String) async throws\n}\n\nprotocol ImageUploading {\n    func uploadImage(_ data: Data) async throws -> URL\n}\n\nprotocol CacheManaging {\n    func clearCache()\n}\n\nNow each consumer depends only on what it uses:\nclass UserListViewModel {\n    let userFetcher: UserFetching\n    init(userFetcher: UserFetching) { self.userFetcher = userFetcher }\n}\n\nThe concrete implementation can still conform to all protocols:\nclass DefaultDataManager: UserFetching, UserPersisting, OrderFetching, OrderPersisting, ImageUploading, CacheManaging { ... }\n\nBenefits:\n- Focused dependencies: Each consumer declares exactly what it needs.\n- Easier mocking: Test doubles only implement the relevant protocol.\n- Better discoverability: Protocol names communicate intent.\n- Reduced recompilation: Changes to OrderPersisting don't affect UserListViewModel.\n- Protocol composition: Functions can require exactly the capabilities they need — func sync(fetcher: UserFetching & OrderFetching).\n\nSwift-specific consideration: Protocol composition with & is a powerful tool for ISP. You can combine small protocols ad hoc without creating new named protocols for every combination."
  },
  {
    "topic": "di",
    "level": 0,
    "question": "What is dependency injection, and why is it important in iOS development?",
    "hint": "Think about what happens when a class creates its own dependencies internally versus receiving them from the outside.",
    "answer": "Dependency injection (DI) is a design pattern where an object receives its dependencies from external sources rather than creating them internally.\n\nWithout DI:\nclass OrderViewModel {\n    let service = OrderAPIService() // Creates its own dependency\n}\n\nWith DI:\nclass OrderViewModel {\n    let service: OrderServiceProtocol\n    init(service: OrderServiceProtocol) { self.service = service } // Receives dependency\n}\n\nWhy it matters in iOS:\n\n1. Testability: Without DI, OrderViewModel is permanently tied to OrderAPIService, meaning unit tests would make real network calls. With DI, you inject a MockOrderService that returns predefined data.\n\n2. Flexibility: You can swap implementations without modifying the class. Use a real API service in production and a local JSON service during development.\n\n3. Separation of concerns: The class focuses on its own logic rather than knowing how to construct its dependencies.\n\n4. Reusability: The same ViewModel can work with different service implementations in different contexts (e.g., different data sources for different regions).\n\n5. Single Responsibility: The responsibility of creating and configuring dependencies moves to a dedicated place (composition root or DI container), keeping each class focused.\n\nThe three main forms of DI in iOS are:\n- Constructor (initializer) injection: Dependencies passed via init.\n- Property injection: Dependencies set as properties after initialization.\n- Method injection: Dependencies passed as function parameters."
  },
  {
    "topic": "di",
    "level": 0,
    "question": "What is the difference between constructor injection, property injection, and method injection? When would you use each?",
    "hint": "Consider which approach guarantees the dependency is available from the moment the object is created versus which allows it to be set or changed later.",
    "answer": "The three forms of dependency injection differ in when and how dependencies are provided:\n\n1. Constructor (Initializer) Injection:\nDependencies are passed through the initializer.\nclass OrderViewModel {\n    let service: OrderServiceProtocol\n    init(service: OrderServiceProtocol) { self.service = service }\n}\nPros: Guarantees the object is fully configured from creation. Dependencies can be let constants (immutable). Clear contract — you see all dependencies in the init signature.\nCons: Long parameter lists for objects with many dependencies. Can't use with types that require parameter-less init (e.g., some UIKit/storyboard patterns).\nWhen to use: This should be the default choice. Use it for required dependencies that the object needs to function.\n\n2. Property Injection:\nDependencies are set on properties after initialization.\nclass OrderViewModel {\n    var service: OrderServiceProtocol!\n}\nlet vm = OrderViewModel()\nvm.service = OrderAPIService()\nPros: Works with storyboard-instantiated ViewControllers that require init?(coder:). Allows optional or reconfigurable dependencies.\nCons: Object can exist in an invalid state (before the property is set). Requires force-unwrapped optionals or optional handling. Less obvious what dependencies are required.\nWhen to use: When constructor injection isn't possible (storyboard VCs), or for optional, reconfigurable dependencies.\n\n3. Method Injection:\nDependencies are passed as parameters to specific methods.\nfunc processOrder(using service: PaymentServiceProtocol) { ... }\nPros: Useful when a dependency is only needed for a specific operation. Different callers can provide different implementations per call.\nCons: Caller must provide the dependency every time. Not suitable for dependencies used across multiple methods.\nWhen to use: When a dependency varies per operation or is only needed by one method.\n\nBest practice in iOS: Prefer constructor injection as the default. Use property injection for UIKit/storyboard constraints. Use method injection for operation-specific dependencies."
  },
  {
    "topic": "di",
    "level": 1,
    "question": "What is the Service Locator pattern, and why is it sometimes considered an anti-pattern compared to dependency injection?",
    "hint": "Think about a global registry that any class can ask for dependencies versus explicitly declaring what a class needs in its initializer.",
    "answer": "The Service Locator pattern provides a centralized registry (the locator) where objects look up their dependencies at runtime.\n\nExample:\nclass ServiceLocator {\n    static let shared = ServiceLocator()\n    private var services: [String: Any] = [:]\n    func register<T>(_ service: T) { services[String(describing: T.self)] = service }\n    func resolve<T>() -> T { services[String(describing: T.self)] as! T }\n}\n\n// Usage\nclass OrderViewModel {\n    let service: OrderServiceProtocol = ServiceLocator.shared.resolve()\n}\n\nWhy it's considered an anti-pattern:\n\n1. Hidden dependencies: The class's initializer doesn't reveal what it needs. You must read the implementation to discover dependencies. With constructor injection, init(service: OrderServiceProtocol) makes dependencies explicit.\n\n2. Runtime failures: If a service isn't registered, the app crashes at runtime. Constructor injection catches missing dependencies at compile time.\n\n3. Testing difficulty: Tests must set up the global ServiceLocator state before each test and tear it down after. Tests can interfere with each other if the locator isn't properly reset. With DI, you just pass mock objects directly.\n\n4. Tight coupling to the locator: Every class depends on ServiceLocator.shared, making it a god object. Removing or refactoring it affects the entire codebase.\n\n5. Violates Dependency Inversion: The class actively seeks its dependencies rather than having them provided. It depends on a concrete mechanism (the locator) rather than receiving abstractions.\n\nWhen Service Locator can be acceptable:\n- Legacy codebases where refactoring to constructor injection is impractical.\n- Framework code where the consumer doesn't control object creation.\n- As an implementation detail inside a DI container (the container itself is a service locator, but consumers use constructor injection).\n\nKey distinction: A DI container and a Service Locator can use the same underlying mechanism. The difference is in usage — if objects reach into the container themselves, it's Service Locator. If the container injects dependencies into objects from outside, it's DI."
  },
  {
    "topic": "di",
    "level": 1,
    "question": "How does the @Environment property wrapper in SwiftUI relate to dependency injection?",
    "hint": "Consider how @Environment lets you read values from the view hierarchy without passing them explicitly through every view's initializer.",
    "answer": "@Environment in SwiftUI is a built-in form of dependency injection that allows views to read values provided by ancestor views in the hierarchy.\n\nHow it works:\n1. A parent view injects a value: .environment(\\.colorScheme, .dark)\n2. Any descendant view reads it: @Environment(\\.colorScheme) var colorScheme\n3. The value propagates automatically through the view tree without manual passing.\n\nAs dependency injection:\n- It's a form of ambient context / environment-based injection.\n- Dependencies don't appear in the view's initializer — they're pulled from the environment.\n- SwiftUI provides many built-in environment values (colorScheme, locale, dismiss, openURL).\n\nCustom environment values:\n// Define the key\nstruct UserServiceKey: EnvironmentKey {\n    static let defaultValue: UserServiceProtocol = DefaultUserService()\n}\n\n// Extend EnvironmentValues\nextension EnvironmentValues {\n    var userService: UserServiceProtocol {\n        get { self[UserServiceKey.self] }\n        set { self[UserServiceKey.self] = newValue }\n    }\n}\n\n// Inject in parent\nContentView().environment(\\.userService, MockUserService())\n\n// Consume in child\n@Environment(\\.userService) var userService\n\nThis is excellent for SwiftUI previews and testing — inject mock services at the top of the view tree.\n\nComparison with constructor injection:\n- Pros: No need to pass dependencies through every intermediate view. Clean view initializers. SwiftUI-native approach.\n- Cons: Dependencies are implicit (not visible in the initializer). Forgetting to inject a value silently falls back to the default. Discovering which environment values a view depends on requires reading its implementation.\n\n@Environment is analogous to React's Context API. It's DI for the view layer, complementing constructor injection used in the model/service layer."
  },
  {
    "topic": "di",
    "level": 1,
    "question": "How do protocol-based dependencies improve testability in iOS apps?",
    "hint": "Think about defining a protocol for a service and then creating both a real implementation and a mock implementation that conforms to the same protocol.",
    "answer": "Protocol-based dependencies allow you to define an abstract contract that both production and test implementations can fulfill.\n\nExample:\nprotocol WeatherServiceProtocol {\n    func fetchForecast(for city: String) async throws -> Forecast\n}\n\n// Production implementation\nclass APIWeatherService: WeatherServiceProtocol {\n    func fetchForecast(for city: String) async throws -> Forecast {\n        // Real network call\n    }\n}\n\n// Test mock\nclass MockWeatherService: WeatherServiceProtocol {\n    var forecastToReturn: Forecast?\n    var errorToThrow: Error?\n    var fetchCallCount = 0\n    var lastRequestedCity: String?\n\n    func fetchForecast(for city: String) async throws -> Forecast {\n        fetchCallCount += 1\n        lastRequestedCity = city\n        if let error = errorToThrow { throw error }\n        return forecastToReturn!\n    }\n}\n\nTesting the ViewModel:\nfunc testFetchForecastSuccess() async {\n    let mock = MockWeatherService()\n    mock.forecastToReturn = Forecast(temperature: 22, condition: .sunny)\n    let viewModel = WeatherViewModel(service: mock)\n    \n    await viewModel.loadForecast(city: \"London\")\n    \n    XCTAssertEqual(mock.lastRequestedCity, \"London\")\n    XCTAssertEqual(viewModel.temperature, \"22 degrees\")\n}\n\nHow protocols improve testability:\n\n1. Isolation: The ViewModel is tested without network, database, or any real infrastructure.\n2. Determinism: Mock returns exactly what you configure — no flaky tests due to network conditions.\n3. Speed: No I/O means tests run in milliseconds.\n4. Error testing: Easily simulate failures by setting errorToThrow.\n5. Behavior verification: Track call counts and arguments to verify the ViewModel calls the service correctly.\n6. Edge cases: Return empty data, malformed data, or boundary values impossible to reproduce with a real service.\n\nBest practices:\n- Define protocols with only the methods the consumer needs (Interface Segregation).\n- Keep mock classes simple — only add tracking properties you actually assert on.\n- Consider using libraries like Mockingbird or swift-macro-testing to auto-generate mocks.\n- In SwiftUI previews, inject mock services to show specific UI states."
  },
  {
    "topic": "di",
    "level": 2,
    "question": "Compare popular DI containers in the iOS ecosystem: Swinject, Factory, and swift-dependencies. What are the trade-offs of each?",
    "hint": "Consider registration style (runtime vs compile-time), type safety, SwiftUI integration, and how each handles scoping.",
    "answer": "Three popular DI solutions for iOS, each with a different philosophy:\n\n1. Swinject:\n- Style: Runtime container with explicit registration and resolution.\n- Registration: container.register(UserServiceProtocol.self) { _ in APIUserService() }\n- Resolution: let service = container.resolve(UserServiceProtocol.self)!\n- Scoping: .transient (new instance each time), .container (singleton within container), .graph (shared during a single resolve chain).\n- Pros: Mature, well-documented, supports auto-registration via SwinjectAutoregistration. Powerful scoping and assembly pattern for organizing registrations.\n- Cons: Runtime resolution means missing registrations crash at runtime, not compile time. Force unwrapping on resolve. Configuration is imperative and can be error-prone.\n- Best for: Large UIKit apps with complex dependency graphs.\n\n2. Factory (by Michael Long):\n- Style: Compile-time safe containers using Swift's type system.\n- Registration: extension Container { var userService: Factory<UserServiceProtocol> { self { APIUserService() }.singleton } }\n- Resolution: @Injected(\\.userService) var userService\n- Scoping: .singleton, .cached, .shared, .unique (transient), custom scopes.\n- Pros: Type-safe — if it compiles, it resolves. SwiftUI-friendly with @Injected property wrapper. Easy to override in tests and previews. Minimal boilerplate.\n- Cons: All registrations must be in Container extensions (can become large). Less flexible than runtime containers for complex dynamic scenarios.\n- Best for: Modern Swift/SwiftUI apps wanting type safety and simplicity.\n\n3. swift-dependencies (by Point-Free):\n- Style: Environment-based, inspired by SwiftUI's @Environment.\n- Registration: extension DependencyValues { var userService: UserServiceProtocol { ... } }\n- Resolution: @Dependency(\\.userService) var userService\n- Scoping: withDependencies { $0.userService = MockUserService() } operation: { ... }\n- Pros: Deeply integrated with TCA. Test dependencies automatically fail if not overridden (catches missing mocks). Context-based scoping.\n- Cons: Strongly tied to the Point-Free ecosystem. Less intuitive for developers not familiar with TCA. Can feel magical due to task-local value propagation.\n- Best for: TCA-based apps or apps wanting strict test discipline.\n\nTrade-off summary:\n| Aspect | Swinject | Factory | swift-dependencies |\n|---|---|---|---|\n| Type safety | Runtime | Compile-time | Compile-time |\n| SwiftUI | Manual | @Injected | @Dependency |\n| Testing | Reset container | Override factories | withDependencies |\n| Learning curve | Low | Low | Medium |\n| Ecosystem | Standalone | Standalone | Point-Free/TCA |"
  },
  {
    "topic": "di",
    "level": 2,
    "question": "Explain the @Inject property wrapper pattern for dependency injection. How would you implement one, and what are its advantages?",
    "hint": "Think about a property wrapper that automatically resolves a dependency from a container when the property is first accessed.",
    "answer": "The @Inject property wrapper is a pattern that provides a clean, declarative syntax for resolving dependencies from a DI container.\n\nBasic implementation:\n@propertyWrapper\nstruct Inject<T> {\n    private var service: T\n\n    init() {\n        self.service = DependencyContainer.shared.resolve()\n    }\n\n    var wrappedValue: T {\n        get { service }\n        mutating set { service = newValue }\n    }\n}\n\nWith lazy resolution:\n@propertyWrapper\nstruct Inject<T> {\n    private lazy var service: T = DependencyContainer.shared.resolve()\n\n    var wrappedValue: T {\n        mutating get { service }\n        mutating set { service = newValue }\n    }\n}\n\nUsage:\nclass OrderViewModel {\n    @Inject var orderService: OrderServiceProtocol\n    @Inject var analyticsService: AnalyticsServiceProtocol\n\n    func placeOrder() async {\n        let result = await orderService.place(currentOrder)\n        analyticsService.track(.orderPlaced)\n    }\n}\n\nAdvantages:\n1. Clean syntax: Dependencies are declared at the property level with minimal boilerplate.\n2. Self-documenting: It's clear which properties are injected dependencies.\n3. No init bloat: You don't need a large initializer parameter list when a class has many dependencies.\n4. Consistent pattern: Every team member uses the same mechanism for dependency declaration.\n5. Easy to override: In tests, you can register mock implementations in the container before creating the object.\n\nDisadvantages:\n1. Hidden dependencies: Like Service Locator, the init signature doesn't reveal dependencies. You must inspect the class body.\n2. Container coupling: The property wrapper depends on a global container (DependencyContainer.shared), which is essentially a service locator under the hood.\n3. Testing setup: Tests must configure the global container, which can lead to test pollution if not properly reset.\n4. Runtime resolution: Missing registrations cause runtime crashes.\n5. Order of initialization: In Swift, property wrappers initialize before the containing type's init runs, which can cause issues if the container setup depends on the init.\n\nLibraries like Factory and Swinject provide their own @Injected/@Inject wrappers with better safety guarantees.\n\nBest practice: Use @Inject for convenience in the app layer, but prefer constructor injection in core business logic where explicitness and testability matter most."
  },
  {
    "topic": "di",
    "level": 2,
    "question": "What is the Factory pattern in the context of dependency injection? How does it differ from a simple constructor call?",
    "hint": "Think about when you need to create multiple instances of a dependency on demand rather than receiving a single pre-built instance.",
    "answer": "The Factory pattern in DI provides a way to create instances on demand rather than injecting a pre-built instance.\n\nThe problem:\nConstructor injection provides a single instance at initialization time. But what if you need to create multiple instances dynamically? For example, a ViewController that creates a new child ViewModel each time a user adds an item.\n\nWithout Factory:\nclass OrderListViewModel {\n    func createDetailViewModel(for order: Order) -> OrderDetailViewModel {\n        // This creates a concrete dependency — tightly coupled!\n        return OrderDetailViewModel(order: order, service: APIOrderService())\n    }\n}\n\nWith Factory:\ntypealias OrderDetailViewModelFactory = (Order) -> OrderDetailViewModel\n\nclass OrderListViewModel {\n    private let makeDetailViewModel: OrderDetailViewModelFactory\n\n    init(makeDetailViewModel: @escaping OrderDetailViewModelFactory) {\n        self.makeDetailViewModel = makeDetailViewModel\n    }\n\n    func showDetail(for order: Order) {\n        let detailVM = makeDetailViewModel(order)\n        // Use detailVM\n    }\n}\n\n// At composition root:\nlet listVM = OrderListViewModel(makeDetailViewModel: { order in\n    OrderDetailViewModel(order: order, service: apiOrderService)\n})\n\nAdvantages:\n1. Deferred creation: Objects are created when needed, not upfront.\n2. Parameterized creation: The factory can accept runtime parameters (like the Order) that aren't available at injection time.\n3. Testability: In tests, inject a factory that returns mock ViewModels:\nlet listVM = OrderListViewModel(makeDetailViewModel: { order in\n    MockOrderDetailViewModel(order: order)\n})\n4. Decoupling: The list ViewModel doesn't know how to construct a detail ViewModel or what dependencies it needs.\n\nFactory protocol approach:\nprotocol OrderDetailViewModelFactory {\n    func make(order: Order) -> OrderDetailViewModel\n}\n\nclass DefaultOrderDetailViewModelFactory: OrderDetailViewModelFactory {\n    private let service: OrderServiceProtocol\n    init(service: OrderServiceProtocol) { self.service = service }\n    func make(order: Order) -> OrderDetailViewModel {\n        OrderDetailViewModel(order: order, service: service)\n    }\n}\n\nThis is particularly useful when:\n- Creating items in a list (each cell needs its own ViewModel).\n- Navigating to screens with runtime parameters.\n- The created object has its own complex dependency graph.\n- You need to create instances asynchronously or lazily."
  },
  {
    "topic": "di",
    "level": 3,
    "question": "How do you manage dependency scopes (singleton, transient, per-request) in an iOS app? What problems arise from incorrect scoping?",
    "hint": "Think about the lifecycle of each dependency — some should live forever, some should be created fresh each time, and some should be shared within a specific operation or screen.",
    "answer": "Dependency scoping controls the lifecycle and sharing of resolved instances.\n\nCommon scopes:\n\n1. Singleton (.container scope): One instance for the entire app lifetime.\n- Use for: Stateless services (NetworkClient, AnalyticsTracker), shared configuration, caches.\n- Example: A single URLSession-based NetworkService shared by all features.\n- Risk: Unintended state sharing. If a singleton accumulates state, it becomes global mutable state.\n\n2. Transient (.unique scope): A new instance every time it's resolved.\n- Use for: ViewModels, stateful objects, anything tied to a specific screen or operation.\n- Example: Each OrderDetailScreen gets its own OrderDetailViewModel.\n- Risk: Creating expensive objects repeatedly can waste memory and CPU.\n\n3. Per-request / Per-graph: One instance shared within a single object graph resolution, but new instances across different resolutions.\n- Use for: Objects that should be shared within one feature but not across features. A database transaction context shared by multiple repositories during one operation.\n- Example: A single CoreData managed object context shared by all repositories for one user action.\n\n4. Per-screen / Scoped: Instance lives as long as a specific scope (often tied to a Coordinator or navigation flow).\n- Use for: State that should persist within a flow but reset when the user starts a new flow.\n- Example: A CheckoutState shared by shipping, payment, and review screens within the checkout flow, but fresh for each new checkout.\n\nProblems from incorrect scoping:\n\n1. Singleton that should be transient:\n- A ViewModel registered as singleton means all screens share the same state. User sees stale data from a previous screen.\n- Memory leaks — the singleton retains references to things that should be deallocated.\n\n2. Transient that should be singleton:\n- Multiple NetworkService instances each create their own URLSession, wasting resources.\n- Multiple instances of a cache means data isn't shared, defeating the purpose.\n\n3. Retain cycles with scoped dependencies:\n- A parent scope holds a child scope object that references back to a parent scope object. Strong references prevent deallocation.\n\n4. Thread safety:\n- Singletons accessed from multiple threads must be thread-safe. A singleton data store without synchronization causes race conditions.\n\nBest practices:\n- Default to transient — only use singleton when explicitly needed.\n- Document the intended scope for each dependency.\n- Use weak references for scope-crossing references.\n- Verify scoping in tests by checking object identity (=== for reference types).\n- Audit singletons periodically — each one is global state."
  },
  {
    "topic": "di",
    "level": 3,
    "question": "How would you set up dependency injection in a modular iOS app where each feature module has its own dependencies?",
    "hint": "Think about each module registering its own dependencies, a shared module defining common protocols, and the app module composing everything together.",
    "answer": "DI in modular apps requires careful architecture to maintain module independence while enabling composition.\n\nStructure:\n\n1. Core/Shared module: Contains protocol definitions shared across modules.\n- UserServiceProtocol, OrderServiceProtocol, AnalyticsTrackerProtocol\n- Does NOT contain implementations.\n\n2. Feature modules: Each feature depends on protocols from Core, not on other feature modules.\n- HomeFeature depends on UserServiceProtocol and ProductServiceProtocol (from Core).\n- OrderFeature depends on OrderServiceProtocol and PaymentServiceProtocol (from Core).\n\n3. Infrastructure modules: Contain concrete implementations.\n- NetworkingModule implements APIUserService: UserServiceProtocol.\n- PersistenceModule implements CoreDataOrderRepository: OrderRepositoryProtocol.\n\n4. App module (composition root): The only module that knows about all concrete implementations. Wires everything together.\n\nRegistration approach:\n\nOption A — Module assemblies:\nEach module provides an Assembly (Swinject) or Container extension (Factory) that registers its internal dependencies.\n\n// In HomeFeature module:\npublic struct HomeAssembly: Assembly {\n    public func assemble(container: Container) {\n        container.register(HomeViewModel.self) { r in\n            HomeViewModel(userService: r.resolve(UserServiceProtocol.self)!)\n        }\n    }\n}\n\n// In App module:\nlet container = Container()\nNetworkingAssembly().assemble(container: container)\nHomeAssembly().assemble(container: container)\nOrderAssembly().assemble(container: container)\n\nOption B — Module entry points:\nEach module exposes a factory function or builder that accepts its external dependencies.\n\n// In HomeFeature module:\npublic struct HomeModuleBuilder {\n    public static func build(userService: UserServiceProtocol) -> UIViewController {\n        let vm = HomeViewModel(userService: userService)\n        return HomeViewController(viewModel: vm)\n    }\n}\n\n// In App module:\nlet homeVC = HomeModuleBuilder.build(userService: apiUserService)\n\nOption B is simpler, more explicit, and doesn't require a DI framework. Option A scales better for modules with many internal dependencies.\n\nHandling cross-module dependencies:\n- Feature A needs to navigate to Feature B: Define a navigation protocol in Core (e.g., OrderFlowLauncher). Feature B's module provides the implementation. The App module registers it.\n- Shared state: A UserSession singleton registered in the App module, accessible via protocol across all features.\n\nBest practices:\n- Never let a feature module resolve dependencies from a global container. Pass them explicitly.\n- Keep the Core module lightweight — only protocols and models.\n- Use feature-specific protocols (HomeDataProviding) rather than exposing entire service APIs to features that only need a subset.\n- Test each module independently by providing mock implementations of its external dependency protocols."
  },
  {
    "topic": "di",
    "level": 4,
    "question": "How do you resolve circular dependencies in iOS, and what strategies exist to prevent them in the first place?",
    "hint": "Consider the case where ServiceA depends on ServiceB and ServiceB depends on ServiceA. Think about property injection, lazy resolution, protocol splitting, and architectural solutions.",
    "answer": "Circular dependencies occur when two or more objects depend on each other, creating a cycle that makes construction impossible with simple constructor injection.\n\nExample: AuthService needs NetworkService (to add auth headers), and NetworkService needs AuthService (to refresh expired tokens).\n\nResolution strategies:\n\n1. Property injection (break the cycle):\nlet networkService = NetworkService()\nlet authService = AuthService(networkService: networkService)\nnetworkService.authService = authService // Set after construction\n\nPros: Simple. Works immediately.\nCons: NetworkService has a temporarily invalid state (no authService until set). Requires a mutable optional property.\n\n2. Lazy resolution:\nclass NetworkService {\n    private let authServiceProvider: () -> AuthServiceProtocol\n    lazy var authService: AuthServiceProtocol = authServiceProvider()\n    init(authServiceProvider: @escaping () -> AuthServiceProtocol) {\n        self.authServiceProvider = authServiceProvider\n    }\n}\n\nThe closure defers resolution until first access, breaking the cycle at construction time.\n\n3. Protocol splitting (eliminate the cycle):\nThe circular dependency often signals a design problem. Split the protocols:\n\nprotocol TokenProvider { func currentToken() -> String? }\nprotocol TokenRefresher { func refreshToken() async throws -> String }\n\nAuthService conforms to both TokenProvider and TokenRefresher.\nNetworkService depends only on TokenProvider (not all of AuthService).\nA separate TokenRefreshInterceptor depends on TokenRefresher.\n\nThis often reveals that the original circular dependency was between responsibilities, not between the actual objects.\n\n4. Mediator / Event-based:\nIntroduce a third object that mediates:\nclass AuthTokenMediator {\n    var onTokenExpired: (() -> Void)?\n    var onTokenRefreshed: ((String) -> Void)?\n}\n\nNetworkService calls onTokenExpired. AuthService listens and calls onTokenRefreshed. Neither depends on the other.\n\n5. DI container scope resolution:\nSwinject's .graph scope handles circular dependencies:\ncontainer.register(NetworkServiceProtocol.self) { r in\n    let service = NetworkService()\n    service.authService = r.resolve(AuthServiceProtocol.self)\n    return service\n}.inObjectScope(.graph)\n\nThe .graph scope ensures the same instance is reused within a single resolve chain, handling the cycle.\n\nPrevention strategies:\n- Follow the Dependency Inversion Principle: Depend on abstractions.\n- Apply Interface Segregation: Split large interfaces so objects depend only on what they need.\n- Use unidirectional dependency graphs: Higher-level modules depend on lower-level modules, never the reverse.\n- Introduce mediators or event systems for cross-cutting communication.\n- Regularly visualize the dependency graph (tools like Xcode's module dependency graph or custom scripts).\n\nA circular dependency is almost always a design smell. Before resolving it technically, ask whether the architecture should be restructured to eliminate it."
  },
  {
    "topic": "di",
    "level": 4,
    "question": "Explain compile-time versus runtime dependency injection safety in Swift. How can you achieve compile-time guarantees that all dependencies are satisfied?",
    "hint": "Think about how Swinject's resolve() can return nil at runtime, while approaches like Factory or manual constructor injection fail to compile if a dependency is missing.",
    "answer": "The fundamental distinction is whether a missing or misconfigured dependency is caught by the compiler or discovered by a crash at runtime.\n\nRuntime DI (e.g., Swinject):\nlet service = container.resolve(UserServiceProtocol.self)!\n\n- If UserServiceProtocol was never registered, this force-unwrap crashes at runtime.\n- The compiler has no way to verify that all registrations match all resolutions.\n- You might discover missing registrations only in specific user flows that are hard to test.\n- Mitigations: Integration tests that resolve all dependencies at startup. Swinject's SwinjectStoryboard has some validation. But none of these are compile-time guarantees.\n\nCompile-time DI approaches:\n\n1. Manual constructor injection:\nThe most straightforward compile-time safe approach.\nlet networkService = URLSessionNetworkService()\nlet userRepository = APIUserRepository(network: networkService)\nlet userViewModel = UserViewModel(repository: userRepository)\n\nIf you forget to pass a dependency, the code won't compile. If a protocol has no conforming type, you get a compiler error.\n\nPros: Maximum safety. No framework needed. Clear and traceable.\nCons: The composition root becomes large and manual. Adding a dependency requires updating the wiring code.\n\n2. Factory library:\nextension Container {\n    var userService: Factory<UserServiceProtocol> {\n        self { APIUserService() }\n    }\n}\n@Injected(\\.userService) var userService\n\nIf the factory closure doesn't return the correct type, it won't compile. If you reference a non-existent keypath (e.g., \\.nonExistent), the compiler catches it.\n\n3. swift-dependencies:\n@Dependency(\\.userService) var userService\n\nThe dependency must be defined in DependencyValues. If it's missing, the code won't compile. In tests, unoverridden dependencies trigger XCTest failures (not crashes), providing test-time safety.\n\n4. Environment-based (SwiftUI):\n@Environment(\\.userService) var userService\n\nCompile-time safe for the key path. However, if you forget to inject the value in the view hierarchy, it silently uses the default value, which might not be what you want.\n\n5. Code generation:\nTools like Needle (by Uber) or Weaver analyze your dependency graph at compile time and generate the wiring code. If a dependency is missing, the generated code won't compile.\n\nNeedle approach:\nclass UserComponent: Component<UserDependency> {\n    var userService: UserServiceProtocol { shared { APIUserService() } }\n}\nprotocol UserDependency: Dependency {\n    var networkService: NetworkServiceProtocol { get } // Must be provided by parent\n}\n\nThe code generator verifies that every Dependency protocol requirement is satisfied by a parent Component in the hierarchy.\n\nRecommendation:\n- For small to medium apps: Manual constructor injection or Factory.\n- For large apps with many developers: Needle or similar compile-time verified frameworks.\n- Avoid runtime-only DI containers without comprehensive integration tests.\n- Hybrid approach: Use a DI container for convenience, but add a startup-time validation step that resolves all registered types and fails fast during development."
  },
  {
    "topic": "di",
    "level": 4,
    "question": "How do you effectively use dependency injection to facilitate testing in iOS? Walk through swapping real implementations with test doubles.",
    "hint": "Think about the different types of test doubles (mocks, stubs, fakes, spies) and how DI enables each. Consider both unit tests and SwiftUI previews.",
    "answer": "DI enables testing by allowing you to replace real implementations with controlled test doubles at every level.\n\nTypes of test doubles:\n\n1. Stub: Returns predetermined data. No verification of how it was called.\nclass StubUserService: UserServiceProtocol {\n    func fetchUser(id: String) async throws -> User {\n        User(name: \"Test User\", email: \"test@example.com\")\n    }\n}\n\n2. Mock: Verifies interactions — was the method called? With what arguments? How many times?\nclass MockAnalyticsTracker: AnalyticsTrackerProtocol {\n    var trackedEvents: [AnalyticsEvent] = []\n    func track(_ event: AnalyticsEvent) {\n        trackedEvents.append(event)\n    }\n}\n// Assert: XCTAssertEqual(mock.trackedEvents, [.screenViewed(\"Home\"), .buttonTapped(\"Buy\")])\n\n3. Spy: Wraps the real implementation, recording calls while still executing real behavior.\nclass SpyNetworkService: NetworkServiceProtocol {\n    let real: NetworkServiceProtocol\n    var requestLog: [URLRequest] = []\n    func execute(_ request: URLRequest) async throws -> Data {\n        requestLog.append(request)\n        return try await real.execute(request)\n    }\n}\n\n4. Fake: A working implementation with simplified behavior (e.g., in-memory database instead of Core Data).\nclass FakeUserRepository: UserRepositoryProtocol {\n    private var storage: [String: User] = [:]\n    func save(_ user: User) { storage[user.id] = user }\n    func fetch(id: String) -> User? { storage[id] }\n}\n\nSwapping in unit tests:\nfunc testPlaceOrderSuccess() async {\n    // Arrange\n    let stubService = StubOrderService(result: .success(Order.mock))\n    let mockTracker = MockAnalyticsTracker()\n    let viewModel = OrderViewModel(\n        orderService: stubService,\n        analyticsTracker: mockTracker\n    )\n\n    // Act\n    await viewModel.placeOrder()\n\n    // Assert\n    XCTAssertEqual(viewModel.state, .confirmed)\n    XCTAssertEqual(mockTracker.trackedEvents.count, 1)\n    XCTAssertEqual(mockTracker.trackedEvents.first, .orderPlaced)\n}\n\nSwapping for error scenarios:\nfunc testPlaceOrderNetworkFailure() async {\n    let failingService = StubOrderService(result: .failure(NetworkError.timeout))\n    let viewModel = OrderViewModel(orderService: failingService, analyticsTracker: MockAnalyticsTracker())\n\n    await viewModel.placeOrder()\n\n    XCTAssertEqual(viewModel.state, .error(\"Connection timed out\"))\n}\n\nSwapping in SwiftUI Previews:\n#Preview {\n    OrderView(viewModel: OrderViewModel(\n        orderService: StubOrderService(result: .success(.mock)),\n        analyticsTracker: MockAnalyticsTracker()\n    ))\n}\n\nUsing DI containers in tests:\n\nWith Factory:\nContainer.shared.orderService.register { StubOrderService() }\nlet viewModel = OrderViewModel() // @Injected picks up the override\n\nWith swift-dependencies:\nwithDependencies {\n    $0.orderService = .mock\n} operation: {\n    let viewModel = OrderViewModel()\n    // Test...\n}\n\nBest practices:\n- Create a TestSupport module/target with shared mocks and stubs.\n- Use protocols with minimal surface area — easier to mock.\n- Reset DI container state in setUp/tearDown to prevent test pollution.\n- Prefer constructor injection for unit-testable code (explicit dependencies).\n- Use container-based injection for integration tests and previews.\n- Consider Sourcery or Swift macros for auto-generating mock implementations from protocols."
  },
  {
    "topic": "di",
    "level": 5,
    "question": "Design a complete dependency injection system for a large-scale modular iOS app. Address container hierarchy, scope management, thread safety, module isolation, and migration strategy from a legacy codebase.",
    "hint": "Think about parent-child containers, per-feature scopes, thread-safe resolution, how modules register without knowing about each other, and how to incrementally adopt DI in a codebase that currently uses singletons.",
    "answer": "Comprehensive DI system design for a large-scale app:\n\n1. Container Hierarchy:\n\nRoot Container (App-level):\n- Holds global singletons: NetworkClient, AuthManager, AnalyticsTracker, FeatureFlagService.\n- Created at app launch, lives for the entire app lifecycle.\n- Thread-safe (all resolutions go through a concurrent queue with barrier writes).\n\nFeature Containers (per-feature):\n- Child containers that inherit from Root. Can resolve anything from Root but also have feature-specific registrations.\n- Created when a feature flow starts, deallocated when the flow ends.\n- Example: CheckoutContainer holds CheckoutState, PaymentProcessor, ShippingCalculator.\n\nScreen Containers (per-screen):\n- Child of Feature Container. Holds screen-specific dependencies like ViewModels.\n- Created per screen instantiation. Shortest lifecycle.\n\nImplementation:\nclass DIContainer {\n    private let parent: DIContainer?\n    private var factories: [ObjectIdentifier: (DIContainer) -> Any] = [:]\n    private var singletons: [ObjectIdentifier: Any] = [:]\n    private let lock = NSRecursiveLock()\n\n    init(parent: DIContainer? = nil) { self.parent = parent }\n\n    func register<T>(_ type: T.Type, scope: Scope = .transient, factory: @escaping (DIContainer) -> T) {\n        lock.lock(); defer { lock.unlock() }\n        let key = ObjectIdentifier(type)\n        switch scope {\n        case .singleton:\n            factories[key] = { [weak self] container in\n                if let existing = self?.singletons[key] { return existing }\n                let instance = factory(container)\n                self?.singletons[key] = instance\n                return instance\n            }\n        case .transient:\n            factories[key] = factory\n        }\n    }\n\n    func resolve<T>(_ type: T.Type) -> T {\n        lock.lock(); defer { lock.unlock() }\n        let key = ObjectIdentifier(type)\n        if let factory = factories[key] { return factory(self) as! T }\n        guard let parent = parent else { fatalError(\"No registration for \\(type)\") }\n        return parent.resolve(type)\n    }\n}\n\n2. Module Registration:\n\nEach module provides a ModuleAssembly protocol conformance:\npublic protocol ModuleAssembly {\n    func registerPublicDependencies(in container: DIContainer)\n    func registerInternalDependencies(in container: DIContainer)\n}\n\nPublic dependencies: Things the module provides to others (conformances to protocols defined in Core).\nInternal dependencies: Things the module uses internally (ViewModels, Coordinators).\n\nThe App module discovers and invokes all assemblies:\nlet assemblies: [ModuleAssembly] = [\n    NetworkingAssembly(), AuthAssembly(), HomeAssembly(), OrderAssembly()\n]\nassemblies.forEach { $0.registerPublicDependencies(in: rootContainer) }\nassemblies.forEach { $0.registerInternalDependencies(in: rootContainer) }\n\nTwo-phase registration ensures all public dependencies are available before internal wiring.\n\n3. Thread Safety:\n- Root container uses NSRecursiveLock (recursive to handle dependencies that resolve other dependencies during construction).\n- Singletons are created under the lock (thread-safe lazy initialization).\n- Feature containers are created and accessed only from the main thread (tied to navigation), avoiding contention.\n- For highly concurrent scenarios, use an actor-based container:\nactor AsyncDIContainer {\n    private var factories: [ObjectIdentifier: (AsyncDIContainer) async -> Any] = [:]\n    func resolve<T>(_ type: T.Type) async -> T { ... }\n}\n\n4. Scope Management:\nenum Scope {\n    case singleton     // Lives forever in the container\n    case transient     // New instance each resolution\n    case scoped(ScopeToken)  // Lives as long as the token\n}\n\nclass ScopeToken {\n    deinit { /* Container cleans up instances associated with this token */ }\n}\n\nFeature Coordinators hold a ScopeToken. When the Coordinator is deallocated (user leaves the flow), all scoped dependencies are cleaned up.\n\n5. Migration Strategy from Legacy Singletons:\n\nPhase 1 — Wrap existing singletons:\nRegister existing singletons in the container without changing their implementation.\ncontainer.register(NetworkManager.self, scope: .singleton) { _ in NetworkManager.shared }\n\nPhase 2 — Extract protocols:\nCreate protocols for existing singletons. Register the protocol, resolving to the existing shared instance.\ncontainer.register(NetworkManaging.self) { _ in NetworkManager.shared }\n\nPhase 3 — Adopt DI in new code:\nNew ViewModels and features use constructor injection with protocols.\n\nPhase 4 — Migrate existing code:\nGradually replace direct singleton access (NetworkManager.shared) with injected dependencies, feature by feature. Prioritize code being actively modified.\n\nPhase 5 — Remove singletons:\nOnce all consumers use DI, convert singletons to regular classes. Remove .shared static properties. The container manages the single-instance lifecycle.\n\nValidation:\n- Debug builds resolve all registered types at launch and assert no failures.\n- CI runs a dependency graph analysis tool that detects circular dependencies, missing registrations, and scope mismatches.\n- Unit tests verify each module's assembly independently.\n\nKey design decisions:\n- Prefer compile-time safety where possible (Factory-style) for new code.\n- Use runtime container for legacy migration path.\n- Never expose the container to feature code — only the composition root and module assemblies interact with it directly.\n- ViewModels receive dependencies via init, never by resolving from a container internally."
  },
  {
    "topic": "di",
    "level": 5,
    "question": "Discuss advanced DI patterns: conditional binding, decorator chains, and AOP (aspect-oriented programming) through DI. How would you implement cross-cutting concerns like logging, caching, and retry logic without polluting business logic?",
    "hint": "Think about wrapping service implementations in decorators registered in the DI container, where each decorator adds one concern (logging, caching, retry) and delegates to the next.",
    "answer": "Advanced DI patterns enable powerful composition without modifying business logic.\n\n1. Conditional Binding:\nResolving different implementations based on runtime conditions.\n\ncontainer.register(PaymentServiceProtocol.self) { _ in\n    if FeatureFlags.isNewPaymentEnabled {\n        return StripePaymentService()\n    } else {\n        return LegacyPaymentService()\n    }\n}\n\nMore sophisticated: Environment-based binding.\ncontainer.register(APIBaseURL.self) { _ in\n    switch Environment.current {\n    case .production: return APIBaseURL(\"https://api.prod.com\")\n    case .staging: return APIBaseURL(\"https://api.staging.com\")\n    case .development: return APIBaseURL(\"https://api.dev.com\")\n    }\n}\n\nPer-user binding (A/B testing):\ncontainer.register(OnboardingFlowProtocol.self) { _ in\n    ABTestService.variant(for: .onboarding) == .newFlow\n        ? NewOnboardingFlow()\n        : ClassicOnboardingFlow()\n}\n\n2. Decorator Chains:\nEach decorator wraps the underlying service, adding one responsibility.\n\nprotocol OrderServiceProtocol {\n    func fetchOrders() async throws -> [Order]\n}\n\n// Base implementation\nclass APIOrderService: OrderServiceProtocol {\n    func fetchOrders() async throws -> [Order] {\n        // Real network call\n    }\n}\n\n// Logging decorator\nclass LoggingOrderService: OrderServiceProtocol {\n    private let wrapped: OrderServiceProtocol\n    private let logger: Logger\n    init(wrapped: OrderServiceProtocol, logger: Logger) {\n        self.wrapped = wrapped\n        self.logger = logger\n    }\n    func fetchOrders() async throws -> [Order] {\n        logger.log(\"Fetching orders...\")\n        let orders = try await wrapped.fetchOrders()\n        logger.log(\"Fetched \\(orders.count) orders\")\n        return orders\n    }\n}\n\n// Caching decorator\nclass CachingOrderService: OrderServiceProtocol {\n    private let wrapped: OrderServiceProtocol\n    private let cache: Cache<[Order]>\n    private let ttl: TimeInterval\n    init(wrapped: OrderServiceProtocol, cache: Cache<[Order]>, ttl: TimeInterval = 300) {\n        self.wrapped = wrapped\n        self.cache = cache\n        self.ttl = ttl\n    }\n    func fetchOrders() async throws -> [Order] {\n        if let cached = cache.get(key: \"orders\"), !cached.isExpired(ttl: ttl) {\n            return cached.value\n        }\n        let orders = try await wrapped.fetchOrders()\n        cache.set(key: \"orders\", value: orders)\n        return orders\n    }\n}\n\n// Retry decorator\nclass RetryingOrderService: OrderServiceProtocol {\n    private let wrapped: OrderServiceProtocol\n    private let maxRetries: Int\n    private let delay: TimeInterval\n    init(wrapped: OrderServiceProtocol, maxRetries: Int = 3, delay: TimeInterval = 1) {\n        self.wrapped = wrapped\n        self.maxRetries = maxRetries\n        self.delay = delay\n    }\n    func fetchOrders() async throws -> [Order] {\n        var lastError: Error?\n        for attempt in 0..<maxRetries {\n            do {\n                return try await wrapped.fetchOrders()\n            } catch {\n                lastError = error\n                if attempt < maxRetries - 1 {\n                    try await Task.sleep(nanoseconds: UInt64(delay * pow(2, Double(attempt)) * 1_000_000_000))\n                }\n            }\n        }\n        throw lastError!\n    }\n}\n\nComposition in DI container:\ncontainer.register(OrderServiceProtocol.self) { r in\n    let base = APIOrderService(network: r.resolve(NetworkClientProtocol.self))\n    let retrying = RetryingOrderService(wrapped: base, maxRetries: 3)\n    let caching = CachingOrderService(wrapped: retrying, cache: r.resolve(Cache.self))\n    let logging = LoggingOrderService(wrapped: caching, logger: r.resolve(Logger.self))\n    return logging\n}\n\nThe call chain: Logging → Caching → Retrying → API.\nThe OrderViewModel has no idea about logging, caching, or retries. It just calls fetchOrders().\n\n3. AOP through DI:\nAspect-Oriented Programming applies cross-cutting concerns without modifying source code.\n\nGeneric interceptor:\nclass ServiceInterceptor<T>: NSObject {\n    let target: T\n    var beforeAdvice: ((String) -> Void)?\n    var afterAdvice: ((String, Any?) -> Void)?\n    var errorAdvice: ((String, Error) -> Void)?\n}\n\nIn practice, Swift's protocol-based design makes the decorator pattern more natural than true AOP (which relies on runtime method interception available in Objective-C via method swizzling but not in Swift).\n\nFor Combine-based services, middleware is another AOP-like approach:\nfunc applyMiddleware<T>(_ publisher: AnyPublisher<T, Error>, operation: String) -> AnyPublisher<T, Error> {\n    publisher\n        .handleEvents(\n            receiveSubscription: { _ in logger.log(\"\\(operation) started\") },\n            receiveOutput: { _ in logger.log(\"\\(operation) succeeded\") },\n            receiveCompletion: { completion in\n                if case .failure(let error) = completion {\n                    logger.log(\"\\(operation) failed: \\(error)\")\n                }\n            }\n        )\n        .retry(3)\n        .eraseToAnyPublisher()\n}\n\nBenefits:\n- Business logic remains pure and focused.\n- Cross-cutting concerns are added/removed by changing container registration, not modifying classes.\n- Each decorator is independently testable.\n- The decorator chain order is meaningful and configurable (e.g., caching before or after retry).\n\nCaveats:\n- Each decorator must conform to the full protocol, even if it only adds behavior to one method.\n- Deep decorator chains can make debugging stack traces harder.\n- Performance overhead from multiple layers of indirection (usually negligible but measurable in hot paths).\n- Protocol changes require updating all decorators."
  },
  {
    "topic": "networking",
    "level": 0,
    "question": "What is URLSession and what are the three main types of tasks it provides?",
    "hint": "Think about the different kinds of network operations: fetching data into memory, saving files to disk, and sending data to a server.",
    "answer": "URLSession is Apple's primary API for making HTTP/HTTPS network requests. It provides three main task types:\n\n1. dataTask — Fetches data into memory as a Data object. Best for small payloads like JSON API responses.\n2. downloadTask — Downloads files to a temporary location on disk. Ideal for large files since it doesn't hold the entire response in memory.\n3. uploadTask — Sends data (file or Data object) to a server, typically with POST or PUT requests.\n\nAll tasks are created in a suspended state and must be resumed by calling task.resume(). URLSession also supports URLSessionWebSocketTask for WebSocket connections."
  },
  {
    "topic": "networking",
    "level": 0,
    "question": "What are the most common HTTP methods and when would you use each one in a REST API?",
    "hint": "Think about CRUD operations — Create, Read, Update, Delete — and how they map to HTTP verbs.",
    "answer": "The most common HTTP methods are:\n\n- GET: Retrieve a resource. Should be idempotent and safe (no side effects). Example: GET /users/123 fetches user with ID 123.\n- POST: Create a new resource. Not idempotent — calling it multiple times may create duplicates. Example: POST /users creates a new user.\n- PUT: Replace an entire resource. Idempotent — calling it multiple times produces the same result. Example: PUT /users/123 replaces user 123.\n- PATCH: Partially update a resource. Only sends the fields that need to change. Example: PATCH /users/123 with {\"name\": \"New Name\"}.\n- DELETE: Remove a resource. Should be idempotent. Example: DELETE /users/123 deletes user 123.\n\nLess common methods include HEAD (like GET but returns only headers), OPTIONS (describes communication options), and CONNECT (establishes a tunnel)."
  },
  {
    "topic": "networking",
    "level": 0,
    "question": "How do you parse a JSON response into a Swift model using Codable?",
    "hint": "Consider the Decodable protocol and JSONDecoder. Think about what happens when JSON keys don't match your property names.",
    "answer": "To parse JSON into Swift models using Codable:\n\n1. Define a struct conforming to Codable (or just Decodable if you only need parsing):\n\nstruct User: Codable {\n    let id: Int\n    let name: String\n    let email: String\n}\n\n2. Use JSONDecoder to decode the Data:\n\nlet decoder = JSONDecoder()\nlet user = try decoder.decode(User.self, from: jsonData)\n\nIf JSON keys use snake_case (e.g., first_name), set decoder.keyDecodingStrategy = .convertFromSnakeCase.\n\nFor custom key mappings, define a CodingKeys enum:\n\nenum CodingKeys: String, CodingKey {\n    case id\n    case name = \"full_name\"\n    case email = \"email_address\"\n}\n\nYou can also handle optional fields by declaring properties as Optional, and provide default values using init(from:) with decodeIfPresent."
  },
  {
    "topic": "networking",
    "level": 1,
    "question": "What are the different URLSessionConfiguration types and when would you use each?",
    "hint": "Think about how sessions handle caching, cookies, and whether data persists between app launches.",
    "answer": "URLSessionConfiguration has three main types:\n\n1. .default — Uses the global cache, cookie, and credential storage. Data is persisted to disk. This is the most common configuration for standard API calls.\n\n2. .ephemeral — Similar to default but stores everything in memory only. Nothing is written to disk — no caches, cookies, or credentials persist. Similar to a private browsing session. Useful for sensitive operations.\n\n3. .background(withIdentifier:) — Allows downloads and uploads to continue even when the app is suspended or terminated. Requires a unique string identifier so the system can reconnect the session. The system manages transfers in a separate process. Completion is delivered via URLSessionDelegate methods or via application(_:handleEventsForBackgroundURLSession:completionHandler:) in the AppDelegate.\n\nAll configurations can be customized with properties like timeoutIntervalForRequest, timeoutIntervalForResource, httpAdditionalHeaders, requestCachePolicy, waitsForConnectivity, and allowsCellularAccess."
  },
  {
    "topic": "networking",
    "level": 1,
    "question": "What are HTTP status codes and what do the main categories (2xx, 3xx, 4xx, 5xx) represent?",
    "hint": "The first digit tells you the general class of the response. Think about success, redirection, client errors, and server errors.",
    "answer": "HTTP status codes are three-digit numbers returned by servers indicating the result of a request:\n\n2xx (Success):\n- 200 OK: Standard success response.\n- 201 Created: Resource was successfully created (common after POST).\n- 204 No Content: Success but no response body (common after DELETE).\n\n3xx (Redirection):\n- 301 Moved Permanently: Resource has a new permanent URL.\n- 304 Not Modified: Cached version is still valid (used with ETags/If-Modified-Since).\n\n4xx (Client Error):\n- 400 Bad Request: Malformed request syntax or invalid parameters.\n- 401 Unauthorized: Authentication is required or has failed.\n- 403 Forbidden: Server understood the request but refuses to authorize it.\n- 404 Not Found: Resource does not exist.\n- 429 Too Many Requests: Rate limiting.\n\n5xx (Server Error):\n- 500 Internal Server Error: Generic server-side failure.\n- 502 Bad Gateway: Server acting as proxy received an invalid response.\n- 503 Service Unavailable: Server is temporarily overloaded or under maintenance.\n\nIn iOS, you cast URLResponse to HTTPURLResponse to access the statusCode property."
  },
  {
    "topic": "networking",
    "level": 1,
    "question": "How does URLCache work and what are the different caching policies available in URLRequest?",
    "hint": "Consider both the client-side cache policy on the request and how the server's Cache-Control headers interact with local caching.",
    "answer": "URLCache provides an in-memory and on-disk cache for URL responses. By default, URLSession.shared uses a shared URLCache instance.\n\nURLRequest.CachePolicy options:\n\n- .useProtocolCachePolicy (default): Follows HTTP caching semantics — respects Cache-Control, Expires, and ETag headers from the server.\n- .reloadIgnoringLocalCacheData: Always fetches from the network, ignoring any cached response.\n- .reloadIgnoringLocalAndRemoteCacheData: Ignores all caches including proxies.\n- .returnCacheDataElseLoad: Uses cache if available regardless of expiration, only hits network if no cache exists.\n- .returnCacheDataDontLoad: Only returns cached data, never hits the network. Fails if no cache exists. Useful for offline mode.\n- .reloadRevalidatingCacheData: Always validates cached response with the server.\n\nYou can configure URLCache size: URLCache(memoryCapacity: 50_000_000, diskCapacity: 100_000_000, directory: cacheURL).\n\nYou can also implement urlSession(_:dataTask:willCacheResponse:completionHandler:) in URLSessionDataDelegate to customize what gets cached per-response."
  },
  {
    "topic": "networking",
    "level": 1,
    "question": "How do you monitor network reachability in iOS using NWPathMonitor?",
    "hint": "Think about the Network framework and how you can observe path changes on a dedicated queue.",
    "answer": "NWPathMonitor from the Network framework provides real-time network status monitoring:\n\nimport Network\n\nlet monitor = NWPathMonitor()\nmonitor.pathUpdateHandler = { path in\n    if path.status == .satisfied {\n        print(\"Connected\")\n    } else {\n        print(\"No connection\")\n    }\n    \n    if path.usesInterfaceType(.wifi) {\n        print(\"Using WiFi\")\n    } else if path.usesInterfaceType(.cellular) {\n        print(\"Using Cellular\")\n    }\n}\nmonitor.start(queue: DispatchQueue(label: \"NetworkMonitor\"))\n\nNWPath.Status values include:\n- .satisfied: Network is available.\n- .unsatisfied: No network connectivity.\n- .requiresConnection: Connection can be established on demand (e.g., VPN).\n\nYou can also create a monitor for a specific interface: NWPathMonitor(requiredInterfaceType: .wifi).\n\nThe path object also provides isExpensive (cellular/hotspot) and isConstrained (Low Data Mode) properties. Always call monitor.cancel() when done to stop monitoring."
  },
  {
    "topic": "networking",
    "level": 2,
    "question": "How would you design a network layer abstraction for an iOS app? What are the key components?",
    "hint": "Think about protocol-oriented design, request building, response parsing, and how to make the layer testable.",
    "answer": "A well-designed network layer typically includes these components:\n\n1. Endpoint/Request Definition — A protocol or enum that defines API endpoints:\nprotocol APIEndpoint {\n    var baseURL: URL { get }\n    var path: String { get }\n    var method: HTTPMethod { get }\n    var headers: [String: String] { get }\n    var body: Encodable? { get }\n}\n\n2. API Client Protocol — Abstracts the networking implementation for testability:\nprotocol APIClient {\n    func request<T: Decodable>(_ endpoint: APIEndpoint) async throws -> T\n}\n\n3. Concrete Implementation — Uses URLSession under the hood:\nfinal class DefaultAPIClient: APIClient {\n    private let session: URLSession\n    private let decoder: JSONDecoder\n    func request<T: Decodable>(_ endpoint: APIEndpoint) async throws -> T { ... }\n}\n\n4. Error Handling — Custom error types mapping HTTP status codes and network failures.\n\n5. Interceptors/Middleware — For adding auth tokens, logging, retry logic.\n\n6. Response Validation — Checking status codes, parsing error responses.\n\nKey design principles: Use protocols for testability (inject mock APIClient in tests), keep endpoint definitions declarative, centralize error mapping, and use async/await or Combine for clean asynchronous code."
  },
  {
    "topic": "networking",
    "level": 2,
    "question": "Explain how certificate pinning works in iOS. What is the difference between pinning a certificate vs a public key?",
    "hint": "Think about what happens during the TLS handshake and which part of the server's certificate you choose to trust.",
    "answer": "Certificate pinning is a security measure where the app validates that the server's certificate matches a known, trusted certificate bundled with the app, rather than relying solely on the system's certificate authority (CA) chain.\n\nCertificate Pinning: You embed the server's exact X.509 certificate (or its hash) in the app bundle. During the TLS handshake, you compare the server's certificate byte-for-byte with the stored one.\n- Pros: Simple to implement.\n- Cons: When the certificate expires and is renewed, you must release an app update with the new certificate. Even if the same key pair is used, the certificate binary changes.\n\nPublic Key Pinning: You extract and pin only the public key (SPKI — Subject Public Key Info) from the certificate.\n- Pros: Certificate renewals that use the same key pair won't break the app. More resilient to rotation.\n- Cons: If the server changes its key pair, an app update is still needed.\n\nImplementation in iOS uses URLSessionDelegate:\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: ...) {\n    guard let serverTrust = challenge.protectionSpace.serverTrust,\n          let serverCert = SecTrustGetCertificateAtIndex(serverTrust, 0) else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n    // Compare certificate or public key data\n}\n\nApple also supports Info.plist-based pinning via NSPinnedDomains under App Transport Security in iOS 14+."
  },
  {
    "topic": "networking",
    "level": 2,
    "question": "What is a background URLSession and how does it differ from a regular session? How do you handle completion when the app is terminated?",
    "hint": "Consider what happens when the system finishes a download while your app is not running. Think about the AppDelegate callback and session reconstruction.",
    "answer": "A background URLSession allows network transfers to continue even when the app is suspended or terminated by the system.\n\nKey differences from regular sessions:\n- Created with URLSessionConfiguration.background(withIdentifier:) using a unique string ID.\n- Transfers are handled by a separate system daemon, not your app process.\n- Only supports upload and download tasks (not data tasks).\n- Completion is delivered via delegate methods, not closures.\n- isDiscretionary can be set to let the system optimize for battery and performance.\n\nHandling completion when app is terminated:\n\n1. The system wakes your app in the background when transfers complete.\n2. AppDelegate receives application(_:handleEventsForBackgroundURLSession:completionHandler:). Store the completionHandler.\n3. Recreate the URLSession with the same identifier — the system reconnects pending tasks.\n4. The delegate receives urlSession(_:downloadTask:didFinishDownloadingTo:) for each completed download.\n5. After all delegate calls, urlSessionDidFinishEvents(forBackgroundURLSession:) is called. Call the stored completionHandler here to tell the system you're done and it can snapshot the UI.\n\nImportant: The session identifier must be unique and consistent across launches. You should create background sessions early in app launch to reconnect to any pending tasks."
  },
  {
    "topic": "networking",
    "level": 2,
    "question": "How do you handle authentication challenges in URLSession using URLSessionDelegate?",
    "hint": "Think about the URLAuthenticationChallenge and the different protection space types like server trust and HTTP basic authentication.",
    "answer": "URLSession delegates handle authentication challenges through the urlSession(_:didReceive:completionHandler:) and urlSession(_:task:didReceive:completionHandler:) methods.\n\nSession-level challenge (urlSession(_:didReceive:completionHandler:)):\nCalled for server-level challenges like TLS certificate validation.\n\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n    let protectionSpace = challenge.protectionSpace\n    \n    switch protectionSpace.authenticationMethod {\n    case NSURLAuthenticationMethodServerTrust:\n        // TLS/SSL validation\n        guard let serverTrust = protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n        // Optionally perform custom trust evaluation (certificate pinning)\n        completionHandler(.useCredential, URLCredential(trust: serverTrust))\n        \n    case NSURLAuthenticationMethodHTTPBasic, NSURLAuthenticationMethodHTTPDigest:\n        // HTTP Basic/Digest auth\n        let credential = URLCredential(user: username, password: password, persistence: .forSession)\n        completionHandler(.useCredential, credential)\n        \n    case NSURLAuthenticationMethodClientCertificate:\n        // Mutual TLS — present client certificate\n        let credential = URLCredential(identity: identity, certificates: [cert], persistence: .forSession)\n        completionHandler(.useCredential, credential)\n        \n    default:\n        completionHandler(.performDefaultHandling, nil)\n    }\n}\n\nDisposition options:\n- .useCredential: Supply credentials and proceed.\n- .performDefaultHandling: Let the system handle it (default trust evaluation).\n- .cancelAuthenticationChallenge: Cancel the request.\n- .rejectProtectionSpace: Reject this auth method, try the next one.\n\nTask-level challenge (urlSession(_:task:didReceive:completionHandler:)) is called for task-specific challenges and takes precedence over session-level for the same task.\n\nCredential persistence options: .none (single request), .forSession (session lifetime), .permanent (stored in Keychain), .synchronizable (synced via iCloud Keychain).\n\nThe previousFailureCount property on the challenge tells you how many times authentication has failed, allowing you to avoid infinite retry loops."
  },
  {
    "topic": "networking",
    "level": 3,
    "question": "How would you implement retry logic with exponential backoff for network requests? What edge cases should you consider?",
    "hint": "Think about which errors are retryable, how to calculate delay, jitter, and maximum retry limits.",
    "answer": "Exponential backoff progressively increases the delay between retries to avoid overwhelming a server.\n\nBasic implementation:\nfunc performRequest<T: Decodable>(endpoint: APIEndpoint, maxRetries: Int = 3) async throws -> T {\n    var attempt = 0\n    while true {\n        do {\n            return try await apiClient.request(endpoint)\n        } catch let error as NetworkError {\n            attempt += 1\n            guard attempt <= maxRetries, error.isRetryable else { throw error }\n            let baseDelay = pow(2.0, Double(attempt)) // 2, 4, 8 seconds\n            let jitter = Double.random(in: 0...1) // Prevent thundering herd\n            let delay = min(baseDelay + jitter, 60) // Cap at 60 seconds\n            try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))\n        }\n    }\n}\n\nRetryable errors typically include:\n- HTTP 429 (Too Many Requests) — respect Retry-After header if present.\n- HTTP 500, 502, 503, 504 — server-side transient failures.\n- URLError.timedOut, .networkConnectionLost, .notConnectedToInternet.\n\nNon-retryable: 400, 401, 403, 404 — these won't succeed on retry.\n\nEdge cases to handle:\n- Idempotency: Only auto-retry idempotent requests (GET, PUT, DELETE). POST retries risk duplicate creation unless the API supports idempotency keys.\n- Retry-After header: Server may specify exact wait time.\n- Circuit breaker pattern: After N consecutive failures, stop retrying entirely for a cooldown period.\n- Task cancellation: Check Task.isCancelled between retries.\n- Maximum total timeout: Cap cumulative retry time, not just per-attempt."
  },
  {
    "topic": "networking",
    "level": 3,
    "question": "How does URLSessionWebSocketTask work and what are the considerations for maintaining a persistent WebSocket connection in iOS?",
    "hint": "Think about the message send/receive loop, ping/pong for keep-alive, and how app lifecycle affects the connection.",
    "answer": "URLSessionWebSocketTask (iOS 13+) provides native WebSocket support:\n\nlet task = URLSession.shared.webSocketTask(with: URL(string: \"wss://example.com/ws\")!)\ntask.resume()\n\n// Sending\ntask.send(.string(\"Hello\")) { error in ... }\ntask.send(.data(binaryData)) { error in ... }\n\n// Receiving — must be called repeatedly for continuous listening\nfunc listen() {\n    task.receive { result in\n        switch result {\n        case .success(let message):\n            switch message {\n            case .string(let text): handleText(text)\n            case .data(let data): handleData(data)\n            }\n            self.listen() // Re-register for next message\n        case .failure(let error): handleError(error)\n        }\n    }\n}\n\n// Ping/Pong keep-alive\ntask.sendPing { error in ... }\n\n// Clean close\ntask.cancel(with: .normalClosure, reason: nil)\n\nKey considerations for persistent connections:\n1. Reconnection logic: Implement automatic reconnection with exponential backoff when the connection drops.\n2. App lifecycle: WebSocket disconnects when the app is suspended. Re-establish on applicationDidBecomeActive. Background URLSession does NOT support WebSocket tasks.\n3. Heartbeat: Send periodic pings to detect dead connections. Servers may close idle connections.\n4. Message queuing: Buffer outgoing messages during reconnection and send them once reconnected.\n5. Thread safety: Receive callbacks happen on the session's delegate queue. Dispatch to main thread for UI updates.\n6. Memory: The receive loop creates a retain cycle if not managed carefully. Use weak self."
  },
  {
    "topic": "networking",
    "level": 3,
    "question": "What is multipart form data upload and how would you implement it with URLSession?",
    "hint": "Think about the Content-Type boundary, how each part is formatted with headers and content, and how the body is assembled.",
    "answer": "Multipart form data is a format for sending mixed content (files, text fields) in a single HTTP request body. Each part is separated by a boundary string.\n\nImplementation:\n\nfunc createMultipartRequest(url: URL, fields: [String: String], fileData: Data, fileName: String, mimeType: String) -> URLRequest {\n    let boundary = UUID().uuidString\n    var request = URLRequest(url: url)\n    request.httpMethod = \"POST\"\n    request.setValue(\"multipart/form-data; boundary=\\(boundary)\", forHTTPHeaderField: \"Content-Type\")\n    \n    var body = Data()\n    \n    // Text fields\n    for (key, value) in fields {\n        body.append(\"--\\(boundary)\\r\\n\")\n        body.append(\"Content-Disposition: form-data; name=\\\"\\(key)\\\"\\r\\n\\r\\n\")\n        body.append(\"\\(value)\\r\\n\")\n    }\n    \n    // File part\n    body.append(\"--\\(boundary)\\r\\n\")\n    body.append(\"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"\\(fileName)\\\"\\r\\n\")\n    body.append(\"Content-Type: \\(mimeType)\\r\\n\\r\\n\")\n    body.append(fileData)\n    body.append(\"\\r\\n\")\n    \n    // Closing boundary\n    body.append(\"--\\(boundary)--\\r\\n\")\n    \n    request.httpBody = body\n    return request\n}\n\nFor large files, use uploadTask(with:fromFile:) to stream from disk instead of loading into memory. You can also implement URLSessionTaskDelegate's urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:) to track upload progress.\n\nKey considerations: Generate a unique boundary that cannot appear in the content, set Content-Length if the server requires it, and handle timeout appropriately for large uploads."
  },
  {
    "topic": "networking",
    "level": 4,
    "question": "Explain the design patterns used in Alamofire and Moya. How do they improve upon raw URLSession, and when might you choose one over the other?",
    "hint": "Think about Alamofire's request chaining and validation, and Moya's enum-based endpoint abstraction using TargetType.",
    "answer": "Alamofire is a networking library built on URLSession that provides a more ergonomic API:\n- Request chaining: AF.request(url).validate().responseDecodable(of: User.self) { response in ... }\n- Automatic validation of status codes and content types.\n- RequestInterceptor protocol for authentication (adapt requests, retry on 401).\n- Built-in parameter encoding (URL, JSON, custom).\n- Upload/download progress tracking.\n- Certificate pinning via ServerTrustManager with per-host evaluation policies.\n- EventMonitor for logging and debugging.\n\nMoya is built on top of Alamofire and adds a higher-level abstraction:\n- TargetType protocol defines endpoints as enum cases:\nenum UserAPI: TargetType {\n    case getUser(id: Int)\n    case createUser(name: String)\n    var baseURL: URL { ... }\n    var path: String { ... }\n    var method: Moya.Method { ... }\n    var task: Task { ... } // .requestPlain, .requestParameters, .uploadMultipart\n}\n- MoyaProvider<UserAPI> handles request execution.\n- Built-in stub responses for testing — no network mocking needed.\n- Plugin system for logging, authentication, activity indicators.\n\nWhen to choose:\n- Use raw URLSession for simple apps or when minimizing dependencies.\n- Use Alamofire when you need interceptors, retry logic, certificate pinning, and cleaner syntax.\n- Use Moya when you want compile-time safe endpoint definitions, built-in testing support, and a clear API contract.\n- For modern Swift with async/await, raw URLSession has closed much of the ergonomic gap."
  },
  {
    "topic": "networking",
    "level": 4,
    "question": "What are the differences between HTTP/1.1, HTTP/2, and HTTP/3? How does iOS handle these protocols?",
    "hint": "Think about multiplexing, header compression, head-of-line blocking, and the transport layer difference in HTTP/3.",
    "answer": "HTTP/1.1:\n- One request-response per TCP connection at a time.\n- Pipelining exists but is rarely used due to head-of-line (HOL) blocking — a slow response blocks all subsequent ones.\n- Multiple parallel connections (typically 6 per host) work around this limitation.\n- Text-based headers sent in full with every request.\n\nHTTP/2:\n- Binary framing layer over a single TCP connection.\n- Multiplexing: Multiple concurrent streams on one connection — no HOL blocking at the HTTP level.\n- Header compression (HPACK) significantly reduces overhead for repeated headers.\n- Server push: Server can proactively send resources (though Apple disabled this in Safari).\n- Stream prioritization: Clients can indicate which resources are more important.\n- Still suffers from TCP-level HOL blocking — if a TCP packet is lost, all streams stall.\n\nHTTP/3:\n- Uses QUIC (UDP-based) instead of TCP.\n- Eliminates TCP HOL blocking — packet loss on one stream doesn't affect others.\n- Built-in TLS 1.3 in the transport layer — faster handshake (0-RTT in some cases).\n- Connection migration: Seamless handoff when switching networks (WiFi to cellular) because connections are identified by connection IDs, not IP/port tuples.\n\niOS support:\n- URLSession automatically negotiates the best available protocol. HTTP/2 has been supported since iOS 9. HTTP/3 support was added in iOS 15 with URLSessionConfiguration.assumesHTTP3Capable. No code changes are needed — the system handles ALPN negotiation. You can check the response's protocol via URLSessionTaskMetrics."
  },
  {
    "topic": "networking",
    "level": 4,
    "question": "How would you implement request and response interceptors in a custom networking layer? What are common use cases?",
    "hint": "Think about the chain-of-responsibility pattern, where each interceptor can modify or observe the request/response pipeline.",
    "answer": "Interceptors are middleware components that can observe or modify requests before they're sent and responses after they're received.\n\nDesign:\nprotocol RequestInterceptor {\n    func intercept(request: URLRequest) async throws -> URLRequest\n}\n\nprotocol ResponseInterceptor {\n    func intercept(response: HTTPURLResponse, data: Data, for request: URLRequest) async throws -> (HTTPURLResponse, Data)\n}\n\nclass InterceptingAPIClient: APIClient {\n    private let session: URLSession\n    private var requestInterceptors: [RequestInterceptor] = []\n    private var responseInterceptors: [ResponseInterceptor] = []\n    \n    func request<T: Decodable>(_ endpoint: APIEndpoint) async throws -> T {\n        var urlRequest = endpoint.toURLRequest()\n        for interceptor in requestInterceptors {\n            urlRequest = try await interceptor.intercept(request: urlRequest)\n        }\n        var (data, response) = try await session.data(for: urlRequest)\n        let httpResponse = response as! HTTPURLResponse\n        for interceptor in responseInterceptors {\n            (_, data) = try await interceptor.intercept(response: httpResponse, data: data, for: urlRequest)\n        }\n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n\nCommon use cases:\n- Authentication: Inject Bearer token into every request; refresh token on 401 and retry.\n- Logging: Log request method, URL, headers, response status, and latency.\n- Analytics: Track API response times and error rates.\n- Caching: Custom cache logic beyond URLCache.\n- Request modification: Add common headers (User-Agent, Accept-Language, device info).\n- Response transformation: Unwrap nested API response envelopes.\n- Mocking: Intercept requests in debug builds to return stub data.\n\nAlamofire's RequestInterceptor protocol (adapt + retry) is a well-known implementation of this pattern."
  },
  {
    "topic": "networking",
    "level": 5,
    "question": "How would you architect a robust offline-first networking layer that handles request queuing, conflict resolution, and eventual consistency?",
    "hint": "Think about local persistence, operation queues, sync strategies, and how to handle merge conflicts when the device reconnects.",
    "answer": "An offline-first architecture prioritizes local data and syncs with the server when connectivity is available.\n\nCore components:\n\n1. Local Storage Layer: Use Core Data or SwiftData as the source of truth. All reads come from local storage. Writes are applied locally first, then synced.\n\n2. Operation Queue: Pending network operations are persisted (not just in memory) so they survive app termination.\nstruct PendingOperation: Codable {\n    let id: UUID\n    let endpoint: APIEndpoint\n    let payload: Data\n    let timestamp: Date\n    let retryCount: Int\n}\nStore in Core Data or SQLite. Process FIFO when connectivity returns.\n\n3. Sync Engine: Monitors NWPathMonitor. When connected, drains the pending operation queue. Uses background URLSession for reliability. Implements idempotency keys to prevent duplicate server-side operations.\n\n4. Conflict Resolution Strategies:\n- Last-write-wins: Simple but can lose data. Use server timestamps.\n- Client-wins or server-wins: Deterministic but one side always loses.\n- Three-way merge: Compare client version, server version, and common ancestor. Merge non-conflicting fields automatically, flag true conflicts for user resolution.\n- CRDTs (Conflict-free Replicated Data Types): For specific data structures (counters, sets) that mathematically guarantee convergence.\n- Vector clocks / version vectors: Track causality across distributed writes.\n\n5. Eventual Consistency: Accept that local and remote data may diverge temporarily. Use ETags or Last-Modified headers for conditional requests. Implement pull-to-refresh and periodic background sync.\n\n6. Delta Sync: Only fetch changes since the last sync token instead of full dataset. Server provides a sync cursor or changelog.\n\n7. Edge cases: Handle operations that depend on server-generated IDs (use temporary local IDs, remap after sync). Handle delete-then-edit conflicts. Implement maximum queue age to discard stale operations."
  },
  {
    "topic": "networking",
    "level": 5,
    "question": "Explain how GraphQL works on iOS. How does its networking differ from REST, and what are the trade-offs for mobile clients?",
    "hint": "Think about query structure, single endpoint, over-fetching, under-fetching, and how code generation tools help with type safety.",
    "answer": "GraphQL is a query language for APIs where clients specify exactly what data they need.\n\nKey differences from REST:\n- Single endpoint: All queries go to one URL (typically POST /graphql) vs REST's multiple resource-specific endpoints.\n- Client-driven queries: The client specifies the shape of the response.\nquery {\n  user(id: 123) {\n    name\n    posts(first: 5) {\n      title\n      commentCount\n    }\n  }\n}\n- No over-fetching: You only get requested fields. REST endpoints often return more data than needed.\n- No under-fetching: A single query can traverse relationships that would require multiple REST calls.\n- Mutations for writes, subscriptions for real-time updates via WebSocket.\n\niOS implementation:\n- Apollo iOS is the primary client. It uses code generation from .graphql schema files to create type-safe Swift models.\n- Apollo provides normalized caching — entities are stored by ID and shared across queries, so updating a User in one query automatically updates it everywhere.\n- Network transport is typically a simple POST with the query string and variables in the JSON body.\n\nTrade-offs for mobile:\nPros: Reduces number of round trips (critical on high-latency cellular). Eliminates over-fetching (saves bandwidth and parsing). Strong typing via code generation.\nCons: HTTP caching is harder — all requests are POST to the same URL, so CDN/URLCache can't easily cache by URL. Persisted queries solve this by using GET with query hashes. Complexity shifts to the client (query construction). Server-side performance risks from deeply nested queries (need query complexity limits). File uploads require multipart specification extension. Binary size overhead from Apollo library and generated code."
  },
  {
    "topic": "networking",
    "level": 5,
    "question": "How does URLSessionTaskMetrics help with network performance analysis, and how would you build a production network monitoring system?",
    "hint": "Think about the detailed timing information in URLSessionTaskTransactionMetrics and how to aggregate this data meaningfully.",
    "answer": "URLSessionTaskMetrics provides detailed timing and protocol information for every network request.\n\nAccess via URLSessionTaskDelegate:\nfunc urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {\n    for transaction in metrics.transactionMetrics {\n        // Timing breakdown\n        transaction.fetchStartDate\n        transaction.domainLookupStartDate / .domainLookupEndDate  // DNS\n        transaction.connectStartDate / .connectEndDate  // TCP\n        transaction.secureConnectionStartDate / .secureConnectionEndDate  // TLS\n        transaction.requestStartDate / .requestEndDate  // Request sent\n        transaction.responseStartDate / .responseEndDate  // TTFB and download\n        \n        // Protocol info\n        transaction.networkProtocolName  // \"h2\", \"h3\", \"http/1.1\"\n        transaction.isReusedConnection\n        transaction.resourceFetchType  // .networkLoad, .localCache, .serverPush\n        transaction.remoteAddress / .remotePort\n    }\n}\n\nProduction monitoring system design:\n\n1. Data Collection: Implement a URLSessionTaskDelegate that captures metrics for every request. Use an interceptor to avoid polluting business logic.\n\n2. Aggregation: Compute per-endpoint statistics: p50/p95/p99 latency, error rates, DNS time, TLS time, TTFB. Track by network type (WiFi vs cellular) and carrier.\n\n3. Anomaly Detection: Flag requests exceeding latency thresholds. Detect DNS resolution failures indicating ISP issues. Monitor connection reuse rate — low reuse suggests configuration problems.\n\n4. Reporting Pipeline: Batch and compress metrics. Send via a separate low-priority URLSession to avoid impacting user-facing requests. Use MetricKit (MXMetricManager) for system-level diagnostics delivered by Apple within 24 hours.\n\n5. Dashboard Metrics: API latency breakdown (DNS, TCP, TLS, TTFB, transfer), error rate by endpoint and status code, cache hit rate, protocol distribution (HTTP/2 vs HTTP/3), payload sizes, retry rates.\n\n6. Alerting: Spike in error rates, latency degradation beyond baseline, certificate expiration warnings from TLS metrics."
  },
  {
    "topic": "security",
    "level": 0,
    "question": "What is the iOS Keychain and why should you use it instead of UserDefaults for storing sensitive data?",
    "hint": "Think about encryption, access control, and what happens to data after the app is deleted.",
    "answer": "The iOS Keychain is a secure, encrypted storage system provided by the operating system for storing small pieces of sensitive data like passwords, tokens, certificates, and cryptographic keys.\n\nWhy Keychain over UserDefaults:\n\n1. Encryption: Keychain data is encrypted using hardware-backed encryption (Secure Enclave on modern devices). UserDefaults stores data as a plain-text plist file that anyone with device access can read.\n\n2. Access Control: Keychain items can be protected with biometrics (Face ID/Touch ID) or device passcode. UserDefaults has no access control.\n\n3. App Sandbox Isolation: Each app can only access its own Keychain items (unless explicitly shared via Keychain Access Groups). UserDefaults is also sandboxed but is not encrypted.\n\n4. Persistence After Deletion: By default, Keychain items persist even after the app is uninstalled (unless configured otherwise with kSecAttrAccessible). UserDefaults is deleted with the app.\n\n5. Sharing Across Apps: Keychain items can be shared between apps from the same developer team using Keychain Access Groups. UserDefaults can only be shared via App Groups.\n\nUse Keychain for: passwords, authentication tokens, API keys, certificates, credit card info.\nUse UserDefaults for: non-sensitive preferences like theme settings, feature flags, onboarding completion status."
  },
  {
    "topic": "security",
    "level": 0,
    "question": "What is App Transport Security (ATS) and why does Apple enforce it?",
    "hint": "Think about what ATS requires for network connections and what happens if you try to use plain HTTP.",
    "answer": "App Transport Security (ATS) is a security feature introduced in iOS 9 that enforces best practices for secure network connections.\n\nATS requirements:\n- All network connections must use HTTPS (not plain HTTP).\n- TLS version must be 1.2 or higher.\n- The server certificate must be signed by a trusted Certificate Authority.\n- The certificate must use at least a 2048-bit RSA key or 256-bit ECC key.\n- The connection must use forward secrecy cipher suites (ECDHE).\n\nIf your app tries to make an HTTP connection, it will fail with an error: \"App Transport Security has blocked a cleartext HTTP resource load.\"\n\nExceptions can be configured in Info.plist under NSAppTransportSecurity:\n- NSAllowsArbitraryLoads: Disables ATS entirely (Apple scrutinizes this during App Review).\n- NSExceptionDomains: Allow specific domains to use HTTP or weaker TLS.\n- NSAllowsLocalNetworking: Permits local network connections without TLS.\n\nWhy Apple enforces it:\n- Prevents man-in-the-middle attacks on unencrypted connections.\n- Ensures data privacy for users by default.\n- Encourages server operators to adopt modern TLS.\n- Protects against downgrade attacks.\n\nApple requires justification in App Store review for any ATS exceptions. Apps should aim for zero exceptions whenever possible."
  },
  {
    "topic": "security",
    "level": 0,
    "question": "What is biometric authentication in iOS and how do you implement basic Face ID / Touch ID using LocalAuthentication?",
    "hint": "Think about the LAContext class and the evaluatePolicy method. Also consider what fallback options exist.",
    "answer": "Biometric authentication allows users to authenticate using Face ID (facial recognition) or Touch ID (fingerprint) via the LocalAuthentication framework.\n\nBasic implementation:\n\nimport LocalAuthentication\n\nfunc authenticateWithBiometrics() {\n    let context = LAContext()\n    var error: NSError?\n    \n    // Check if biometrics are available\n    guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {\n        print(\"Biometrics unavailable: \\(error?.localizedDescription ?? \"\")\")\n        return\n    }\n    \n    // Perform authentication\n    context.evaluatePolicy(\n        .deviceOwnerAuthenticationWithBiometrics,\n        localizedReason: \"Authenticate to access your account\"\n    ) { success, error in\n        DispatchQueue.main.async {\n            if success {\n                // Authentication succeeded\n            } else {\n                // Handle error (user cancelled, failed, etc.)\n            }\n        }\n    }\n}\n\nKey points:\n- You must add NSFaceIDUsageDescription to Info.plist explaining why Face ID is needed.\n- .deviceOwnerAuthenticationWithBiometrics only allows biometrics.\n- .deviceOwnerAuthentication falls back to device passcode if biometrics fail.\n- context.biometryType tells you if the device supports .faceID, .touchID, .opticID, or .none.\n- LAError codes include .userCancel, .userFallback, .biometryNotAvailable, .biometryNotEnrolled, .biometryLockout (too many failed attempts).\n- The localizedReason string is shown to the user in the authentication prompt."
  },
  {
    "topic": "security",
    "level": 1,
    "question": "What are the NSFileProtection levels in iOS and when would you use each one?",
    "hint": "Think about when files need to be accessible relative to the device lock state — always, only when unlocked, or on first unlock after boot.",
    "answer": "NSFileProtection (Data Protection API) controls when files can be accessed based on the device lock state. It leverages hardware encryption tied to the user's passcode.\n\nProtection levels (from most to least secure):\n\n1. .complete (NSFileProtectionComplete): File is only accessible when the device is unlocked. The encryption key is discarded from memory shortly after the device locks. Best for: highly sensitive user data (health records, financial data). Limitation: background operations cannot access these files.\n\n2. .completeUnlessOpen (NSFileProtectionCompleteUnlessOpen): File can be created/written while locked if it was opened before locking. Once closed while locked, it cannot be reopened until unlocked. Best for: files that need to be written in the background (e.g., downloading attachments).\n\n3. .completeUntilFirstUserAuthentication (NSFileProtectionCompleteUntilFirstUserAuthentication): File is accessible after the user unlocks the device once after boot. Remains accessible even when locked afterward. This is the DEFAULT for most files. Best for: data needed by background processes (push notification handling, background fetch).\n\n4. .none (NSFileProtectionNone): No protection — file is always accessible. Encrypted with a device key only (not passcode-derived). Best for: non-sensitive data that must be available immediately after boot (before first unlock).\n\nSet protection:\ntry data.write(to: fileURL, options: .completeFileProtection)\ntry FileManager.default.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: path)\n\nKeychain items have analogous accessibility levels via kSecAttrAccessible."
  },
  {
    "topic": "security",
    "level": 1,
    "question": "Explain the OAuth 2.0 authorization code flow for iOS apps. Why is PKCE important?",
    "hint": "Think about the steps: redirect to auth server, user login, authorization code, exchange for tokens. PKCE adds a code challenge to prevent interception.",
    "answer": "OAuth 2.0 Authorization Code Flow with PKCE (Proof Key for Code Exchange) is the recommended authentication flow for mobile apps.\n\nFlow steps:\n\n1. Generate PKCE parameters:\n   - Create a random code_verifier (43-128 characters).\n   - Compute code_challenge = Base64URL(SHA256(code_verifier)).\n\n2. Redirect user to authorization server:\n   GET /authorize?response_type=code&client_id=xxx&redirect_uri=myapp://callback&scope=openid+profile&code_challenge=xxx&code_challenge_method=S256\n\n3. User authenticates and grants consent in the browser (ASWebAuthenticationSession in iOS).\n\n4. Auth server redirects back to your app with an authorization code:\n   myapp://callback?code=AUTH_CODE\n\n5. Exchange code for tokens (server-to-server is preferred, but mobile apps do this directly):\n   POST /token with code=AUTH_CODE, code_verifier=ORIGINAL_VERIFIER, grant_type=authorization_code, redirect_uri, client_id.\n\n6. Server validates code_challenge matches SHA256(code_verifier), then returns access_token and refresh_token.\n\nWhy PKCE is critical for mobile:\n- Without PKCE, if a malicious app registers the same custom URL scheme, it can intercept the authorization code from the redirect.\n- With PKCE, the intercepted code is useless because the attacker doesn't have the code_verifier.\n- PKCE makes the authorization code one-time-use and bound to the original requestor.\n\niOS implementation: Use ASWebAuthenticationSession which handles the browser session securely, prevents other apps from observing the callback, and supports Universal Links for more secure redirects."
  },
  {
    "topic": "security",
    "level": 1,
    "question": "How should you securely handle JWT access tokens and refresh tokens in an iOS app?",
    "hint": "Think about where to store tokens, how to handle expiration, and the refresh flow when an access token expires.",
    "answer": "JWT (JSON Web Token) management involves secure storage, automatic refresh, and proper lifecycle handling.\n\nToken storage:\n- Store both access and refresh tokens in the Keychain — never in UserDefaults, files, or in-memory only.\n- Use kSecAttrAccessibleWhenUnlockedThisDeviceOnly to prevent backup extraction and ensure tokens are only accessible when the device is unlocked.\n- Never store tokens in the app bundle or hardcode them.\n\nAccess token handling:\n- Access tokens are short-lived (typically 15-60 minutes).\n- Include in API requests via Authorization: Bearer <token> header.\n- Check expiration before each request by decoding the JWT payload (base64) and reading the exp claim. Alternatively, track expiration time locally.\n- Do NOT rely solely on 401 responses to detect expiration — proactively refresh before expiry.\n\nRefresh token flow:\n- When access token expires, send refresh token to POST /token with grant_type=refresh_token.\n- Server returns a new access token (and optionally a new refresh token — token rotation).\n- If refresh fails (expired or revoked), redirect user to login.\n\nConcurrency handling:\n- Use a serial queue or actor to prevent multiple simultaneous refresh requests when several API calls fail at once.\n- Queue pending requests and replay them with the new token after refresh succeeds.\n\nSecurity best practices:\n- Implement token rotation: each refresh returns a new refresh token and invalidates the old one.\n- Detect refresh token reuse on the server (indicates theft) and invalidate all tokens for that user.\n- Clear all tokens on logout.\n- Never log or print tokens.\n- Set appropriate Keychain access group if sharing tokens between app and extensions."
  },
  {
    "topic": "security",
    "level": 2,
    "question": "What are the OWASP Mobile Top 10 risks and how do they apply to iOS development?",
    "hint": "Think about the major categories of mobile security vulnerabilities from insecure storage to insufficient cryptography.",
    "answer": "The OWASP Mobile Top 10 identifies the most critical mobile security risks:\n\n1. M1 — Improper Credential Usage: Hardcoded credentials, API keys in source code, insecure storage of user credentials. iOS mitigation: Use Keychain, never hardcode secrets, use server-side authentication.\n\n2. M2 — Inadequate Supply Chain Security: Compromised third-party SDKs or dependencies. iOS mitigation: Audit dependencies, use SPM with pinned versions, verify checksums.\n\n3. M3 — Insecure Authentication/Authorization: Weak authentication, missing server-side validation. iOS mitigation: Validate all auth server-side, use OAuth 2.0 + PKCE, implement biometrics properly.\n\n4. M4 — Insufficient Input/Output Validation: SQL injection, XSS in WebViews, path traversal. iOS mitigation: Validate and sanitize all input, use parameterized queries, configure WKWebView securely.\n\n5. M5 — Insecure Communication: Cleartext traffic, weak TLS, missing certificate validation. iOS mitigation: Enforce ATS, implement certificate pinning, use only TLS 1.2+.\n\n6. M6 — Inadequate Privacy Controls: Excessive data collection, leaking PII in logs or analytics. iOS mitigation: Follow data minimization, respect privacy APIs, audit logging.\n\n7. M7 — Insufficient Binary Protections: Lack of obfuscation, no tampering detection, reverse engineering. iOS mitigation: Enable bitcode, use app attestation (DeviceCheck/App Attest), detect jailbreak.\n\n8. M8 — Security Misconfiguration: Debug flags in production, excessive permissions, exposed URL schemes. iOS mitigation: Remove debug code, minimize entitlements, validate URL scheme inputs.\n\n9. M9 — Insecure Data Storage: Sensitive data in UserDefaults, unencrypted Core Data, data in backups. iOS mitigation: Use Keychain, enable file protection, exclude sensitive files from backup.\n\n10. M10 — Insufficient Cryptography: Weak algorithms, hardcoded keys, improper IV generation. iOS mitigation: Use CryptoKit, never implement custom crypto, use secure random for keys and IVs."
  },
  {
    "topic": "security",
    "level": 2,
    "question": "How does CryptoKit work for encryption and hashing in iOS? Explain AES-GCM, SHA-256, and HMAC usage.",
    "hint": "Think about symmetric encryption with AES-GCM providing both confidentiality and integrity, and how HMAC provides message authentication.",
    "answer": "CryptoKit (iOS 13+) provides a Swift-native API for common cryptographic operations.\n\nSHA-256 Hashing (one-way, irreversible):\nimport CryptoKit\nlet data = \"Hello\".data(using: .utf8)!\nlet hash = SHA256.hash(data: data)\nlet hashString = hash.compactMap { String(format: \"%02x\", $0) }.joined()\n// Also available: SHA384, SHA512\n\nHMAC (Hash-based Message Authentication Code):\nlet key = SymmetricKey(size: .bits256)\nlet authCode = HMAC<SHA256>.authenticationCode(for: data, using: key)\nlet isValid = HMAC<SHA256>.isValidAuthenticationCode(authCode, authenticating: data, using: key)\n// HMAC verifies both integrity and authenticity — the sender must know the key.\n\nAES-GCM Encryption (symmetric, authenticated encryption):\nlet key = SymmetricKey(size: .bits256)\n// Encrypt\nlet sealedBox = try AES.GCM.seal(plaintext, using: key)\nlet ciphertext = sealedBox.combined! // nonce + ciphertext + tag\n// Decrypt\nlet sealedBox = try AES.GCM.SealedBox(combined: ciphertext)\nlet decrypted = try AES.GCM.open(sealedBox, using: key)\n\nAES-GCM provides:\n- Confidentiality: Data is encrypted.\n- Integrity: A tag detects any tampering.\n- Authentication: Only someone with the key can produce valid ciphertext.\n- Nonce: Automatically generated to prevent replay attacks.\n\nAlso available: ChaChaPoly (alternative to AES-GCM, good on devices without AES hardware), P256/P384/P521 for elliptic curve operations (signing, key agreement), and Curve25519 for key exchange.\n\nBest practices: Never hardcode keys. Generate keys with SymmetricKey(size:) or derive them with HKDF. Store keys in the Keychain or Secure Enclave."
  },
  {
    "topic": "security",
    "level": 2,
    "question": "What are some common jailbreak detection techniques in iOS, and what are their limitations?",
    "hint": "Think about file system checks, dynamic library checks, sandbox integrity tests, and why determined attackers can bypass them all.",
    "answer": "Jailbreak detection aims to identify if a device has been compromised, which may expose the app to additional attack vectors.\n\nCommon detection techniques:\n\n1. File System Checks: Look for files that exist only on jailbroken devices:\n- /Applications/Cydia.app\n- /Library/MobileSubstrate/MobileSubstrate.dylib\n- /bin/bash, /usr/sbin/sshd\n- /etc/apt, /private/var/lib/apt/\nlet suspicious = FileManager.default.fileExists(atPath: \"/Applications/Cydia.app\")\n\n2. URL Scheme Check: if UIApplication.shared.canOpenURL(URL(string: \"cydia://\")!) — Cydia's URL scheme.\n\n3. Sandbox Integrity: Try writing to a location outside the sandbox:\nlet testPath = \"/private/test_jailbreak\"\ndo { try \"test\".write(toFile: testPath, atomically: true, encoding: .utf8); /* jailbroken */ }\ncatch { /* not jailbroken */ }\n\n4. Dynamic Library Checks: Use _dyld_image_count() and _dyld_get_image_name() to check for injected libraries like MobileSubstrate or frida.\n\n5. Fork Check: fork() succeeds on jailbroken devices (sandbox normally prevents it).\n\n6. Symbolic Link Check: Check if /Applications is a symlink (it is on jailbroken devices).\n\nLimitations:\n- All client-side checks can be bypassed. Tools like Liberty Lite, Shadow, and A-Bypass hook detection methods and return false results.\n- Attackers can use Frida to dynamically patch detection code at runtime.\n- File path checks are easily spoofed by renaming or hiding files.\n- Obfuscation helps but is not foolproof.\n\nBest approach: Layer multiple detection methods, use Apple's App Attest API (DeviceCheck framework) for server-side device integrity verification, and design the app so that server-side validation doesn't trust the client regardless of jailbreak status."
  },
  {
    "topic": "security",
    "level": 3,
    "question": "Explain the Secure Enclave on iOS. What operations can it perform and what are its limitations?",
    "hint": "Think about the hardware-isolated coprocessor, what key types it supports, and why private keys never leave the enclave.",
    "answer": "The Secure Enclave is a hardware-based security coprocessor isolated from the main processor. It has its own encrypted memory and boot process, separate from the application processor.\n\nCapabilities:\n\n1. Key Generation and Storage: Generates elliptic curve keys (P-256 / secp256r1) inside the enclave. Private keys are created within and NEVER leave the Secure Enclave — not even Apple or the OS can extract them.\n\n2. Signing Operations:\nlet privateKey = try SecureEnclave.P256.Signing.PrivateKey()\nlet signature = try privateKey.signature(for: dataToSign)\nlet publicKey = privateKey.publicKey // Can be exported\nlet isValid = publicKey.isValidSignature(signature, for: dataToSign)\n\n3. Key Agreement (ECDH):\nlet privateKey = try SecureEnclave.P256.KeyAgreement.PrivateKey()\nlet sharedSecret = try privateKey.sharedSecretFromKeyAgreement(with: otherPublicKey)\n\n4. Access Control: Keys can require biometric authentication or device passcode before use:\nlet accessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, [.privateKeyUsage, .biometryCurrentSet], nil)!\nlet privateKey = try SecureEnclave.P256.Signing.PrivateKey(accessControl: accessControl)\n\n5. Biometric Data Processing: Face ID / Touch ID matching occurs entirely within the Secure Enclave.\n\nLimitations:\n- Only supports P-256 elliptic curve keys — no RSA, no AES, no other curve types.\n- Cannot perform bulk encryption/decryption (use derived symmetric keys with CryptoKit instead).\n- Keys are device-bound — cannot be backed up, migrated, or synced.\n- .biometryCurrentSet invalidates the key if biometrics change (user adds a new fingerprint).\n- Performance: Signing operations are slower than software-based crypto due to hardware communication.\n\nUse cases: Digital signatures for authentication, cryptographic attestation, protecting high-value operations (payment authorization, document signing), and securing encryption keys by deriving symmetric keys from Secure Enclave key agreements."
  },
  {
    "topic": "security",
    "level": 3,
    "question": "How does SSL/TLS pinning differ between certificate pinning and public key pinning? How would you implement each in iOS?",
    "hint": "Think about what exactly is being compared during the TLS handshake and the operational implications of certificate rotation.",
    "answer": "Both approaches validate server identity beyond the standard CA chain, but they pin different parts of the certificate.\n\nCertificate Pinning:\n- Pins the entire DER-encoded X.509 certificate or its SHA-256 hash.\n- During TLS handshake, extract the server certificate and compare it byte-for-byte with the bundled certificate.\n- Implementation:\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n    guard let serverTrust = challenge.protectionSpace.serverTrust,\n          let serverCert = SecTrustGetCertificateAtIndex(serverTrust, 0) else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n    let serverCertData = SecCertificateCopyData(serverCert) as Data\n    let pinnedCertData = // load from bundle\n    if serverCertData == pinnedCertData {\n        completionHandler(.useCredential, URLCredential(trust: serverTrust))\n    } else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n}\n- Drawback: Certificates expire (typically every 1-2 years). Every renewal requires an app update, even if the key pair stays the same.\n\nPublic Key Pinning:\n- Extracts and pins only the Subject Public Key Info (SPKI) from the certificate.\n- More resilient: certificate renewals using the same key pair don't break pinning.\n- Implementation: Extract the public key from the server certificate using SecTrustCopyKey (or SecCertificateCopyKey on newer APIs), then compare its data representation with the pinned key hash.\n- Can pin backup keys to enable smooth rotation.\n\nApple's built-in support (iOS 14+):\nIn Info.plist under NSAppTransportSecurity > NSPinnedDomains, you can specify pinned CA certificates per domain. The system handles validation automatically.\n\nBest practices:\n- Always pin at least two keys (primary + backup) to avoid lockout.\n- Plan key rotation strategy before implementing pinning.\n- Include a mechanism to update pins remotely (with its own security, e.g., signed configuration).\n- Pin the intermediate CA certificate rather than the leaf for more flexibility.\n- Test pinning thoroughly — incorrect implementation locks users out of the app."
  },
  {
    "topic": "security",
    "level": 3,
    "question": "What is App Attest (DeviceCheck framework) and how does it help prevent fraud?",
    "hint": "Think about how the server can verify that requests come from a genuine, unmodified app running on a real Apple device.",
    "answer": "App Attest (part of the DeviceCheck framework, iOS 14+) allows your server to verify that requests originate from a legitimate, unmodified instance of your app on a genuine Apple device.\n\nHow it works:\n\n1. Key Generation: The app generates an asymmetric key pair inside the Secure Enclave:\nlet service = DCAppAttestService.shared\nguard service.isSupported else { return }\nservice.generateKey { keyId, error in\n    // Store keyId — this identifies the key pair\n}\n\n2. Attestation: The app requests Apple to attest the key:\nlet challenge = // server-generated nonce\nlet hash = Data(SHA256.hash(data: challenge))\nservice.attestKey(keyId, clientDataHash: hash) { attestation, error in\n    // Send attestation + keyId to your server\n}\nApple returns an attestation object containing: the public key, app identity (bundle ID, team ID), device identity, and a certificate chain signed by Apple.\n\n3. Server Verification: Your server validates the attestation certificate chain back to Apple's root CA. Verifies the app ID and receipt match expectations.\n\n4. Assertion (ongoing): For subsequent requests, the app signs a challenge:\nservice.generateAssertion(keyId, clientDataHash: requestHash) { assertion, error in\n    // Send assertion with the API request\n}\nServer verifies the signature using the previously attested public key.\n\nWhat it prevents:\n- Modified/repackaged apps (attestation fails for tampered binaries).\n- Emulators and simulators (no Secure Enclave).\n- Replay attacks (server nonce ensures freshness).\n- Bot traffic and automated abuse.\n- Jailbroken device detection (compromised devices may fail attestation).\n\nLimitations:\n- Not available on simulators (use isSupported check).\n- Requires network connectivity for initial attestation (Apple's servers).\n- A risk budget exists — Apple may rate-limit attestation requests.\n- Sophisticated attackers with jailbroken devices might still pass attestation in some cases.\n- Should be one layer in a defense-in-depth strategy, not the sole protection."
  },
  {
    "topic": "security",
    "level": 4,
    "question": "How would you implement runtime manipulation protection in an iOS app to detect debuggers, code injection, and method swizzling?",
    "hint": "Think about ptrace, sysctl for debugger detection, checking dyld images for injected libraries, and monitoring Objective-C runtime modifications.",
    "answer": "Runtime manipulation protection involves detecting and responding to various attack techniques:\n\n1. Debugger Detection:\n// ptrace-based: Prevent debugger attachment\nptrace(PT_DENY_ATTACH, 0, nil, 0)\n\n// sysctl-based: Check if debugger is attached\nfunc isDebuggerAttached() -> Bool {\n    var info = kinfo_proc()\n    var size = MemoryLayout<kinfo_proc>.stride\n    var mib: [Int32] = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()]\n    sysctl(&mib, 4, &info, &size, nil, 0)\n    return (info.kp_proc.p_flag & P_TRACED) != 0\n}\n\n// Run checks periodically, not just at launch (attackers can attach later).\n\n2. Code Injection Detection:\nfunc detectInjectedLibraries() -> Bool {\n    let suspiciousLibs = [\"FridaGadget\", \"frida-agent\", \"MobileSubstrate\", \"libcycript\", \"SubstrateLoader\"]\n    for i in 0..<_dyld_image_count() {\n        if let name = _dyld_get_image_name(i) {\n            let imageName = String(cString: name)\n            for lib in suspiciousLibs {\n                if imageName.contains(lib) { return true }\n            }\n        }\n    }\n    return false\n}\n\n// Also check DYLD_INSERT_LIBRARIES environment variable.\n\n3. Method Swizzling Detection:\n- Store original IMP (implementation pointers) of critical methods at launch.\n- Periodically verify they haven't changed using method_getImplementation.\n- For Swift methods, this is less applicable since vtable dispatch is harder to swizzle.\n\n4. Integrity Checks:\n- Compute hash of critical code sections and compare against expected values.\n- Validate the app's code signature at runtime using SecCodeCheckValidity (macOS) or by checking embedded.mobileprovision.\n- Check the app binary's LC_CODE_SIGNATURE load command.\n\n5. Anti-Frida Measures:\n- Check for Frida's default port (27042) being open.\n- Scan for Frida-specific named threads.\n- Detect Frida's trampolines in memory.\n\nLimitations and best practices:\n- All client-side checks can eventually be bypassed by determined attackers.\n- Obfuscate detection code to make it harder to locate and patch.\n- Scatter checks throughout the codebase rather than centralizing them.\n- Report detections to the server for risk scoring rather than immediately crashing (which reveals detection logic).\n- Use these as part of defense-in-depth alongside server-side validation and App Attest."
  },
  {
    "topic": "security",
    "level": 4,
    "question": "Explain code signing, entitlements, and provisioning profiles in iOS. How do they form the chain of trust?",
    "hint": "Think about the relationship between your signing identity, the provisioning profile linking your team to devices and capabilities, and how the system verifies the chain at install and runtime.",
    "answer": "iOS code signing creates a chain of trust from Apple down to each specific app installation.\n\nCode Signing:\n- Every app binary and framework must be signed with a cryptographic signature.\n- The developer has a signing identity (private key + certificate) issued by Apple.\n- codesign creates a code seal: a hash of every page of executable code, stored in the binary's code directory.\n- At runtime, iOS validates these hashes when loading code pages into memory. Any modification invalidates the signature and the app is killed.\n\nCertificates (signing identity):\n- Development Certificate: For running on test devices during development.\n- Distribution Certificate: For App Store and enterprise distribution.\n- Apple signs your certificate, creating a chain: Apple Root CA -> Apple Worldwide Developer Relations -> Your Certificate.\n\nEntitlements:\n- A plist embedded in the app binary specifying capabilities the app is allowed to use.\n- Examples: push notifications (aps-environment), App Groups (com.apple.security.application-groups), Keychain Sharing, HealthKit, Sign in with Apple.\n- Requested in Xcode's Signing & Capabilities tab.\n- Must match the provisioning profile — you can't claim entitlements not granted by the profile.\n- The system checks entitlements at runtime when accessing protected APIs.\n\nProvisioning Profiles:\n- A signed file from Apple that binds together: Team ID, App ID (bundle identifier), entitlements, certificate(s), and device UDIDs (for development/ad hoc).\n- Development profiles list specific device UUIDs allowed to run the app.\n- App Store profiles don't list devices (any device can install from the App Store).\n- Enterprise profiles allow installation on any device within the organization.\n\nChain of trust at install:\n1. iOS verifies the provisioning profile signature (signed by Apple).\n2. Verifies the app's code signature certificate matches one in the profile.\n3. Verifies the certificate chains to Apple's root CA.\n4. Checks the device UUID is in the profile (for dev/ad hoc).\n5. Validates entitlements in the binary match those in the profile.\n6. At runtime, page-level hash verification ensures code integrity."
  },
  {
    "topic": "security",
    "level": 4,
    "question": "How do you prevent man-in-the-middle (MITM) attacks in an iOS app beyond basic HTTPS?",
    "hint": "Think about all the layers: ATS enforcement, certificate pinning, certificate transparency, proxy detection, and network security configuration.",
    "answer": "Preventing MITM attacks requires multiple layers of defense:\n\n1. Enforce ATS Strictly:\n- Zero ATS exceptions in production.\n- Use TLS 1.3 where possible (faster handshake, better security).\n- Ensure servers support forward secrecy (ECDHE cipher suites).\n\n2. Certificate Pinning:\n- Pin public keys of your server's certificate chain (leaf or intermediate).\n- Use NSPinnedDomains in Info.plist (iOS 14+) for declarative pinning.\n- Implement URLSessionDelegate pinning for programmatic control.\n- Pin backup keys for rotation resilience.\n\n3. Certificate Transparency (CT):\n- CT requires CAs to log all issued certificates to public, auditable logs.\n- iOS automatically enforces CT for certificates issued after certain dates.\n- Helps detect rogue or misissued certificates.\n- You can verify CT compliance via SecTrustEvaluateWithError and checking SCTs.\n\n4. Proxy Detection:\n- Detect HTTP proxy configuration: CFNetworkCopySystemProxySettings().\n- Check if a VPN is active via NWPathMonitor (path includes VPN interface).\n- While not blocking proxies outright (legitimate use cases exist), alert the server for risk scoring.\n\n5. Request/Response Integrity:\n- Sign API requests with HMAC using a session key derived from authentication.\n- Include timestamps and nonces to prevent replay attacks.\n- Validate response signatures from the server.\n\n6. Secure DNS:\n- Use DNS-over-HTTPS (DoH) or DNS-over-TLS to prevent DNS spoofing.\n- iOS 14+ supports encrypted DNS via NEDNSSettingsManager or per-app DNS configuration in Info.plist.\n\n7. Network Security Monitoring:\n- Log TLS connection details via URLSessionTaskMetrics (negotiated protocol, cipher suite).\n- Detect unexpected certificate changes between connections.\n- Report anomalies to the server.\n\n8. Mutual TLS (mTLS):\n- For high-security scenarios, require the client to present a certificate too.\n- The server validates the client certificate, ensuring only authorized apps can connect.\n- Implement via URLSessionDelegate's urlSession(_:didReceive challenge:) handling .clientCertificateRequested."
  },
  {
    "topic": "security",
    "level": 5,
    "question": "How would you architect an end-to-end encryption system for a messaging app on iOS, including key management, forward secrecy, and multi-device support?",
    "hint": "Think about the Signal Protocol concepts: identity keys, prekey bundles, double ratchet algorithm, and how to sync across a user's multiple devices.",
    "answer": "An E2E encrypted messaging system requires careful key management and protocol design.\n\nKey Hierarchy (Signal Protocol model):\n\n1. Identity Key Pair: Long-term P-256 key pair generated in the Secure Enclave. Public key is uploaded to the server as the user's identity. Private key never leaves the device.\n\n2. Signed Prekey: Medium-term key pair (rotated weekly/monthly). Signed by the identity key to prove ownership. Uploaded to the server.\n\n3. One-time Prekeys: Batch of ephemeral key pairs uploaded to the server. Each consumed by a single new conversation. Prevents replays.\n\n4. Session Setup (X3DH - Extended Triple Diffie-Hellman):\n- Sender fetches recipient's prekey bundle (identity key, signed prekey, one-time prekey).\n- Performs three ECDH operations to derive a shared secret:\n  DH1 = ECDH(senderIdentityKey, recipientSignedPrekey)\n  DH2 = ECDH(senderEphemeralKey, recipientIdentityKey)\n  DH3 = ECDH(senderEphemeralKey, recipientSignedPrekey)\n- Optional DH4 with one-time prekey.\n- Derive root key via HKDF(DH1 || DH2 || DH3 || DH4).\n\n5. Double Ratchet Algorithm:\n- Symmetric ratchet: Each message derives a new message key from a chain key using HMAC. Old keys are deleted after use (forward secrecy).\n- DH ratchet: Each message exchange rotates DH key pairs, providing future secrecy (break-in recovery). If a key is compromised, future messages are secure once the ratchet advances.\n\n6. Message Encryption:\n- Each message encrypted with AES-256-GCM using a unique message key from the ratchet.\n- Includes message number and previous chain length for handling out-of-order delivery.\n\nMulti-Device Support:\n- Each device has its own identity key pair and prekey bundle.\n- Messages are encrypted separately for each of the recipient's devices (fan-out).\n- Devices within a user's account verify each other via a device linking protocol (QR code scanning or trusted device chain).\n- Server stores one encrypted copy per recipient device.\n\niOS Implementation:\n- Generate and store identity keys in Secure Enclave (SecureEnclave.P256.KeyAgreement.PrivateKey).\n- Use CryptoKit for ECDH, HKDF key derivation, and AES-GCM encryption.\n- Store ratchet state in Keychain or encrypted Core Data (with NSFileProtectionComplete).\n- Implement prekey replenishment: when one-time prekeys run low, generate and upload more.\n- Key verification: Provide safety numbers (hash of both identity keys) for users to verify out-of-band.\n\nKey deletion policy: Aggressively delete expired message keys, old ratchet states, and consumed prekeys. This is essential for forward secrecy — if the device is compromised later, old messages cannot be decrypted."
  },
  {
    "topic": "security",
    "level": 5,
    "question": "What is certificate transparency, and how can you verify it programmatically in iOS to detect misissued certificates?",
    "hint": "Think about SCTs (Signed Certificate Timestamps), CT logs, and how they integrate with the TLS trust evaluation on Apple platforms.",
    "answer": "Certificate Transparency (CT) is a framework (RFC 6962) that requires Certificate Authorities to publicly log every certificate they issue, making misissued or rogue certificates detectable.\n\nHow CT works:\n1. When a CA issues a certificate, it submits the pre-certificate to one or more public CT logs.\n2. Each log returns a Signed Certificate Timestamp (SCT) — a promise to include the certificate in the log within a maximum merge delay (typically 24 hours).\n3. SCTs are delivered to the client via: embedded in the certificate itself, TLS extension during handshake, or OCSP stapling.\n4. The client verifies SCTs are signed by known CT log operators.\n\nApple's CT Policy:\n- Apple requires CT compliance for all publicly-trusted TLS certificates issued after specific dates.\n- Safari and all apps using ATS validate CT by default.\n- Certificates must have SCTs from at least two independent CT logs (from different operators).\n- If CT validation fails, the connection is rejected.\n\nProgrammatic verification in iOS:\n\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n    guard let trust = challenge.protectionSpace.serverTrust else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n        return\n    }\n    \n    // Set CT policy\n    let ctPolicy = SecPolicyCreateSSL(true, challenge.protectionSpace.host as CFString)\n    SecTrustSetPolicies(trust, ctPolicy)\n    \n    // Evaluate with CT\n    var error: CFError?\n    let isTrusted = SecTrustEvaluateWithError(trust, &error)\n    \n    if isTrusted {\n        // Check CT result specifically\n        if let trustResult = SecTrustCopyResult(trust) as? [String: Any],\n           let ctResult = trustResult[\"TrustCertificateTransparency\"] as? Bool,\n           ctResult {\n            completionHandler(.useCredential, URLCredential(trust: trust))\n        } else {\n            // CT verification failed\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    } else {\n        completionHandler(.cancelAuthenticationChallenge, nil)\n    }\n}\n\nWhy CT matters for iOS apps:\n- Detects if a CA has been compromised and is issuing fraudulent certificates for your domain.\n- Prevents state-level attackers from obtaining valid certificates from compliant CAs without detection.\n- Combined with certificate pinning and CAA DNS records, provides comprehensive certificate security.\n- CT logs are publicly auditable — anyone can monitor for unexpected certificates for their domain.\n\nMonitoring:\n- Use services like crt.sh or Facebook's CT monitoring to watch for certificates issued for your domains.\n- Set up alerts for unexpected certificate issuance.\n- Regularly audit your domain's CT log entries."
  },
  {
    "topic": "security",
    "level": 5,
    "question": "How would you design a secure offline authentication system that works without network connectivity while maintaining security guarantees?",
    "hint": "Think about how to cache authentication state securely, time-based token validation, hardware-backed key attestation, and degradation policies.",
    "answer": "Designing secure offline authentication requires balancing usability with security when the server is unreachable.\n\nArchitecture:\n\n1. Initial Online Authentication:\n- User authenticates normally (OAuth 2.0 + PKCE or similar).\n- Server issues a signed offline token (JWT with specific offline claims):\n  {\n    \"sub\": \"user_123\",\n    \"iat\": timestamp,\n    \"offline_exp\": timestamp + 7_days,\n    \"max_offline_uses\": 50,\n    \"permissions\": [\"read\", \"limited_write\"],\n    \"device_key_hash\": \"sha256_of_device_public_key\"\n  }\n- Token is signed by the server's private key. App stores the server's public key for offline verification.\n\n2. Device Binding:\n- Generate a P-256 key pair in the Secure Enclave during setup.\n- Register the public key with the server (device_key_hash in the token).\n- Offline authentication requires proving possession of the device private key (sign a challenge).\n- This prevents token theft — a stolen token is useless without the specific device's Secure Enclave key.\n\n3. Offline Authentication Flow:\n- Verify the offline token's signature using the cached server public key.\n- Check offline_exp hasn't passed (requires reasonably accurate device clock — but note attackers can manipulate system time).\n- Require biometric/passcode authentication via LAContext to unlock the Secure Enclave key.\n- Sign a local challenge with the device key to prove hardware binding.\n- Decrement the offline use counter (stored encrypted in Keychain).\n\n4. Time Verification:\n- Cache the last known server time during online sessions.\n- Compare with device time — if significant drift detected, restrict offline access.\n- Use monotonic clock (ProcessInfo.processInfo.systemUptime or mach_absolute_time) to detect backward time changes between uses, though this resets on reboot.\n\n5. Degraded Permissions:\n- Offline mode grants a reduced permission set (read-only, limited features).\n- Sensitive operations are queued and require online re-authentication.\n- Progressive degradation: as time offline increases, permissions decrease.\n\n6. Re-synchronization:\n- When connectivity returns, immediately re-authenticate online.\n- Submit an audit log of offline operations for server-side validation.\n- Server can retroactively reject operations if the offline token was revoked.\n- Refresh the offline token with a new expiration.\n\n7. Revocation:\n- Maintain a small revocation list cached locally (updated during online sessions).\n- Server can push revocation via silent push notification when connectivity is intermittent.\n- On re-connection, always check token validity before continuing offline operations.\n\nSecurity considerations:\n- Assume the device could be compromised — limit offline token lifetime and use count.\n- All offline data should use NSFileProtectionComplete.\n- Audit logging of all offline actions is critical for forensic analysis.\n- The system should err on the side of requiring re-authentication rather than granting access when in doubt."
  },
  {
    "topic": "performance",
    "level": 0,
    "question": "What is Instruments in Xcode and what are the most commonly used profiling tools it provides?",
    "hint": "Think about the different types of performance problems you might need to diagnose: speed, memory, leaks, and energy usage.",
    "answer": "Instruments is a performance analysis and testing tool built into Xcode. It provides a suite of profiling templates to diagnose various performance issues.\n\nMost commonly used instruments:\n\n1. Time Profiler: Shows where your app spends CPU time. Displays a call tree with the percentage of time in each function. Essential for finding slow code paths and optimizing performance-critical sections.\n\n2. Allocations: Tracks all memory allocations over time. Shows heap growth, persistent vs transient objects, and helps identify memory bloat. You can mark generations to compare allocation patterns.\n\n3. Leaks: Detects memory that has been allocated but is no longer referenced — true memory leaks. Also detects retain cycles involving Objective-C objects. Run alongside Allocations for a complete memory picture.\n\n4. Energy Log: Measures the app's energy impact across CPU, network, location, GPU, and other subsystems. Critical for battery optimization.\n\n5. Network: Monitors network request timing, payload sizes, and concurrent connections.\n\n6. Core Animation: Measures frame rate (FPS), identifies offscreen rendering, blending issues, and other GPU-related problems.\n\n7. System Trace: Low-level view of thread scheduling, system calls, and virtual memory activity.\n\nTo use Instruments: Product > Profile (Cmd+I) in Xcode, or open Instruments directly and attach to a running process. Always profile on a real device — Simulator performance is not representative of actual device performance."
  },
  {
    "topic": "performance",
    "level": 0,
    "question": "What is cell reuse in UITableView and UICollectionView, and why is it important for performance?",
    "hint": "Think about what would happen if you created a brand new view for every row in a list with thousands of items.",
    "answer": "Cell reuse is a pattern where table views and collection views maintain a pool of reusable cell objects instead of creating new ones for every visible row.\n\nHow it works:\n1. You register a cell class or nib: tableView.register(MyCell.self, forCellReuseIdentifier: \"cell\")\n2. In cellForRowAt, you dequeue a reusable cell: let cell = tableView.dequeueReusableCell(withIdentifier: \"cell\", for: indexPath)\n3. When a cell scrolls off screen, it's placed in a reuse queue rather than being deallocated.\n4. When a new cell is needed, the system returns a recycled cell from the queue instead of allocating a new one.\n\nWhy it matters:\n- Memory efficiency: A table with 10,000 rows only needs ~15-20 cell instances (enough to fill the visible area plus a small buffer), not 10,000.\n- Performance: Creating and laying out views is expensive. Reusing existing cells avoids this overhead during scrolling.\n- Smooth scrolling: Without reuse, creating new cells during fast scrolling causes frame drops and stuttering.\n\nCommon pitfalls:\n- Forgetting to reset cell state in prepareForReuse() — old data or images may appear briefly in recycled cells.\n- Performing expensive operations (network requests, complex layout calculations) in cellForRowAt instead of pre-computing them.\n- Not using the correct reuse identifier, causing cells to be created instead of reused.\n\nIn SwiftUI, List and LazyVStack/LazyHStack handle cell reuse automatically."
  },
  {
    "topic": "performance",
    "level": 0,
    "question": "What is the main thread in iOS and why is it important to keep it responsive?",
    "hint": "Think about what happens to the UI when the main thread is busy with a long-running operation.",
    "answer": "The main thread (also called the UI thread) is the primary thread where all UI updates, user interaction handling, and most UIKit/SwiftUI work occurs.\n\nWhy it must stay responsive:\n- The screen refreshes at 60 FPS (or 120 FPS on ProMotion devices), giving the main thread only ~16.67ms (or ~8.33ms) per frame to process input and render the next frame.\n- If the main thread is blocked by heavy work (network calls, file I/O, complex calculations, image processing), the UI freezes — buttons don't respond, scrolling stutters, animations freeze.\n- If the main thread is unresponsive for too long, the system watchdog will terminate the app (watchdog timeout crash).\n\nWhat should run on the main thread:\n- All UIKit/SwiftUI view updates.\n- User interaction handling (gestures, button taps).\n- Animations.\n- Short, fast computations.\n\nWhat should NOT run on the main thread:\n- Network requests.\n- File and database operations.\n- Image processing and resizing.\n- JSON parsing of large payloads.\n- Any computation taking more than a few milliseconds.\n\nHow to move work off the main thread:\n- DispatchQueue.global().async { /* heavy work */ }\n- Task.detached { /* async heavy work */ }\n- Use URLSession (which is asynchronous by default).\n\nHow to return to the main thread:\n- DispatchQueue.main.async { /* update UI */ }\n- @MainActor annotation in Swift concurrency.\n- MainActor.run { /* update UI */ }"
  },
  {
    "topic": "performance",
    "level": 1,
    "question": "What is the difference between pre-main and post-main app launch time, and how do you optimize each?",
    "hint": "Think about what happens before main() is called (dynamic linking, class loading) versus after (application didFinishLaunching setup).",
    "answer": "App launch time is divided into two phases:\n\nPre-main (before main() is called):\nThe system performs these steps:\n1. Loading the app executable into memory.\n2. Loading all dynamic libraries (dylibs/frameworks) and performing symbol binding.\n3. Running Objective-C +load methods and static initializers (C++ constructors, __attribute__((constructor))).\n4. Calling UIApplicationMain (which calls main).\n\nPre-main optimizations:\n- Reduce dynamic frameworks: Each framework adds load time. Merge small frameworks or use static linking where possible.\n- Remove unused code and frameworks: Dead code adds to binary parsing and symbol binding.\n- Avoid +load methods: Use +initialize (lazy) instead. In Swift, avoid static initializers.\n- Minimize Objective-C class count: Each class is registered at launch. Large numbers of classes slow pre-main.\n- Measure with DYLD_PRINT_STATISTICS=1 environment variable.\n\nPost-main (after main, through first frame rendered):\nIncludes application(_:didFinishLaunchingWithOptions:), scene setup, initial view controller creation, and first layout pass.\n\nPost-main optimizations:\n- Defer non-essential initialization: Don't set up analytics, logging, or preloading in didFinishLaunching. Defer to after the first frame.\n- Lazy load view controllers: Don't create tabs or views that aren't immediately visible.\n- Avoid synchronous network calls or file I/O during launch.\n- Reduce storyboard complexity: Large storyboards take longer to parse.\n- Use launch storyboard effectively to make perceived launch instant.\n- Cache expensive computations from previous launches.\n\nMeasurement: Use Instruments (App Launch template), os_signpost for custom intervals, and MetricKit's MXAppLaunchMetric for production data. Target < 400ms for total launch time."
  },
  {
    "topic": "performance",
    "level": 1,
    "question": "How do you optimize image loading and caching in an iOS app?",
    "hint": "Think about downloading, decoding, resizing, and the memory impact of keeping full-resolution images in memory.",
    "answer": "Image optimization involves multiple stages:\n\n1. Downloading:\n- Use URLSession download tasks for large images.\n- Implement pagination or lazy loading — don't download all images at once.\n- Use appropriate image formats: WebP or HEIC for smaller file sizes, JPEG for photos, PNG for images requiring transparency.\n- Request appropriately sized images from the server (e.g., thumbnail URL vs full-res URL).\n\n2. Decoding:\n- Image decoding (converting compressed data to bitmap) is CPU-intensive and happens on first display by default (on the main thread).\n- Force decoding on a background thread:\nDispatchQueue.global().async {\n    let renderer = UIGraphicsImageRenderer(size: targetSize)\n    let decoded = renderer.image { ctx in image.draw(in: CGRect(origin: .zero, size: targetSize)) }\n    DispatchQueue.main.async { imageView.image = decoded }\n}\n- Use preparingForDisplay() (iOS 15+) which decodes asynchronously.\n\n3. Resizing:\n- Never display a 4000x3000 image in a 100x100 thumbnail. Downscale first.\n- Use ImageIO for memory-efficient downsampling without fully decoding the original:\nlet options: [CFString: Any] = [kCGImageSourceThumbnailMaxPixelSize: maxDimension, kCGImageSourceCreateThumbnailFromImageAlways: true]\nlet thumbnail = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary)\n\n4. Caching:\n- Use NSCache for in-memory caching (automatically evicts under memory pressure).\n- Implement disk caching for persistence across sessions.\n- Use URLCache for HTTP-level caching with proper cache headers.\n- Libraries like Kingfisher or SDWebImage provide full pipelines: download, cache, decode, resize.\n\n5. Memory:\n- A 4000x3000 RGBA image uses ~48MB in memory regardless of file size.\n- Always downscale to display size before caching in memory.\n- Respond to memory warnings by clearing image caches."
  },
  {
    "topic": "performance",
    "level": 1,
    "question": "What causes offscreen rendering and blending in iOS, and how do they affect scrolling performance?",
    "hint": "Think about corner radius with masks, shadows without a path, and overlapping translucent layers.",
    "answer": "Offscreen rendering and blending are GPU-side operations that can significantly degrade scrolling performance.\n\nOffscreen Rendering:\nOccurs when the GPU must create a temporary offscreen buffer to composite a layer before displaying it. This is expensive because it requires a context switch and additional memory.\n\nCommon causes:\n- cornerRadius + masksToBounds (clipsToBounds): Forces offscreen rendering to clip content. Fix: Use prerendered images with rounded corners, or set layer.cornerRadius with layer.maskedCorners without clipping if content doesn't overflow.\n- Shadows without a path: layer.shadowColor/shadowOffset without shadowPath forces the GPU to calculate the shadow shape from the layer's alpha channel. Fix: Always set layer.shadowPath = UIBezierPath(roundedRect:cornerRadius:).cgPath.\n- Group opacity: layer.allowsGroupOpacity = true with complex sublayers.\n- Masks: layer.mask requires compositing in an offscreen buffer.\n- shouldRasterize: Intentionally renders to an offscreen cache. Useful for complex static content but wasteful if content changes frequently.\n\nBlending:\nOccurs when the GPU must composite multiple overlapping translucent layers. The GPU calculates the resulting color for each pixel by blending the layers.\n\nCommon causes:\n- Views with alpha < 1.0 or non-opaque backgrounds.\n- UILabel on transparent background (default).\n- Images with alpha channels (PNG transparency).\n\nFixes:\n- Set view.isOpaque = true and use solid background colors.\n- Set label.backgroundColor to match parent background.\n- Use opaque image formats where transparency isn't needed.\n\nDebugging:\n- In Instruments Core Animation: Enable 'Color Blended Layers' (green = opaque, red = blended) and 'Color Offscreen-Rendered' (yellow highlight).\n- Simulator > Debug menu has the same visual debugging options."
  },
  {
    "topic": "performance",
    "level": 2,
    "question": "How does memory management work in iOS and what happens when your app receives memory warnings? How should you respond?",
    "hint": "Think about the jetsam system, the different memory warning levels, and what iOS does when apps don't free memory.",
    "answer": "iOS uses a jetsam system to manage memory across all running processes. Unlike macOS, iOS does not use swap space — when physical memory runs low, the system must reclaim it from running apps.\n\nMemory pressure levels:\n1. Normal: Sufficient memory available.\n2. Warning: Memory is getting low. Apps receive didReceiveMemoryWarning.\n3. Critical: System begins terminating background apps by jetsam priority.\n4. If still insufficient, the foreground app may be terminated.\n\nHow your app is notified:\n- UIViewController.didReceiveMemoryWarning() — Called on all view controllers.\n- UIApplicationDelegate.applicationDidReceiveMemoryWarning(_:) — App-level notification.\n- NotificationCenter: UIApplication.didReceiveMemoryWarningNotification.\n- dispatch_source_create(DISPATCH_SOURCE_TYPE_MEMORYPRESSURE, ...) for GCD-level monitoring.\n\nWhat you should do in response:\n1. Release caches: Clear NSCache instances, image caches, and any in-memory data that can be recreated or re-fetched.\n2. Release non-visible resources: View controllers not currently displayed can release their views. UIKit automatically calls viewDidUnload-equivalent behavior.\n3. Purge downloaded data: If stored in memory, write to disk and release.\n4. Cancel non-essential operations: Stop prefetching, background processing.\n\nWhat NOT to do:\n- Don't ignore memory warnings — repeated warnings with no response lead to termination.\n- Don't save state in didReceiveMemoryWarning (that's for applicationDidEnterBackground).\n\nProactive memory management:\n- Use Instruments Allocations to track heap growth and generation analysis.\n- Monitor with os_proc_available_memory() to check remaining memory.\n- Use autorelease pools in tight loops to prevent temporary memory spikes.\n- Prefer lazy loading and on-demand computation over preloading.\n- Set limits on caches: NSCache.totalCostLimit and countLimit.\n- Watch for retain cycles with weak/unowned references in closures."
  },
  {
    "topic": "performance",
    "level": 2,
    "question": "What techniques can you use to reduce an iOS app's binary size?",
    "hint": "Think about assets, dead code, compiler optimizations, and the difference between static and dynamic linking.",
    "answer": "Reducing binary size improves download times, install success rates (cellular download limits), and launch performance.\n\nAsset optimization:\n- Use Asset Catalogs with app thinning — Apple delivers only the assets matching the user's device (1x/2x/3x, device-specific).\n- Compress images: Use HEIC or WebP instead of PNG where possible.\n- Use vector PDFs or SF Symbols instead of multiple resolution bitmaps.\n- Audit for unused assets: Tools like FengNiao or Periphery can detect unused images.\n- Use on-demand resources for content not needed immediately at launch.\n\nCode-level optimization:\n- Enable dead code stripping: Build Settings > Dead Code Stripping = YES (default). The linker removes unreachable functions.\n- Swift compiler optimization level: Use -O (Optimize for Speed) or -Osize (Optimize for Size) for release builds.\n- Whole Module Optimization (WMO): Enables cross-file inlining and dead code elimination across the entire module.\n- Remove unused frameworks and libraries.\n- Audit third-party dependencies — some libraries add significant binary size for features you may not use.\n\nLinking strategy:\n- Static linking merges library code into your binary but enables better dead code stripping.\n- Dynamic frameworks add per-framework overhead (Mach-O headers, code signature). Merging small dynamic frameworks into one reduces overhead.\n- Swift runtime is included in the OS since iOS 12.2, removing ~5MB from apps targeting those versions.\n\nBitcode (deprecated in Xcode 14 but relevant for older apps):\n- Allowed Apple to re-optimize your binary for specific architectures.\n\nApp Thinning:\n- Slicing: Delivers only relevant architectures (arm64) and assets.\n- On-Demand Resources: Download additional content as needed.\n\nMeasurement:\n- Generate an App Size Report in Xcode: Product > Archive, then Distribute > App Thinning.\n- Use the app size report to identify the largest contributors.\n- Inspect the binary with command-line tools: size, nm, otool to find bloated sections."
  },
  {
    "topic": "performance",
    "level": 2,
    "question": "How do UITableView and UICollectionView prefetching APIs work and how do they improve performance?",
    "hint": "Think about UITableViewDataSourcePrefetching and how it lets you start loading data before cells become visible.",
    "answer": "Prefetching APIs allow you to prepare data for cells before they're displayed, resulting in smoother scrolling.\n\nUITableViewDataSourcePrefetching / UICollectionViewDataSourcePrefetching:\n\nclass MyViewController: UITableViewDataSourcePrefetching {\n    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {\n        // Called with index paths of cells that will likely become visible soon\n        for indexPath in indexPaths {\n            let item = items[indexPath.row]\n            if imageCache[item.imageURL] == nil {\n                startImageDownload(for: item.imageURL) // Begin loading early\n            }\n        }\n    }\n    \n    func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths: [IndexPath]) {\n        // Called when cells are no longer expected to be displayed\n        // (e.g., user reversed scroll direction)\n        for indexPath in indexPaths {\n            cancelImageDownload(for: items[indexPath.row].imageURL)\n        }\n    }\n}\n\ntableView.prefetchDataSource = self\n\nHow it works internally:\n- UIKit predicts which cells will become visible based on scroll velocity and direction.\n- prefetchRowsAt is called with those index paths, giving you time to start async operations.\n- cancelPrefetchingForRowsAt is called when the prediction changes (scroll reversal), allowing you to cancel unnecessary work.\n\nBest practices:\n- Use for network requests (image downloads, API calls) and expensive data processing.\n- Implement cancellation to avoid wasting resources.\n- Don't perform synchronous work in prefetch — it runs on the main thread.\n- Combine with Operation queues for prioritization: in-progress operations for visible cells should have higher priority than prefetch operations.\n- Works alongside cellForRowAt — always handle the case where data isn't yet available when the cell is needed.\n\nFor pagination: Trigger next page load when prefetching approaches the end of current data. This creates seamless infinite scrolling."
  },
  {
    "topic": "performance",
    "level": 3,
    "question": "How do you use the Signpost API and os_log for performance measurement in production and development?",
    "hint": "Think about marking intervals of interest with begin/end signposts that Instruments can visualize, and structured logging with os_log.",
    "answer": "The os_signpost API and os_log provide lightweight, structured performance instrumentation.\n\nos_signpost for performance measurement:\n\nimport os.signpost\n\nlet log = OSLog(subsystem: \"com.app.networking\", category: \"API\")\nlet signpostID = OSSignpostID(log: log)\n\n// Mark an interval\nos_signpost(.begin, log: log, name: \"FetchUsers\", signpostID: signpostID, \"Fetching page %d\", page)\n// ... perform work ...\nos_signpost(.end, log: log, name: \"FetchUsers\", signpostID: signpostID, \"Received %d users\", count)\n\n// Mark a single event (point in time)\nos_signpost(.event, log: log, name: \"CacheMiss\", \"Key: %{public}s\", cacheKey)\n\nViewing signposts:\n- In Instruments: Use the os_signpost instrument to see intervals on a timeline.\n- Points of Interest instrument shows events across the app.\n- Signposts are visualized as colored bars, making it easy to spot long operations.\n\nos_log for structured logging:\n\nlet logger = Logger(subsystem: \"com.app\", category: \"auth\")\nlogger.info(\"User logged in: \\(userId, privacy: .private)\")\nlogger.error(\"Token refresh failed: \\(error.localizedDescription)\")\nlogger.debug(\"Cache size: \\(cacheSize)\")\n\nLog levels: .debug (stripped in release), .info, .notice (default), .error, .fault.\n\nPrivacy: By default, dynamic string interpolations are redacted in release builds. Use privacy: .public to make them visible, or privacy: .private (default) for sensitive data.\n\nPerformance characteristics:\n- Signposts and os_log are designed to be extremely lightweight — they use the unified logging system with compile-time format strings.\n- When no tool is attached, signpost calls have near-zero overhead (they compile to a simple branch that's almost never taken).\n- Far more efficient than print() or NSLog.\n\nProduction use:\n- Signposts can be captured via MetricKit diagnostics payloads.\n- Use custom signpost intervals to track business-critical operations.\n- Log levels control what's persisted vs. only available during live debugging."
  },
  {
    "topic": "performance",
    "level": 3,
    "question": "What is MetricKit and how do you use it for production performance monitoring?",
    "hint": "Think about the daily diagnostic and metric payloads Apple delivers, covering launch time, hang rate, disk and memory usage.",
    "answer": "MetricKit (iOS 13+) provides aggregated performance and diagnostic data collected by the operating system from real user devices.\n\nSetup:\nimport MetricKit\n\nclass MetricSubscriber: NSObject, MXMetricManagerSubscriber {\n    func didReceive(_ payloads: [MXMetricPayload]) {\n        // Delivered once per day with aggregated metrics\n        for payload in payloads {\n            // App launch metrics\n            let launchTime = payload.applicationLaunchMetrics\n            let histogrammedResume = launchTime?.histogrammedResumeTime\n            \n            // Responsiveness\n            let hangTime = payload.applicationResponsivenessMetrics\n            \n            // Memory\n            let memory = payload.memoryMetrics?.peakMemoryUsage\n            \n            // Battery\n            let cpuTime = payload.cpuMetrics?.cumulativeCPUTime\n            let gpuTime = payload.gpuMetrics?.cumulativeGPUTime\n            \n            // Disk\n            let diskWrites = payload.diskIOMetrics?.cumulativeLogicalWrites\n            \n            // Network\n            let networkUp = payload.networkTransferMetrics?.cumulativeUpload\n        }\n    }\n    \n    func didReceive(_ payloads: [MXDiagnosticPayload]) {\n        // iOS 14+: Diagnostic reports\n        for payload in payloads {\n            let crashes = payload.crashDiagnostics\n            let hangs = payload.hangDiagnostics\n            let diskWrites = payload.diskWriteExceptionDiagnostics\n            let cpuExceptions = payload.cpuExceptionDiagnostics\n        }\n    }\n}\n\n// Register\nlet subscriber = MetricSubscriber()\nMXMetricManager.shared.add(subscriber)\n\nMetric categories:\n- MXAppLaunchMetric: Cold and warm launch durations as histograms.\n- MXAppResponsivenessMetric: Hang time (main thread blocked > 250ms on iOS 16+).\n- MXMemoryMetric: Peak memory usage, suspended memory.\n- MXCPUMetric: Cumulative CPU time, instruction count.\n- MXDiskIOMetric: Logical writes (excessive writes can trigger system throttling).\n- MXNetworkTransferMetric: Upload/download volume.\n- MXCellularConditionMetric: Cell signal quality distribution.\n- MXAnimationMetric (iOS 15+): Scroll and animation hitch rates.\n\nDiagnostic payloads (iOS 14+):\n- Crash reports with full stack traces.\n- Hang diagnostics with call stacks of the blocked main thread.\n- Disk write exception reports.\n- CPU exception reports.\n\nBest practices:\n- Forward payloads to your analytics backend as JSON (payload.jsonRepresentation()).\n- Combine with custom signpost metrics for app-specific measurements.\n- Use the Xcode Organizer to view aggregated MetricKit data from all users.\n- Set performance budgets and alert on regressions using the daily metrics."
  },
  {
    "topic": "performance",
    "level": 3,
    "question": "How do you optimize network performance for an iOS app using prefetching, pagination, and compression?",
    "hint": "Think about reducing latency with speculative prefetching, minimizing payload size with compression, and loading data incrementally.",
    "answer": "Network performance optimization reduces latency, bandwidth usage, and improves perceived speed.\n\nPrefetching:\n- Speculative prefetching: Predict what data the user will need next and fetch it before they navigate. Example: prefetch the next page of results while the user views the current page.\n- Use URLSession's waitsForConnectivity = true to queue requests when offline and execute when connected.\n- Implement priority-based prefetching: Cancel low-priority prefetches when high-priority requests come in.\n- iOS Background App Refresh: Use BGAppRefreshTask to prefetch content before the user opens the app.\n- Prefetch during idle time using low QoS:\nDispatchQueue.global(qos: .utility).async { prefetchNextContent() }\n\nPagination:\n- Cursor-based pagination: More stable than offset-based. Server returns a cursor token; client sends it for the next page. Handles insertions/deletions gracefully.\n- Offset/limit pagination: Simple but can skip or duplicate items if data changes between pages.\n- Implement in UI with infinite scroll: Trigger next page fetch when user scrolls within ~2 screen heights of the bottom.\n- Use prefetchRowsAt in table/collection views to trigger pagination automatically.\n- Cache page results locally for instant back-navigation.\n\nCompression:\n- HTTP compression: Set Accept-Encoding: gzip, br header. URLSession handles decompression automatically. Brotli (br) typically achieves 15-25% better compression than gzip.\n- Payload optimization: Request only needed fields from the API (sparse fieldsets, GraphQL). Use efficient serialization formats (Protocol Buffers, MessagePack) instead of JSON for bandwidth-sensitive operations.\n- Image compression: Request WebP or AVIF from CDNs. Use appropriate quality levels (80% JPEG is often visually identical to 100% at half the size).\n- Delta updates: Only fetch changed data since last sync. Use ETags and If-None-Match for conditional requests — server returns 304 Not Modified with empty body if data hasn't changed.\n\nConnection optimization:\n- HTTP/2 multiplexing reduces connection overhead.\n- URLSessionConfiguration.multipathServiceType = .handover for seamless WiFi-to-cellular transitions.\n- Combine multiple small API calls into batch endpoints to reduce round trips."
  },
  {
    "topic": "performance",
    "level": 4,
    "question": "Explain Swift performance characteristics: value types vs reference types, generics specialization, and whole module optimization.",
    "hint": "Think about stack vs heap allocation, the cost of reference counting, how the compiler can optimize generic code, and why WMO enables better cross-file optimization.",
    "answer": "Swift's performance model is heavily influenced by type system decisions and compiler optimizations.\n\nValue Types vs Reference Types:\n- Value types (structs, enums): Stored on the stack (when not captured or boxed). No reference counting overhead. Copied on assignment, but Swift uses copy-on-write (CoW) for large types like Array and Dictionary — actual copying is deferred until mutation.\n- Reference types (classes): Stored on the heap. Each strong reference requires atomic reference counting (retain/release), which involves expensive atomic CPU operations. Heap allocation requires lock coordination.\n- Performance implication: Value types can be significantly faster for small, frequently created objects due to stack allocation and lack of reference counting. The compiler can often optimize away copies entirely.\n- Caveat: Large structs containing reference types still incur reference counting for their reference-type properties. A struct with 5 String properties has 5x the retain/release cost of a class with 5 String properties.\n\nGenerics Specialization:\n- Unspecialized generics use a value witness table — a layer of indirection that handles memory layout, copying, and destruction for any type. This prevents inlining and direct memory access.\n- Specialization: When the compiler knows the concrete type at compile time, it generates a type-specific version of the function. func sort<T: Comparable>(_ array: [T]) becomes func sort(_ array: [Int]) with direct integer comparison.\n- Specialized code is dramatically faster — direct memory access, inlined comparisons, no witness table lookups.\n- Specialization happens automatically within a module. Across modules, it requires @inlinable annotation on the generic function.\n\nWhole Module Optimization (WMO):\n- Without WMO, each Swift file is compiled independently. The compiler can't see across file boundaries.\n- With WMO (-whole-module-optimization), the compiler processes all files in a module together, enabling:\n  - Cross-file inlining of functions.\n  - Cross-file generic specialization.\n  - More aggressive dead code elimination.\n  - Better devirtualization (replacing dynamic dispatch with static calls when the concrete type is known).\n  - Inferring final/private for classes/methods not subclassed or overridden.\n- Trade-off: WMO increases compile time (no incremental compilation). Use -Onone for debug, -O with WMO for release.\n\nAdditional optimizations:\n- final and private keywords help the compiler devirtualize method calls.\n- @frozen on structs in library evolution mode enables direct field access.\n- Existential types (any Protocol) require heap allocation for the existential container — prefer generics (some Protocol) when possible."
  },
  {
    "topic": "performance",
    "level": 4,
    "question": "How do you detect and fix hangs in an iOS app? Explain the Thread Performance Checker and hang detection strategies.",
    "hint": "Think about what constitutes a hang (main thread blocked beyond a threshold), how to identify the blocking call stack, and both development-time and production monitoring.",
    "answer": "A hang occurs when the main thread is blocked and unable to process events, making the app appear frozen.\n\nHang classification (iOS 16+):\n- Micro hang: 100ms-250ms — noticeable during interaction.\n- Severe hang: 250ms+ — clearly perceived as unresponsive.\n- Fatal hang: Multiple seconds — may trigger watchdog termination.\n\nThread Performance Checker (Xcode runtime tool):\n- Enabled in Scheme > Diagnostics > Thread Performance Checker.\n- Detects common threading issues at runtime:\n  - Main thread blocked by synchronous work (file I/O, network, database).\n  - Priority inversion (main thread waiting on low-priority queue).\n  - Disk I/O on the main thread.\n- Issues appear as purple runtime warnings in Xcode with stack traces.\n- Low overhead — can be left enabled during development.\n\nDetection strategies:\n\n1. Development — Instruments:\n- Time Profiler: Shows where CPU time is spent on the main thread.\n- System Trace: Reveals thread blocking, context switches, and priority inversions.\n- Animation Hitches instrument: Measures commit and render hitches.\n\n2. Production — MetricKit:\nfunc didReceive(_ payloads: [MXDiagnosticPayload]) {\n    for payload in payloads {\n        if let hangDiagnostics = payload.hangDiagnostics {\n            for diagnostic in hangDiagnostics {\n                let callStackTree = diagnostic.callStackTree\n                let hangDuration = diagnostic.hangDuration\n                // Send to analytics backend\n            }\n        }\n    }\n}\n\n3. Custom hang detection:\n- Use a watchdog thread that pings the main thread:\nclass HangDetector {\n    private var lastPong = Date()\n    func start() {\n        // Background thread checks main thread responsiveness\n        DispatchQueue.global().async {\n            while true {\n                var ponged = false\n                DispatchQueue.main.async { ponged = true }\n                Thread.sleep(forTimeInterval: 0.5)\n                if !ponged { self.reportHang() }\n            }\n        }\n    }\n}\n- Capture the main thread's call stack when a hang is detected using backtrace() or Thread.callStackSymbols.\n\nCommon hang causes and fixes:\n- Synchronous network calls on main thread → Use async/await or background queue.\n- Large Core Data fetches on main thread → Use NSAsynchronousFetchRequest or background context.\n- Image decoding → Use preparingForDisplay() or decode on background thread.\n- Lock contention → Use actors or fine-grained locks.\n- Excessive Auto Layout constraints → Simplify view hierarchy."
  },
  {
    "topic": "performance",
    "level": 4,
    "question": "How do you optimize Core Animation performance? Explain layer optimization, rendering pipeline, and avoiding hitches.",
    "hint": "Think about the commit and render phases, how layer tree complexity affects performance, and the difference between commit hitches and render hitches.",
    "answer": "Core Animation's rendering pipeline has two main phases, each with distinct optimization strategies.\n\nRendering Pipeline:\n1. Commit Phase (CPU, main thread):\n   - Layout: Calculate frames (Auto Layout constraint solving).\n   - Display: Draw layer contents (drawRect, attributed string rendering).\n   - Prepare: Image decoding, format conversion.\n   - Commit: Package layer tree and send to render server.\n\n2. Render Phase (GPU, render server process):\n   - Compositing: Combine layers into final image.\n   - Offscreen rendering when required.\n\nA hitch occurs when either phase takes longer than the frame deadline (16.67ms at 60fps).\n\nCommit Phase Optimization:\n- Flatten view hierarchy: Fewer views = less layout computation. Use layer.shouldRasterize for complex static subtrees to cache as a single bitmap.\n- Auto Layout: Reduce constraint count. Avoid inequality constraints. Use manual frame calculation for extremely performance-sensitive cells.\n- Avoid layoutIfNeeded() in animation blocks with complex hierarchies.\n- Batch UI updates: Set multiple properties before triggering layout, not one at a time.\n- Cache calculated layouts: If cell heights are known, return them immediately in heightForRow.\n\nRender Phase Optimization:\n- Minimize offscreen rendering passes:\n  - Set cornerRadius + layer.maskedCorners without clipsToBounds when possible.\n  - Always provide shadowPath for shadows.\n  - Avoid layer.mask when simpler alternatives exist.\n- Reduce blending: Set isOpaque = true, use solid backgrounds.\n- Avoid large layer sizes: Layers exceeding the GPU's maximum texture size (4096x4096 on most devices) force CPU rendering.\n- Use shouldRasterize = true for complex, infrequently changing layers. Set rasterizationScale = UIScreen.main.scale. But if content changes every frame, rasterization hurts performance (re-rasterizes each frame).\n\nDiagnosing hitches:\n- Instruments > Animation Hitches: Shows commit duration, render duration, and hitch ratio.\n- CAMetalLayer.presentsWithTransaction for synchronizing Metal and Core Animation.\n- Xcode Debug Navigator: Monitor GPU utilization in real-time.\n\nHitch ratio = total hitch time / total scroll duration. Target < 5ms/s for a smooth experience. Apple considers > 10ms/s to be a poor experience."
  },
  {
    "topic": "performance",
    "level": 5,
    "question": "How would you design a comprehensive performance monitoring and regression detection system for a large iOS app?",
    "hint": "Think about automated benchmarking in CI, production metric collection, baseline comparisons, alerting, and the complete infrastructure needed.",
    "answer": "A comprehensive performance system requires instrumentation, collection, analysis, and action across both development and production.\n\n1. Development-time Performance Testing:\n- XCTest performance tests: measure { } blocks with baselines set per device.\n  - Track metrics: wall clock, CPU time, memory peak, disk writes.\n  - Set standard deviation allowances; fail CI on regression.\n- Custom benchmark suite: Test critical user flows (app launch, feed scroll, search) with XCUITest + MetricKit.\n- Integration with CI: Run benchmarks on dedicated, consistent hardware (specific iPhone model, specific iOS version). Avoid simulators for performance tests.\n- Screenshot diffing for rendering regression (not directly performance, but related to render changes).\n\n2. Production Instrumentation:\n- MetricKit: Subscribe to daily metric and diagnostic payloads.\n- Custom signposts: os_signpost for business-critical operations (time-to-interactive, time-to-first-content, checkout flow duration).\n- Custom metrics collection:\n  struct PerformanceEvent: Codable {\n      let name: String\n      let durationMs: Double\n      let deviceModel: String\n      let osVersion: String\n      let appVersion: String\n      let isLowPowerMode: Bool\n      let thermalState: String\n      let memoryUsageMB: Double\n  }\n- Sample at an appropriate rate (not 100%) to control data volume.\n\n3. Data Pipeline:\n- Batch events and send compressed payloads on a low-priority queue.\n- Backend aggregates by: app version, device model, OS version, and user segment.\n- Compute percentiles: p50, p75, p90, p95, p99 for each metric.\n- Store time-series data for trend analysis.\n\n4. Baseline and Regression Detection:\n- Establish baselines per metric per app version.\n- Statistical regression detection: Compare current distribution against baseline using hypothesis testing (e.g., Mann-Whitney U test) rather than simple threshold checks.\n- Account for device mix changes — normalize metrics or segment by device class.\n- Detect both sudden regressions (new release) and gradual degradation (data growth over time).\n\n5. Alerting:\n- Alert on: p95 launch time > Xms, hang rate > Y%, memory terminations > Z per 1000 sessions, scroll hitch ratio exceeding threshold.\n- Differentiate between device-specific and universal regressions.\n- Link alerts to recent commits/PRs for fast attribution.\n\n6. Dashboard:\n- Real-time view of key metrics by app version during rollout.\n- Historical trends with release markers.\n- Device and OS breakdowns.\n- Comparison views: current vs previous version.\n\n7. Action Framework:\n- Performance budget per team/feature: Each team owns metrics for their features.\n- Automated rollback triggers for catastrophic regressions.\n- Weekly performance review with metric reports.\n- Binary size tracking per commit using CI artifacts."
  },
  {
    "topic": "performance",
    "level": 5,
    "question": "How do you optimize battery performance in an iOS app, and how do you measure energy impact?",
    "hint": "Think about CPU wake-ups, background activity, location services, network polling, and how Instruments Energy Log and MetricKit provide energy data.",
    "answer": "Battery optimization requires minimizing unnecessary CPU, GPU, radio, and sensor usage.\n\nKey battery drains and mitigations:\n\n1. CPU:\n- Minimize timer usage. Replace Timer.scheduledTimer with event-driven updates.\n- Use QoS classes properly: .background and .utility allow the system to defer work to energy-optimal times.\n- Batch processing: Accumulate work and process in bursts rather than frequent small tasks. The CPU enters low-power idle states between bursts.\n- Use Combine's .throttle() and .debounce() to reduce processing frequency.\n\n2. Networking:\n- Avoid polling. Use push notifications (APNs) or WebSockets for real-time data.\n- If polling is necessary, use exponential backoff and adjust intervals based on app activity.\n- Set waitsForConnectivity = true to avoid repeated failed connection attempts.\n- Use URLSession background sessions — the system coalesces transfers with other app traffic.\n- Enable HTTP/2 or HTTP/3 to reduce connection overhead.\n\n3. Location:\n- Use the minimum accuracy needed: kCLLocationAccuracyHundredMeters vs kCLLocationAccuracyBest (10x power difference).\n- Use significant location changes (CLLocationManager.startMonitoringSignificantLocationChanges) instead of continuous GPS.\n- Use region monitoring (geofencing) instead of continuous tracking when possible.\n- Call stopUpdatingLocation() as soon as you have the data you need.\n- Set allowsBackgroundLocationUpdates = false when not needed.\n- Use activityType to help the system optimize (e.g., .fitness vs .automotiveNavigation).\n\n4. Background Activity:\n- Use BGProcessingTask for heavy work — the system schedules it during charging.\n- Minimize background app refresh frequency.\n- Avoid using beginBackgroundTask for long-running work — it's meant for finishing short tasks.\n\n5. Display and GPU:\n- Reduce animation complexity and frame rate when not critical.\n- Use CADisplayLink's preferredFrameRateRange to lower refresh rate for subtle animations.\n- Dark mode reduces power on OLED screens.\n\nMeasurement:\n- Instruments Energy Log: Shows energy impact over time broken down by component (CPU, network, location, display, GPU). Shows overhead events (discrete CPU wakeups).\n- MetricKit MXCPUMetric and MXGPUMetric: Cumulative CPU/GPU time per day.\n- Xcode Energy Gauge: Real-time energy impact during debugging.\n- XCTest Energy metrics in measure blocks.\n- ProcessInfo.processInfo.isLowPowerMode: Reduce non-essential work when enabled.\n- ProcessInfo.processInfo.thermalState: Reduce activity during .serious or .critical thermal states to prevent throttling.\n\nBest practice: Profile energy on device with real workloads. Set energy budgets for features and track with MetricKit in production."
  },
  {
    "topic": "performance",
    "level": 5,
    "question": "Explain how you would diagnose and fix a complex memory issue involving retain cycles, abandoned memory, and fragmentation in a production iOS app.",
    "hint": "Think about the difference between leaked memory and abandoned memory, how to use Instruments generation analysis, runtime tools for finding retain cycles, and heap fragmentation effects.",
    "answer": "Complex memory issues require distinguishing between different types of memory growth and using appropriate tools for each.\n\nTypes of memory issues:\n\n1. Leaked Memory: Allocated memory with no remaining references. True leaks in Swift are rare due to ARC, but can occur with:\n- Retain cycles in closures (self → closure → self).\n- Retain cycles with delegates (strong delegate references).\n- Objective-C bridging issues.\n- Core Foundation objects not properly released.\n\n2. Abandoned Memory: Memory that is still referenced but will never be used again. More common and harder to detect than leaks. Example: growing caches without limits, appending to arrays that are never cleared, view controllers retained by notification observers.\n\n3. Fragmentation: Non-contiguous free memory blocks that prevent large allocations despite sufficient total free memory. Caused by frequent allocation/deallocation of varying sizes.\n\nDiagnosis workflow:\n\n1. Instruments Allocations:\n- Use Mark Generation (heapshot analysis): Mark after each user action cycle (navigate to screen, go back). Any growth between generations that doesn't decrease represents abandoned or leaked memory.\n- Filter by your app's classes. Sort by Persistent Bytes.\n- Drill into specific allocations to see their allocation backtrace.\n\n2. Instruments Leaks:\n- Detects reference cycles involving Objective-C objects (uses conservative garbage collector scan).\n- May miss Swift-only retain cycles — supplement with manual analysis.\n\n3. Memory Graph Debugger (Xcode):\n- Debug > Debug Memory Graph while the app is running.\n- Shows all live objects and their references.\n- Highlights retain cycles with warning icons.\n- Export as .memgraph file for command-line analysis: leaks --outputGraph=output.memgraph\n- vmmap --summary process_name shows memory region breakdown.\n- heap --sortBySize process_name lists largest allocations.\n- malloc_history for tracking specific allocation origins.\n\n4. Production detection:\n- Monitor os_proc_available_memory() periodically and report to analytics.\n- Track memory footprint growth per session.\n- MetricKit MXMemoryMetric for peak usage and suspended memory.\n- Implement a custom abandoned memory detector: periodically snapshot live object counts by class and report unexpected growth.\n\nFixing retain cycles:\n- Use [weak self] in closures that outlive the caller.\n- Use [unowned self] only when you can guarantee self outlives the closure.\n- Make delegates weak: weak var delegate: MyDelegate?\n- Use Combine's .store(in: &cancellables) and ensure cancellables are cleared on deinit.\n- For complex cycles, break them explicitly in appropriate lifecycle methods.\n\nFixing abandoned memory:\n- Set NSCache limits: totalCostLimit and countLimit.\n- Implement LRU eviction for custom caches.\n- Clear data structures when leaving screens (in viewDidDisappear or deinit).\n- Remove notification observers (especially NotificationCenter).\n- Cancel network tasks when their results are no longer needed.\n\nAddressing fragmentation:\n- Use memory pools (allocate large blocks and subdivide) for high-frequency, same-sized allocations.\n- Prefer contiguous collections (Array) over linked structures.\n- Reuse objects (pool pattern) instead of frequent alloc/dealloc.\n- Use autoreleasepool in tight loops to release intermediate objects promptly rather than letting them accumulate."
  },
  {
    "topic": "uikit",
    "level": 0,
    "question": "What are the main stages of a UIViewController's lifecycle, and in what order are they called?",
    "hint": "Think about what happens from the moment a view controller is instantiated to when its view appears on screen and eventually disappears.",
    "answer": "The main UIViewController lifecycle methods are called in this order:\n\n1. init(coder:) or init(nibName:bundle:) — The view controller is instantiated.\n2. loadView() — The system calls this to create the view controller's view. Override it only if you create your view hierarchy entirely in code (do not call super in that case).\n3. viewDidLoad() — Called once after the view is loaded into memory. Use it for one-time setup like adding subviews, configuring data sources, or setting up constraints.\n4. viewWillAppear(_:) — Called every time the view is about to become visible. Good for refreshing data or updating UI state.\n5. viewDidAppear(_:) — Called after the view is fully visible and on screen. Use it for starting animations, timers, or analytics tracking.\n6. viewWillDisappear(_:) — Called when the view is about to be removed from the view hierarchy. Save state or stop timers here.\n7. viewDidDisappear(_:) — Called after the view has been fully removed from the screen.\n\nAdditionally, viewWillLayoutSubviews() and viewDidLayoutSubviews() are called whenever the view's bounds change, such as during rotation or when a subview's frame changes."
  },
  {
    "topic": "uikit",
    "level": 0,
    "question": "What is the difference between frame and bounds in UIView?",
    "hint": "Think about which coordinate system each property references — the superview's or the view's own.",
    "answer": "frame and bounds are both CGRect properties on UIView, but they reference different coordinate systems:\n\n- frame describes the view's location and size in its superview's coordinate system. It defines where the view is positioned relative to its parent. Changing the frame moves or resizes the view within the superview.\n\n- bounds describes the view's own internal coordinate system. Its origin is typically (0, 0) and its size defines the drawable area inside the view. Changing the bounds origin scrolls the content inside the view (this is how UIScrollView works internally). Changing the bounds size can affect the view's size.\n\nKey differences:\n- When you rotate a view using a transform, the frame becomes an axis-aligned bounding rectangle that encloses the rotated view, so it may grow larger. The bounds remain unchanged.\n- frame is undefined (unreliable) when a non-identity transform is applied.\n- Use frame when positioning a view within its parent. Use bounds when working with content inside the view itself."
  },
  {
    "topic": "uikit",
    "level": 0,
    "question": "What is a UINavigationController, and how does its view controller stack work?",
    "hint": "Think about the push/pop model and how it manages a stack of child view controllers.",
    "answer": "UINavigationController is a container view controller that manages a stack of child view controllers in a navigation hierarchy. It provides a navigation bar at the top and optionally a toolbar at the bottom.\n\nHow the stack works:\n- The stack is a LIFO (last-in, first-out) structure. The first view controller added is the root view controller and stays at the bottom of the stack.\n- pushViewController(_:animated:) adds a new view controller on top of the stack and transitions to it with a slide animation.\n- popViewController(animated:) removes the top view controller and returns to the previous one.\n- popToRootViewController(animated:) removes all view controllers except the root.\n- popToViewController(_:animated:) pops back to a specific view controller in the stack.\n- The viewControllers property provides direct access to the entire stack array and can be set directly for custom navigation flows.\n\nThe navigation bar automatically displays a back button when there is more than one view controller on the stack. Each view controller can customize its navigationItem to set its title, bar button items, and other navigation bar properties. The navigation controller also calls the appropriate lifecycle methods (viewWillAppear, viewDidDisappear, etc.) on child view controllers as they are pushed and popped."
  },
  {
    "topic": "uikit",
    "level": 0,
    "question": "What is a UIStackView and what are the key properties that control its layout behavior?",
    "hint": "Consider the four main properties: axis, distribution, alignment, and spacing.",
    "answer": "UIStackView is a non-rendering container view that manages the layout of its arranged subviews in either a horizontal or vertical line. It simplifies Auto Layout by automatically creating and managing the constraints for its children.\n\nKey properties:\n\n1. axis (.horizontal or .vertical) — Determines whether arranged subviews are laid out side by side or stacked on top of each other.\n\n2. distribution — Controls how arranged subviews are sized along the stack's axis:\n   - .fill — Views stretch to fill the available space; priorities and intrinsic content sizes determine which view stretches.\n   - .fillEqually — All views are sized equally along the axis.\n   - .fillProportionally — Views are sized proportionally based on their intrinsic content size.\n   - .equalSpacing — Views keep their intrinsic sizes; extra space becomes equal spacing.\n   - .equalCentering — Views are positioned so their centers are equally spaced.\n\n3. alignment — Controls positioning perpendicular to the axis:\n   - .fill — Views stretch to fill the cross axis.\n   - .leading/.trailing, .top/.bottom — Views align to one edge.\n   - .center — Views are centered on the cross axis.\n   - .firstBaseline/.lastBaseline — For horizontal stacks, aligns text baselines.\n\n4. spacing — The minimum spacing (in points) between adjacent arranged subviews.\n\nSince UIStackView does not render itself (no background, border, etc.), it has minimal performance overhead. You add views with addArrangedSubview(_:) and remove them with removeArrangedSubview(_:). Hiding an arranged subview automatically recalculates the layout as if the view were removed."
  },
  {
    "topic": "uikit",
    "level": 1,
    "question": "Explain the UIView rendering cycle. What are the roles of setNeedsLayout, layoutIfNeeded, setNeedsDisplay, and draw(_:)?",
    "hint": "Think about the two separate pipelines: layout and display, and how they are batched by the run loop.",
    "answer": "UIView's rendering cycle has two distinct pipelines that are batched for efficiency by the run loop:\n\n**Layout Pipeline:**\n- setNeedsLayout() — Marks the view as needing a layout update. It does not trigger layout immediately; instead it sets a flag so the system processes layout on the next run loop iteration. This is safe to call multiple times without performance concern.\n- layoutIfNeeded() — Forces the view to lay out its subviews immediately if a layout pass has been requested. Unlike setNeedsLayout(), this is synchronous. It is commonly used inside animation blocks to animate constraint changes.\n- layoutSubviews() — The method the system calls when performing layout. Override this to perform custom layout logic. Always call super.\n\nThe typical pattern for animating constraint changes is: modify constraints, then call UIView.animate { self.view.layoutIfNeeded() }.\n\n**Display Pipeline:**\n- setNeedsDisplay() — Marks the view as needing a redraw. Like setNeedsLayout(), it is deferred to the next drawing cycle.\n- draw(_:) — Called by the system when the view needs to render its content using Core Graphics. You override this for custom drawing. Never call draw(_:) directly; always call setNeedsDisplay() instead.\n\n**The full cycle per run loop iteration:**\n1. Constraints are updated (updateConstraints, from leaves to root).\n2. Layout is performed (layoutSubviews, from parent to children).\n3. Display/drawing is performed (draw(_:), from parent to children).\n\nThis batching ensures multiple changes within one run loop turn are coalesced into a single layout and draw pass, improving performance."
  },
  {
    "topic": "uikit",
    "level": 1,
    "question": "What is Auto Layout's intrinsicContentSize, and how does it interact with content hugging and compression resistance priorities?",
    "hint": "Think about what a view 'wants' to be sized at versus what constraints force it to be, and what happens when space is too large or too small.",
    "answer": "intrinsicContentSize is a CGSize that represents the natural size a view prefers based on its content. For example, a UILabel's intrinsic content size is determined by its text and font, and a UIImageView's by its image dimensions. Not all views have an intrinsic content size — a plain UIView returns (UIView.noIntrinsicMetric, UIView.noIntrinsicMetric).\n\nWhen a view has an intrinsic content size, Auto Layout internally creates two pairs of inequality constraints per axis:\n- Content Hugging: The view should not grow larger than its intrinsic size. It resists expansion. A higher priority means the view more strongly resists being stretched.\n- Compression Resistance: The view should not shrink smaller than its intrinsic size. It resists compression. A higher priority means the view more strongly resists being squeezed.\n\nPractical implications:\n- When two labels are side by side in a horizontal stack and there is extra space, the label with the lower content hugging priority will stretch to fill the remaining space.\n- When two labels are side by side and there is not enough space, the label with the lower compression resistance priority will be compressed (truncated) first.\n\nDefault priorities:\n- Content hugging: 250 (UILayoutPriority.defaultLow)\n- Compression resistance: 750 (UILayoutPriority.defaultHigh)\n\nYou set these using setContentHuggingPriority(_:for:) and setContentCompressionResistancePriority(_:for:). If you want a label to maintain its size while another stretches, raise its content hugging priority or lower the other's.\n\nTo provide a custom intrinsic content size for a custom UIView subclass, override intrinsicContentSize and call invalidateIntrinsicContentSize() whenever the content changes."
  },
  {
    "topic": "uikit",
    "level": 1,
    "question": "How do UITableView and UICollectionView cell reuse mechanisms work, and why are they important?",
    "hint": "Think about the registration-dequeue pattern and what happens to cells that scroll off screen.",
    "answer": "Both UITableView and UICollectionView use a cell reuse mechanism to efficiently display large amounts of content by maintaining a pool of reusable cell objects instead of creating new ones for every item.\n\nHow it works:\n\n1. Registration — You register a cell class or nib with a reuse identifier:\n   tableView.register(MyCell.self, forCellReuseIdentifier: \"MyCell\")\n   collectionView.register(MyCell.self, forCellWithReuseIdentifier: \"MyCell\")\n\n2. Dequeuing — In your data source method, you dequeue a cell:\n   let cell = tableView.dequeueReusableCell(withIdentifier: \"MyCell\", for: indexPath)\n   The system either returns a recycled cell from the reuse pool or creates a new one if the pool is empty.\n\n3. Recycling — When a cell scrolls off screen, it is not deallocated. Instead, it is placed into the reuse pool associated with its reuse identifier. The cell's prepareForReuse() method is called, giving you a chance to reset the cell's state (clear images, reset labels, cancel pending network requests).\n\n4. Configuration — After dequeuing, you configure the cell with data for the current index path. You must set ALL properties because the cell may carry stale data from its previous use.\n\nWhy it matters:\n- Memory efficiency: Only a handful of cells exist in memory at any time (roughly the number visible on screen plus a small buffer), regardless of whether the data source has 10 or 10,000 items.\n- Performance: Creating and destroying views is expensive. Reusing them avoids repeated allocation, layout, and rendering costs.\n\nCommon pitfalls:\n- Forgetting to reset state in prepareForReuse() or cellForRowAt, causing old data to appear in recycled cells.\n- Starting async image loads without canceling previous ones, leading to flickering or incorrect images."
  },
  {
    "topic": "uikit",
    "level": 1,
    "question": "What are gesture recognizers in UIKit, and how do multiple gesture recognizers interact?",
    "hint": "Consider UIGestureRecognizer subclasses, their state machine, and delegate methods for simultaneous recognition.",
    "answer": "Gesture recognizers are objects that decouple touch-handling logic from views. Instead of overriding touchesBegan/Moved/Ended on UIView, you attach UIGestureRecognizer subclasses to views.\n\nBuilt-in subclasses include:\n- UITapGestureRecognizer — Detects single or multiple taps.\n- UILongPressGestureRecognizer — Detects long press and hold.\n- UIPanGestureRecognizer — Detects dragging/panning.\n- UIPinchGestureRecognizer — Detects pinch-to-zoom.\n- UIRotationGestureRecognizer — Detects two-finger rotation.\n- UISwipeGestureRecognizer — Detects swipes in a specific direction.\n- UIScreenEdgePanGestureRecognizer — Detects pans starting from a screen edge.\n\nGesture recognizers have a state machine:\n- Discrete gestures (tap, swipe): .possible → .recognized or .failed\n- Continuous gestures (pan, pinch): .possible → .began → .changed → .ended (or .cancelled)\n\nMultiple gesture recognizer interaction:\n- By default, only one gesture recognizer can recognize at a time. When one recognizes, others transition to .failed.\n- To allow simultaneous recognition, implement the UIGestureRecognizerDelegate method gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:) and return true.\n- require(toFail:) creates a dependency: one gesture waits until another fails before it can recognize. This is used to distinguish single taps from double taps.\n- shouldRequireFailure(of:) and shouldBeRequiredToFail(by:) provide class-level failure requirement logic.\n\nGesture recognizers participate in the hit-testing and touch-delivery process. They receive touches before the view does, and by default, when a gesture is recognized, the remaining touches are cancelled on the view (cancelsTouchesInView = true)."
  },
  {
    "topic": "uikit",
    "level": 2,
    "question": "Explain how Auto Layout constraints work with layout anchors. How do you create constraints programmatically, and what are common pitfalls?",
    "hint": "Think about translatesAutoresizingMaskIntoConstraints, NSLayoutAnchor types, and constraint activation.",
    "answer": "Layout anchors provide a type-safe, readable API for creating Auto Layout constraints programmatically. Every UIView has anchor properties like topAnchor, bottomAnchor, leadingAnchor, trailingAnchor, widthAnchor, heightAnchor, centerXAnchor, centerYAnchor, and more.\n\nCreating constraints:\n\nview.translatesAutoresizingMaskIntoConstraints = false\nNSLayoutConstraint.activate([\n    childView.topAnchor.constraint(equalTo: parentView.topAnchor, constant: 16),\n    childView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    childView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    childView.heightAnchor.constraint(equalToConstant: 44)\n])\n\nAnchor types are strongly typed:\n- NSLayoutXAxisAnchor (leading, trailing, centerX) can only constrain to other X-axis anchors.\n- NSLayoutYAxisAnchor (top, bottom, centerY) can only constrain to other Y-axis anchors.\n- NSLayoutDimension (width, height) can constrain to other dimensions or to constants.\nThis prevents nonsensical constraints like constraining a view's top to another view's leading edge at compile time.\n\nCommon pitfalls:\n\n1. Forgetting to set translatesAutoresizingMaskIntoConstraints = false. Without this, the system generates constraints from the autoresizing mask that conflict with your manual constraints.\n\n2. Not activating constraints. Creating a constraint does not apply it — you must set isActive = true or use NSLayoutConstraint.activate(). Never use addConstraint() directly on views.\n\n3. Ambiguous layout. If you do not provide enough constraints to fully determine position and size, the layout is ambiguous. Use hasAmbiguousLayout and exerciseAmbiguityInLayout() for debugging.\n\n4. Conflicting constraints. When constraints are unsatisfiable, Auto Layout breaks one at runtime and logs a warning. Use priorities (1-1000) to indicate which constraints can be broken. Required priority is 1000.\n\n5. Constraint references. If you need to animate or change constraints later, keep a reference to the constraint and modify its constant or isActive property. Do not recreate constraints repeatedly.\n\n6. Safe area considerations. Use safeAreaLayoutGuide instead of the view's own anchors to respect notches, home indicators, and navigation bars."
  },
  {
    "topic": "uikit",
    "level": 2,
    "question": "What are diffable data sources in UIKit, and how do they improve upon traditional UITableViewDataSource/UICollectionViewDataSource?",
    "hint": "Think about NSDiffableDataSourceSnapshot, Hashable requirements, and how diffable data sources eliminate common batch update crashes.",
    "answer": "Diffable data sources (UITableViewDiffableDataSource and UICollectionViewDiffableDataSource), introduced in iOS 13, provide a declarative approach to managing data for table and collection views.\n\nTraditional approach problems:\n- You had to implement numberOfSections, numberOfItemsInSection, and cellForItemAt.\n- When data changed, you called performBatchUpdates with manual insertions, deletions, and moves. Getting the order of operations wrong or having a mismatch between your data model and the update calls caused crashes like 'Invalid update: invalid number of items.'\n- Maintaining consistency between your data model and the UI was error-prone.\n\nDiffable data source approach:\n\n1. Define your section and item types, both conforming to Hashable:\n   enum Section: Hashable { case main }\n   struct Item: Hashable { let id: UUID; let title: String }\n\n2. Create the data source with a cell provider closure:\n   let dataSource = UITableViewDiffableDataSource<Section, Item>(tableView: tableView) { tableView, indexPath, item in\n       let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n       cell.textLabel?.text = item.title\n       return cell\n   }\n\n3. Apply snapshots to update the UI:\n   var snapshot = NSDiffableDataSourceSnapshot<Section, Item>()\n   snapshot.appendSections([.main])\n   snapshot.appendItems(items, toSection: .main)\n   dataSource.apply(snapshot, animatingDifferences: true)\n\nBenefits:\n- No more batch update crashes. The diffable data source computes the diff between the current and new snapshots automatically and generates the correct insertions, deletions, moves, and reloads.\n- Animations are handled automatically.\n- Thread-safe: snapshots can be created on background threads (call apply on the main thread or set the data source to apply on background queues).\n- Single source of truth: the snapshot IS the data state.\n\nIn iOS 15+, reconfigureItems(_:) was added to allow updating cell content without reloading (and losing cell state). SectionSnapshotDataSource was added for outline-style hierarchical data."
  },
  {
    "topic": "uikit",
    "level": 2,
    "question": "What is the responder chain in UIKit, and how does event handling flow through it?",
    "hint": "Consider UIResponder, first responder, hit testing, and how unhandled events propagate up the chain.",
    "answer": "The responder chain is a linked list of UIResponder objects that defines the path an event follows when no specific target is designated to handle it. UIView, UIViewController, UIWindow, UIApplication, and UIApplicationDelegate are all UIResponder subclasses.\n\nEvent delivery consists of two phases:\n\n1. Hit Testing (finding the target view):\n   - When a touch occurs, the system calls hitTest(_:with:) on the window.\n   - hitTest traverses the view hierarchy from front to back (reverse order of subviews) using point(inside:with:) to find the deepest view that contains the touch point.\n   - Views that are hidden, have user interaction disabled, or have alpha below 0.01 are excluded from hit testing.\n   - The deepest qualifying view becomes the first responder for that touch.\n\n2. Responder Chain Traversal:\n   - If the hit-test view does not handle the event (does not override the relevant method or does not have a gesture recognizer), the event propagates up the responder chain.\n   - The chain typically follows: Hit-test view → superview → ... → root view → view controller → parent view controller → ... → window → UIApplication → app delegate.\n   - For actions sent with target nil (like menu commands), the system walks the responder chain starting from the first responder until it finds an object that implements the action selector.\n\nPractical uses:\n- Target-action with nil target: UIControl.sendAction(_:to:from:for:) with nil target sends the action up the responder chain.\n- Input views: The first responder determines which keyboard or input view appears.\n- Undo management: Each responder can provide its own UndoManager.\n- Key commands: UIKeyCommand objects on responders allow hardware keyboard shortcuts.\n- canPerformAction(_:withSender:) determines whether a responder can handle a given action, enabling or disabling menu items dynamically.\n\nYou can override the next property on UIResponder to customize the chain, though this is rarely needed."
  },
  {
    "topic": "uikit",
    "level": 2,
    "question": "What are trait collections in UIKit, and how are they used for adaptive interfaces?",
    "hint": "Think about UITraitCollection, size classes, traitCollectionDidChange, and how traits propagate through the view hierarchy.",
    "answer": "UITraitCollection is an object that encapsulates the environmental characteristics of a view or view controller: display scale, size classes, user interface style (light/dark), preferred content size, layout direction, device idiom, and more.\n\nKey traits:\n- horizontalSizeClass / verticalSizeClass: .compact or .regular. iPhones in portrait have compact horizontal, regular vertical. iPads typically have regular for both. These enable adaptive layouts.\n- userInterfaceStyle: .light or .dark. Enables dark mode support.\n- preferredContentSizeCategory: Reflects the user's Dynamic Type preference.\n- displayScale: 1x, 2x, or 3x for image resolution selection.\n- userInterfaceIdiom: .phone, .pad, .mac, .tv, .carPlay, .vision.\n\nTrait propagation:\n- Traits flow from UIScreen → UIWindowScene → UIWindow → root UIViewController → child view controllers → UIViews. Each level can override traits for its children using setOverrideTraitCollection(_:forChild:) (pre-iOS 17) or the new UIMutableTraits API (iOS 17+).\n\nResponding to trait changes:\n- Pre-iOS 17: Override traitCollectionDidChange(_:) and compare traits to detect changes. Always call super.\n- iOS 17+: Use registerForTraitChanges([UITrait.self]) { (self: Self, previousTraitCollection) in ... } for more targeted, closure-based registration.\n\nUsage patterns:\n- Adaptive images: UIImage asset catalogs automatically select variants based on traits (scale, gamut, size class).\n- Dynamic colors: UIColor supports dynamic providers that return different colors based on traits: UIColor { traitCollection in traitCollection.userInterfaceStyle == .dark ? .white : .black }.\n- Adaptive layouts: Use trait collections in combination with Auto Layout constraints that activate/deactivate based on size classes, or configure different layouts in Interface Builder for different size classes.\n- UIAppearance: appearance(for:) can target specific trait collections.\n\nTraits are immutable; to create custom combinations, use UITraitCollection(traitsFrom: [collection1, collection2]) where later collections override earlier ones."
  },
  {
    "topic": "uikit",
    "level": 3,
    "question": "Explain UICollectionViewCompositionalLayout. How does its section-group-item model work, and what are its advantages over UICollectionViewFlowLayout?",
    "hint": "Think about NSCollectionLayoutItem, NSCollectionLayoutGroup, NSCollectionLayoutSection, fractional sizes, and orthogonal scrolling.",
    "answer": "UICollectionViewCompositionalLayout, introduced in iOS 13, is a highly flexible layout system built around a hierarchical model of items, groups, and sections.\n\nThe hierarchy:\n\n1. NSCollectionLayoutItem — Represents a single cell. You define its size using NSCollectionLayoutSize with width and height dimensions. Dimensions can be:\n   - .fractionalWidth(0.5) — 50% of the container's width.\n   - .fractionalHeight(1.0) — 100% of the container's height.\n   - .absolute(200) — Fixed 200 points.\n   - .estimated(100) — Starts at 100 and grows based on content (self-sizing).\n\n2. NSCollectionLayoutGroup — Contains items and arranges them. Can be horizontal, vertical, or custom. Groups define how items tile within a row or column:\n   - .horizontal(layoutSize:subitems:) — Items laid out horizontally.\n   - .vertical(layoutSize:subitems:) — Items laid out vertically.\n   Groups can be nested inside other groups for complex layouts.\n\n3. NSCollectionLayoutSection — Contains groups and represents a distinct region of the layout. Each section can have entirely different layouts. Sections support:\n   - contentInsets and interGroupSpacing.\n   - Orthogonal scrolling: section.orthogonalScrollingBehavior = .continuous makes the section scroll horizontally while the overall collection view scrolls vertically.\n   - Boundary supplementary items (headers, footers) and decoration items (backgrounds).\n\nCreating the layout:\n   let layout = UICollectionViewCompositionalLayout { sectionIndex, environment in\n       // Return a different NSCollectionLayoutSection per section index\n   }\nThe closure receives a NSCollectionLayoutEnvironment that provides the container's size and trait collection for adaptive layouts.\n\nAdvantages over UICollectionViewFlowLayout:\n- Per-section layouts: Each section can have a completely different layout. FlowLayout applies one layout to the entire collection.\n- No subclassing: Complex layouts are described declaratively without overriding layoutAttributesForElements(in:).\n- Orthogonal scrolling built in: Creating horizontally scrolling sections within a vertical collection is trivial.\n- Self-sizing with estimated dimensions works seamlessly.\n- Nested groups enable grid, waterfall, and mosaic layouts without custom calculations.\n- Section-level supplementary and decoration items are straightforward.\n\nCompositional layout can replicate any FlowLayout design and far exceed it, and is Apple's recommended approach for all new collection view layouts."
  },
  {
    "topic": "uikit",
    "level": 3,
    "question": "How does UIAppearance work, and what are its limitations?",
    "hint": "Think about appearance proxies, containerClass scoping, when appearance changes take effect, and what kinds of properties it supports.",
    "answer": "UIAppearance is a protocol that allows you to set default visual properties on all instances of a UIView subclass without modifying each instance individually. It uses the appearance proxy pattern.\n\nBasic usage:\n   UINavigationBar.appearance().tintColor = .red\n   UIButton.appearance().setTitleColor(.blue, for: .normal)\n\nThis sets the tint color for ALL navigation bars and button title color for ALL buttons in the app.\n\nContainer-scoped appearance:\n   UIBarButtonItem.appearance(whenContainedInInstancesOf: [UINavigationBar.self]).tintColor = .green\nThis applies only to bar button items within navigation bars.\n\nHow it works internally:\n- appearance() returns a proxy object, not an actual instance. Property setters called on the proxy are recorded.\n- When a UIView is added to a window (moved to the view hierarchy), the system applies the recorded appearance settings. This is why changes do not immediately affect views already on screen — you must remove and re-add them, or the changes take effect for newly created instances.\n\nLimitations:\n\n1. Only works with UI_APPEARANCE_SELECTOR annotated methods. Not all properties support it. In practice, this means properties exposed to Objective-C with the right annotation. Custom Swift-only properties do not work unless explicitly bridged.\n\n2. Timing: Changes only apply when views are added to a window. Existing views are not updated. To force an update, you can remove the view from its superview and re-add it, or remove the view controller and push it again.\n\n3. Performance: Overusing appearance proxies with deep container hierarchies can slow view setup.\n\n4. Debugging: Since appearance is applied implicitly, it can be hard to trace where a visual property is being set. It can conflict with explicit property settings if the order is not understood.\n\n5. Trait-specific appearance: appearance(for: UITraitCollection) allows trait-specific defaults (e.g., different colors for dark mode), but UIColor dynamic providers are generally preferred for dark mode support.\n\n6. No removal API: Once set, you cannot easily 'un-set' an appearance property. You must set it to another value explicitly."
  },
  {
    "topic": "uikit",
    "level": 3,
    "question": "How do UIView animations work under the hood? Compare UIView.animate block-based animations with UIViewPropertyAnimator.",
    "hint": "Think about Core Animation implicit animations, CATransaction, timing curves, interruptibility, and scrubbing.",
    "answer": "UIView animations are built on top of Core Animation (CAAnimation). When you modify animatable properties inside an animation block, UIKit creates CABasicAnimation objects on the view's backing CALayer.\n\nUIView.animate block-based API:\n   UIView.animate(withDuration: 0.3, delay: 0, options: [.curveEaseInOut]) {\n       view.alpha = 0\n       view.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)\n   } completion: { finished in\n       view.removeFromSuperview()\n   }\n- Simple, declarative, fire-and-forget.\n- The model layer is updated immediately; the animation is applied to the presentation layer.\n- Supports spring animations via UIView.animate(withDuration:delay:usingSpringWithDamping:initialSpringVelocity:...).\n- Options like .autoreverse, .repeat, .allowUserInteraction, .beginFromCurrentState.\n- Limited interruptibility: Starting a new animation while one is running can cause jumps unless .beginFromCurrentState is used.\n\nUIViewPropertyAnimator (iOS 10+):\n   let animator = UIViewPropertyAnimator(duration: 0.3, curve: .easeInOut) {\n       view.alpha = 0\n   }\n   animator.startAnimation()\n\nKey advantages:\n1. Interruptible: You can pause (.pauseAnimation()), reverse (.isReversed = true), or stop an animation at any point. The animation gracefully transitions.\n2. Scrubbable: Set fractionComplete (0.0 to 1.0) to scrub through the animation manually — perfect for interactive transitions driven by gestures.\n3. Custom timing: Supports UITimingCurveProvider including UICubicTimingParameters and UISpringTimingParameters. You can create custom bezier curves.\n4. Additive animations: Multiple property animators can target the same view simultaneously and their effects are combined.\n5. Completion flexibility: addCompletion { position in } gives you the finishing position (.end, .start, .current).\n6. State machine: The animator has clear states — .inactive, .active, .stopped — making it easier to reason about complex animation sequences.\n\nUnder the hood, both approaches create CAAnimation objects. The key difference is that UIViewPropertyAnimator wraps them in a controllable, interactive interface. Property animators are essential for custom view controller transitions and interactive dismiss gestures."
  },
  {
    "topic": "uikit",
    "level": 3,
    "question": "How do you implement a custom UIPresentationController, and what responsibilities does it have?",
    "hint": "Think about the chrome around a presented view controller — dimming views, custom frames, and adaptation.",
    "answer": "UIPresentationController manages the presentation chrome and lifecycle of a presented view controller. It controls the visual elements surrounding the presented content (dimming views, shadows, custom frames) and handles adaptation to size class changes.\n\nTo implement a custom presentation:\n\n1. Subclass UIPresentationController and override key methods:\n\n   - frameOfPresentedViewInContainerView — Returns the CGRect where the presented view should be positioned. For a half-sheet, you might return the bottom half of the container.\n\n   - presentationTransitionWillBegin() — Called when the presentation starts. Add chrome (dimming view, background blur) to the containerView and animate it alongside the transition using presentedViewController.transitionCoordinator.\n\n   - presentationTransitionDidEnd(_ completed: Bool) — Clean up if the transition was cancelled (completed == false).\n\n   - dismissalTransitionWillBegin() — Animate chrome removal alongside the dismissal.\n\n   - dismissalTransitionDidEnd(_ completed: Bool) — Remove chrome views when dismissal completes.\n\n   - containerViewWillLayoutSubviews() / containerViewDidLayoutSubviews() — Update frames when the container size changes (rotation, multitasking).\n\n   - shouldRemovePresentersView — Return true if the presenting view controller's view should be removed from the hierarchy during presentation (like fullscreen). Default is false (the presenting view remains visible behind, as in a sheet).\n\n2. Set up the transitioning delegate on the presented view controller:\n   presentedVC.modalPresentationStyle = .custom\n   presentedVC.transitioningDelegate = self\n\n3. In the transitioning delegate, return your custom presentation controller:\n   func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -> UIPresentationController? {\n       return MyPresentationController(presentedViewController: presented, presenting: presenting)\n   }\n\nUIPresentationController also supports adaptation: override adaptivePresentationStyle(for:traitCollection:) to change the presentation style when traits change (e.g., switch from popover to full screen on compact width). You can provide an entirely different view controller via presentedViewController(forAdaptivePresentationStyle:) if needed.\n\nThe presentation controller lives for the entire duration of the presentation, unlike transitioning animators which are transient. This makes it the right place for managing persistent chrome elements."
  },
  {
    "topic": "uikit",
    "level": 4,
    "question": "How do you implement fully custom interactive view controller transitions? Describe the roles of UIViewControllerTransitioningDelegate, UIViewControllerAnimatedTransitioning, and UIViewControllerInteractiveTransitioning.",
    "hint": "Think about the separation of concerns: who decides which animator to use, who performs the animation, and who drives the interaction based on gestures.",
    "answer": "Custom view controller transitions in UIKit are built on three protocols that separate concerns cleanly:\n\n1. UIViewControllerTransitioningDelegate — The coordinator. Set on the presented/pushed view controller's transitioningDelegate (for modal) or on the navigation controller's delegate (for push/pop). It vends the appropriate objects:\n   - animationController(forPresented:presenting:source:) → returns a UIViewControllerAnimatedTransitioning for presentation.\n   - animationController(forDismissed:) → returns one for dismissal.\n   - interactionControllerForPresentation/Dismissal(using:) → returns a UIViewControllerInteractiveTransitioning to make the transition gesture-driven. Return nil for non-interactive.\n   - presentationController(forPresented:presenting:source:) → returns a custom UIPresentationController.\n\n2. UIViewControllerAnimatedTransitioning — The animator. Responsible for the actual animation:\n   - transitionDuration(using:) → returns the animation duration.\n   - animateTransition(using: UIViewControllerContextTransitioning) → performs the animation. The context provides:\n     - containerView: the view in which the transition happens.\n     - viewController(forKey: .from/.to): the participating view controllers.\n     - view(forKey: .from/.to): their views.\n     - initialFrame(for:) / finalFrame(for:): where views should start and end.\n   - You must call context.completeTransition(!context.transitionWasCancelled) when done.\n   - Optionally implement interruptibleAnimator(using:) (iOS 10+) to return a UIViewPropertyAnimator, enabling interruptible transitions.\n\n3. UIViewControllerInteractiveTransitioning — The interaction driver. Typically you use the concrete subclass UIPercentDrivenInteractiveTransition:\n   - Attach a UIPanGestureRecognizer to the view.\n   - On .began: Start the dismiss/pop (dismiss(animated:) or popViewController(animated:)).\n   - On .changed: Calculate progress (0.0–1.0) from the gesture translation and call update(progress).\n   - On .ended: Call finish() if progress > threshold, otherwise cancel().\n   - UIPercentDrivenInteractiveTransition scrubs through the animation provided by the animated transitioning object.\n\nFull flow for an interactive dismiss:\n1. User begins pan gesture → gesture handler calls dismiss(animated: true).\n2. UIKit asks transitioningDelegate for animationController(forDismissed:) → returns your animator.\n3. UIKit asks for interactionControllerForDismissal(using:) → returns your UIPercentDrivenInteractiveTransition (since the gesture is active).\n4. UIKit calls animateTransition on the animator, but instead of playing it, the interactive controller scrubs it.\n5. As the gesture progresses, update() drives the animation.\n6. On gesture end, finish() completes the animation forward, or cancel() reverses it.\n\nFor iOS 10+ interruptible transitions, return a UIViewPropertyAnimator from interruptibleAnimator(using:). This allows mid-animation pausing, reversing, and re-driving, enabling fluid transitions like the iOS home screen app switcher."
  },
  {
    "topic": "uikit",
    "level": 4,
    "question": "What happens internally when you call setNeedsLayout followed by layoutIfNeeded inside a UIView.animate block? Why does this pattern animate constraint changes?",
    "hint": "Think about Core Animation's implicit animation mechanism, CATransaction, and how the layout pass updates layer properties that get animated.",
    "answer": "This pattern works due to the interaction between Auto Layout, UIKit, and Core Animation's implicit animation mechanism.\n\nStep-by-step breakdown:\n\n1. Before the animate block, you modify constraints (change constants, activate/deactivate). At this point, nothing visible has changed — constraints are just mathematical relationships stored in the layout engine.\n\n2. You call setNeedsLayout() on the parent view to flag it for a layout pass. This is often implicit when constraints change.\n\n3. Inside the UIView.animate block:\n   UIView.animate(withDuration: 0.3) {\n       self.view.layoutIfNeeded()\n   }\n\n4. UIView.animate internally opens a CATransaction and sets its animation duration, timing function, and enables implicit animations. Any animatable CALayer property change made inside this block will be automatically animated.\n\n5. layoutIfNeeded() triggers an immediate layout pass. The Auto Layout engine solves the new constraint equations and computes new frames for all affected views.\n\n6. When the new frames are applied to the views, this updates the underlying CALayer's position, bounds, and potentially transform properties. Because these changes happen inside the CATransaction created by UIView.animate, Core Animation creates implicit CABasicAnimations for each changed property.\n\n7. The model layer values are updated immediately to the final state. The presentation layer (what the user sees) animates from the old values to the new values over the specified duration.\n\nWhy layoutIfNeeded() must be inside the animation block:\n- If you call layoutIfNeeded() outside the block, the layout changes happen without a CATransaction, so there are no implicit animations — the views jump to their new positions.\n- The animate block creates the transaction context that intercepts property changes and wraps them in animations.\n\nWhy setNeedsLayout() should be outside the block:\n- setNeedsLayout() just sets a dirty flag. Calling it inside the animate block would also work since layoutIfNeeded() checks and processes the flag regardless, but conceptually the flag-setting is a preparation step.\n\nThis pattern is preferred over animating constraint.constant directly because it lets the layout engine handle all cascading effects — if one constraint change affects multiple views, they all animate together in a single coordinated pass.\n\nWith UIViewPropertyAnimator, the same pattern applies but gives you interruptibility:\n   let animator = UIViewPropertyAnimator(duration: 0.3, curve: .easeInOut) {\n       self.view.layoutIfNeeded()\n   }\n   animator.startAnimation()"
  },
  {
    "topic": "uikit",
    "level": 4,
    "question": "How does UICollectionView's prefetching mechanism work, and how does it interact with diffable data sources and compositional layout for optimal scrolling performance?",
    "hint": "Think about UICollectionViewDataSourcePrefetching, the prefetch window, cancelPrefetching, and how to coordinate with image loading or data fetching pipelines.",
    "answer": "UICollectionView's prefetching system proactively loads data for cells that are approaching the visible area, preventing jank during fast scrolling.\n\nUICollectionViewDataSourcePrefetching protocol:\n- collectionView(_:prefetchItemsAt:) — Called with index paths of items that are likely to be displayed soon. The system predicts based on scroll velocity and direction. Use this to begin asynchronous data loading (images, network requests, database queries).\n- collectionView(_:cancelPrefetchingForItemsAt:) — Called when previously prefetched items are no longer needed (user changed scroll direction). Cancel in-flight requests to avoid wasted work.\n\nSetup:\n   collectionView.prefetchDataSource = self\n   collectionView.isPrefetchingEnabled = true // default is true\n\nInteraction with diffable data sources:\n- Diffable data sources work seamlessly with prefetching. The prefetch delegate receives index paths, and you use the snapshot to resolve the corresponding model objects:\n   func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {\n       let items = indexPaths.compactMap { dataSource.itemIdentifier(for: $0) }\n       items.forEach { imageLoader.startPrefetch(for: $0.imageURL) }\n   }\n- When applying a new snapshot, previously issued prefetch calls may reference stale index paths. The system calls cancelPrefetchingForItemsAt: for invalidated paths, so handle cancellation properly.\n\nInteraction with compositional layout:\n- Compositional layout's orthogonal scrolling sections create unique prefetching behavior. Items in horizontally scrolling sections are prefetched based on horizontal scroll position within that section.\n- Estimated-size items may trigger layout passes that affect prefetching timing, as the collection view discovers the actual sizes during scrolling.\n- For sections with orthogonalScrollingBehavior, prefetching considers both the vertical position of the section and the horizontal scroll offset within it.\n\nOptimal performance patterns:\n1. Use a dedicated prefetch/cache layer (like NSCache or a custom image pipeline) that both prefetch and cellForItemAt can share.\n2. In cancelPrefetchingForItemsAt, actually cancel operations — do not just ignore it. This is critical for memory and network efficiency during fast scrolling.\n3. Pair with cell lifecycle: in collectionView(_:willDisplay:forItemAt:) and collectionView(_:didEndDisplaying:forItemAt:), manage resource loading priority.\n4. For self-sizing cells with estimated dimensions, ensure your prefetch completes data loading so that when the cell is configured, the content is ready and layout does not need a second pass.\n5. UICollectionView also supports cell prefetching (separate from data prefetching) where it pre-creates and configures cells ahead of time. This is controlled internally and works automatically with cell registration."
  },
  {
    "topic": "uikit",
    "level": 5,
    "question": "Describe the complete hit-testing algorithm in UIKit. How does hitTest(_:with:) traverse the view hierarchy, and how do transforms, clipping, and custom overrides affect the process?",
    "hint": "Think about the reverse subview order traversal, the three disqualification checks, coordinate conversion, and how overriding hitTest/pointInside enables touch area expansion.",
    "answer": "The hit-testing algorithm determines which view should receive a touch event. It is implemented as a recursive traversal of the view hierarchy.\n\nThe algorithm (hitTest(_:with:) default implementation):\n\n1. Disqualification checks — A view is immediately excluded if any of these are true:\n   - view.isUserInteractionEnabled == false\n   - view.isHidden == true\n   - view.alpha < 0.01\n   If disqualified, hitTest returns nil.\n\n2. Point containment — The view calls point(inside:with:) to check if the touch point (converted to the view's local coordinate system) is within its bounds. If the point is outside, hitTest returns nil.\n\n3. Reverse subview traversal — If the point is inside, the view iterates through its subviews array in reverse order (last subview first, since later subviews are visually on top). For each subview:\n   a. The touch point is converted from the current view's coordinate system to the subview's coordinate system using convert(_:to:).\n   b. hitTest(_:with:) is called recursively on the subview.\n   c. If any subview returns a non-nil result, that result is immediately returned (the deepest frontmost view wins).\n\n4. Self — If no subview claims the touch, the view returns itself.\n\nHow transforms affect hit testing:\n- convert(_:to:) correctly handles affine transforms (rotation, scale, translation) applied to views. The point is transformed through the inverse of the view's transform to map it into the view's local coordinate space.\n- A rotated view's hit-testable area follows its actual visual shape, not its frame. This is because point(inside:with:) checks against bounds after coordinate conversion.\n- 3D transforms (CATransform3D on the layer) are also handled during coordinate conversion, so perspective transforms work correctly.\n\nClipping (clipsToBounds):\n- If clipsToBounds is false (the default), subviews can visually extend beyond their parent's bounds. However, hit testing on the parent still checks point(inside:with:) for the parent first. Since the point is outside the parent's bounds, hitTest returns nil, and the overflowing subview does NOT receive the touch even though it is visible.\n- Solution: Override hitTest or point(inside:with:) on the parent to expand its touchable area.\n\nCustom overrides:\n\n1. Expanding touch area (e.g., making a small button easier to tap):\n   override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {\n       return bounds.insetBy(dx: -20, dy: -20).contains(point)\n   }\n\n2. Touch passthrough (making a view ignore touches so they pass to views behind it):\n   override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {\n       let result = super.hitTest(point, with: event)\n       return result == self ? nil : result // Only pass through if self would be the receiver\n   }\n\n3. Handling overflow beyond parent bounds:\n   override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {\n       // Check subviews even if point is outside our bounds\n       for subview in subviews.reversed() {\n           let subviewPoint = subview.convert(point, from: self)\n           if let result = subview.hitTest(subviewPoint, with: event) {\n               return result\n           }\n       }\n       return super.hitTest(point, with: event)\n   }\n\nImportant edge cases:\n- Hit testing happens on the MAIN THREAD and can be called multiple times per touch for different phases.\n- The hitTest result is cached for the duration of a touch sequence — the same view receives all touch phases (began, moved, ended).\n- During hit testing, gesture recognizers are not yet involved. They receive touches after the hit-test view is determined.\n- UIEvent can be nil in some edge cases (accessibility, programmatic calls), so handle that gracefully."
  },
  {
    "topic": "uikit",
    "level": 5,
    "question": "How does Auto Layout's constraint solving engine work internally? Explain the Cassowary algorithm, constraint priorities, and what happens when the system encounters ambiguous or unsatisfiable layouts.",
    "hint": "Think about the simplex method, the objective function with priority-weighted error variables, how required vs optional constraints differ, and how the engine resolves conflicts.",
    "answer": "Auto Layout uses the Cassowary incremental constraint solving algorithm, which is based on the simplex method from linear programming.\n\nCore concepts:\n\n1. Constraints as linear equations/inequalities:\n   Every constraint is expressed as: a1*x1 + a2*x2 + ... = (or >=, <=) constant\n   For example, view.leading = superview.leading + 16 becomes: view.minX = superview.minX + 16\n   The variables are the view's layout attributes (minX, minY, width, height).\n\n2. The Cassowary algorithm:\n   - It maintains a tableau (matrix) of all constraints in the system.\n   - Uses the simplex method to find a solution that satisfies all required constraints and maximally satisfies optional constraints.\n   - It is 'incremental': when constraints are added or removed, the solver does not restart from scratch. It incrementally updates the tableau, making it efficient for dynamic layouts.\n   - Time complexity is typically linear for well-formed layouts, though worst case is exponential (rare in practice).\n\n3. Priority system (1-1000):\n   - Required constraints (priority 1000) MUST be satisfied. If they conflict, the layout is unsatisfiable.\n   - Optional constraints (priority < 1000) are treated as optimization goals. The solver introduces error variables for each optional constraint and minimizes a weighted sum: minimize(sum of priority_i * |error_i|).\n   - Higher priority optional constraints are satisfied before lower priority ones. The solver uses a lexicographic ordering: it first minimizes violation of the highest priority, then among solutions with equal violation of that priority, minimizes the next highest, and so on.\n   - This is why priority 999 behaves very differently from 1000 — 1000 is a hard constraint (no error variable), while 999 is soft (can be violated if necessary).\n\n4. Content hugging and compression resistance:\n   These are implemented as optional constraints:\n   - Compression resistance: width >= intrinsicWidth @ priority (default 750)\n   - Content hugging: width <= intrinsicWidth @ priority (default 250)\n   The priorities determine which views stretch or compress when space is insufficient or excessive.\n\n5. Unsatisfiable layouts:\n   When required constraints conflict, the engine cannot find a valid solution. UIKit:\n   - Logs a detailed warning: 'Unable to simultaneously satisfy constraints' with a list of all conflicting constraints.\n   - Breaks one constraint (removes it temporarily) to reach a satisfiable state. The choice of which constraint to break is deterministic but not well-documented — it is essentially arbitrary from the developer's perspective.\n   - The layout is still rendered, but it may not match your intent.\n   - To fix: review the logged constraints, identify the conflict, and lower one constraint's priority or remove it.\n\n6. Ambiguous layouts:\n   When the constraint system has multiple valid solutions (underconstrained), the engine picks one, but the result is unpredictable.\n   - Debug with: view.hasAmbiguousLayout, view.exerciseAmbiguityInLayout() (cycles through valid solutions), and UIViewAlertForUnsatisfiableConstraints symbolic breakpoint.\n   - Common cause: missing width, height, or positional constraint so the view's frame is not fully determined.\n\n7. Performance considerations:\n   - The engine maintains a persistent solver that incrementally updates. Adding/removing individual constraints is efficient.\n   - However, calling setNeedsUpdateConstraints or invalidating intrinsic content size on many views simultaneously can cause the engine to re-solve large portions of the tableau.\n   - Deeply nested view hierarchies with cross-hierarchy constraints are more expensive because they increase the number of variables and constraints in the solver.\n   - Constraint churn (repeatedly creating and destroying constraints) defeats the incremental advantage. Prefer activating/deactivating constraints or modifying constants.\n   - For complex collection view cells, consider caching computed heights or using manual layout in performance-critical paths.\n\n8. The layout pass:\n   - updateConstraints() propagates from leaf views to the root (bottom-up), allowing views to modify their constraints.\n   - The solver runs and produces new values for all layout variables.\n   - layoutSubviews() propagates from root to leaves (top-down), applying the computed frames.\n   - This two-pass approach ensures that constraint modifications are collected before solving, and frame assignments happen in parent-to-child order."
  },
  {
    "topic": "lifecycle",
    "level": 1,
    "question": "What are the main states of a UIApplication lifecycle, and what does each state represent?",
    "hint": "Think about what happens from the moment a user taps the app icon to when they switch away.",
    "answer": "UIApplication has five main states:\n\n1. Not Running — The app has not been launched or was terminated by the system.\n2. Inactive — The app is in the foreground but not receiving events (e.g., during a transition or when an alert is displayed).\n3. Active — The app is in the foreground and receiving user events. This is the normal interactive state.\n4. Background — The app is executing code but is not visible on screen. Apps enter this state briefly before being suspended, or can request extended background execution.\n5. Suspended — The app is in memory but not executing code. The system may purge suspended apps without notice to reclaim memory.\n\nTransitions between these states trigger delegate callbacks such as applicationDidBecomeActive(_:), applicationWillResignActive(_:), applicationDidEnterBackground(_:), and applicationWillEnterForeground(_:)."
  },
  {
    "topic": "lifecycle",
    "level": 1,
    "question": "What is the correct order of UIViewController lifecycle methods from creation to appearing on screen?",
    "hint": "Consider what happens after the view controller is instantiated but before the user sees it.",
    "answer": "The UIViewController lifecycle methods fire in this order:\n\n1. init(coder:) or init(nibName:bundle:) — The view controller is instantiated.\n2. loadView() — The system calls this to create the view hierarchy. Override only if building views entirely in code.\n3. viewDidLoad() — Called once after the view is loaded into memory. Use this for one-time setup like adding subviews or configuring data.\n4. viewWillAppear(_:) — Called every time the view is about to be added to the window hierarchy. Good for refreshing data or updating UI state.\n5. viewIsAppearing(_:) — (iOS 13+ but back-deployed, prominent from iOS 17) Called after viewWillAppear and after the view has been added to the hierarchy with updated trait collections and geometry. Ideal for layout-dependent setup.\n6. viewDidAppear(_:) — Called after the view is fully visible and any transition animations have completed. Use for starting animations or analytics tracking.\n\nOn disappearing, the inverse order is: viewWillDisappear(_:) then viewDidDisappear(_:)."
  },
  {
    "topic": "lifecycle",
    "level": 1,
    "question": "What is the difference between AppDelegate and SceneDelegate, and why was SceneDelegate introduced?",
    "hint": "Think about iPad multitasking and multiple windows of the same app.",
    "answer": "AppDelegate was originally responsible for both application-level events (launch, termination, push notifications) and UI lifecycle events (foreground/background transitions). SceneDelegate was introduced in iOS 13 to support multi-window functionality, especially on iPad.\n\nWith SceneDelegate, responsibilities are split:\n\n- AppDelegate handles process-level events: application(_:didFinishLaunchingWithOptions:), registering for push notifications, handling background URL sessions, and configuring new scene sessions via application(_:configurationForConnecting:options:).\n\n- SceneDelegate handles per-window UI lifecycle: scene(_:willConnectTo:options:), sceneDidBecomeActive(_:), sceneWillResignActive(_:), sceneDidEnterBackground(_:), sceneWillEnterForeground(_:), and sceneDidDisconnect(_:).\n\nThis separation means each window (UIScene) has its own lifecycle, so one window can be in the foreground while another is backgrounded. On iPhone, there is typically a single scene, but the architecture still applies."
  },
  {
    "topic": "lifecycle",
    "level": 2,
    "question": "Describe the complete app launch sequence from the moment a user taps the app icon until the first screen is visible.",
    "hint": "Consider what happens at the process level before any of your Swift code runs.",
    "answer": "The app launch sequence involves several stages:\n\n1. Kernel & dyld — The system creates the process, and dyld (the dynamic linker) loads the app binary and all dependent frameworks/dylibs. It performs symbol binding and runs initializers (+load methods, C++ static constructors, __attribute__((constructor)) functions).\n\n2. UIKit initialization — The main() function is called, which calls UIApplicationMain(). This creates the UIApplication singleton and the AppDelegate.\n\n3. application(_:willFinishLaunchingWithOptions:) — Called before state restoration. Return true to continue launching.\n\n4. State restoration — If supported, the system restores UI state from a previous session.\n\n5. application(_:didFinishLaunchingWithOptions:) — Primary setup callback. Configure services, parse launch options, set up the root view controller if not using scenes.\n\n6. Scene connection (iOS 13+) — application(_:configurationForConnecting:options:) is called to create a scene configuration, then scene(_:willConnectTo:options:) on SceneDelegate sets up the UIWindow and root view controller.\n\n7. sceneWillEnterForeground(_:) then sceneDidBecomeActive(_:) — The scene transitions to the foreground.\n\n8. First frame — The initial layout pass runs (viewDidLoad, viewWillAppear, viewIsAppearing, viewDidAppear), Core Animation commits the layer tree, and the first frame renders on screen.\n\nOptimizing pre-main time (reducing dylib count, avoiding +load) and didFinishLaunching work (deferring non-essential setup) are key to fast launches."
  },
  {
    "topic": "lifecycle",
    "level": 2,
    "question": "What is viewIsAppearing(_:) introduced in iOS 17, and how does it differ from viewWillAppear(_:)?",
    "hint": "Think about when trait collections and geometry (like safe area insets) become accurate.",
    "answer": "viewIsAppearing(_:) is a UIViewController lifecycle callback that was formally introduced as API in iOS 17 but is back-deployed to iOS 13+. It is called between viewWillAppear(_:) and viewDidAppear(_:).\n\nKey differences from viewWillAppear:\n\n1. Accurate geometry — When viewIsAppearing is called, the view has already been added to the view hierarchy, so its bounds, safe area insets, and layout margins are accurate. In viewWillAppear, the view may not yet be in the hierarchy, so geometry values can be stale or incorrect.\n\n2. Updated trait collection — The view's traitCollection reflects the actual display environment (size class, user interface style, etc.) in viewIsAppearing. In viewWillAppear, traits may not yet be updated for the target window.\n\n3. Transition context — viewIsAppearing is called during the transition animation, making it the ideal place to configure views based on their final size, update scroll positions, or adjust layout for the current traits.\n\n4. Called alongside viewWillAppear — It fires every time the view appears (not just once), just like viewWillAppear.\n\nApple recommends migrating most viewWillAppear logic to viewIsAppearing when you need reliable geometry or traits. viewWillAppear remains useful for work that should happen before the view is in the hierarchy, like starting to fetch data."
  },
  {
    "topic": "lifecycle",
    "level": 2,
    "question": "How does state restoration work in iOS, and what are the modern approaches compared to the legacy NSCoding-based system?",
    "hint": "Consider the difference between NSUserActivity-based restoration and the older restorationIdentifier approach.",
    "answer": "State restoration allows apps to recreate their UI state after being terminated by the system, so users return to exactly where they left off.\n\nLegacy approach (NSCoding-based):\n- Assign restorationIdentifier to each view controller and key views.\n- Implement encodeRestorableState(with:) and decodeRestorableState(with:) on view controllers.\n- Register view controller restoration classes via viewControllerWithRestorationIdentifierPath(_:coder:).\n- UIKit automatically saves and restores the view controller hierarchy.\n- This approach is complex and tightly coupled to the view controller hierarchy.\n\nModern approach (NSUserActivity-based, iOS 13+):\n- In SceneDelegate, save state by returning an NSUserActivity from stateRestorationActivity(for:).\n- Restore state in scene(_:willConnectTo:options:) by reading the session's stateRestorationActivity.\n- Encode key navigation state (selected tab, displayed item ID, scroll position) into the userActivity's userInfo dictionary.\n- This approach is simpler, decoupled from the view hierarchy, and works naturally with Handoff and Spotlight.\n\nSwiftUI approach:\n- Use @SceneStorage property wrapper to automatically persist and restore small pieces of state per scene.\n- For example, @SceneStorage(\"selectedTab\") var selectedTab = 0 persists the selected tab across launches.\n- Combine with NavigationPath serialization for complex navigation stacks.\n\nBest practice: Use NSUserActivity for UIKit apps and @SceneStorage for SwiftUI apps. Keep restored state minimal — IDs and navigation paths rather than full data models."
  },
  {
    "topic": "lifecycle",
    "level": 3,
    "question": "Explain background execution modes in iOS. What are the different ways an app can execute code in the background, and what are the constraints?",
    "hint": "Think about both continuous background modes and discrete background tasks.",
    "answer": "iOS provides several mechanisms for background execution, each with specific constraints:\n\n1. Background Task Completion (beginBackgroundTask) — Any app can request a short window (roughly 30 seconds, reduced from the historical ~3 minutes) to complete work when entering the background. Call UIApplication.shared.beginBackgroundTask(expirationHandler:) and must call endBackgroundTask(_:) when done. The expiration handler is your last chance to clean up before the process is suspended.\n\n2. Background Modes (Info.plist UIBackgroundModes):\n   - audio — Continuous audio playback/recording (music, podcasts, VoIP).\n   - location — Continuous GPS updates (navigation apps). Also significant-change and region monitoring for less precise but lower-power tracking.\n   - voip — Maintain VoIP connections via PushKit.\n   - fetch — Legacy background fetch (deprecated in iOS 13 in favor of BGTaskScheduler).\n   - remote-notification — Wake on silent push notifications to refresh content.\n   - bluetooth-central / bluetooth-peripheral — BLE communication in background.\n   - processing — Long-running maintenance tasks via BGProcessingTaskRequest (iOS 13+).\n\n3. BGTaskScheduler (iOS 13+):\n   - BGAppRefreshTaskRequest — Short tasks (~30 seconds) for periodic content refresh. System decides when to run based on usage patterns.\n   - BGProcessingTaskRequest — Longer tasks (minutes) for maintenance like database cleanup or ML model training. Can require external power and network connectivity. Typically runs overnight.\n   - Register tasks in didFinishLaunching, submit requests when entering background.\n\n4. URLSession background transfers — Downloads/uploads continue even after app suspension or termination. The system manages the transfer and wakes the app via application(_:handleEventsForBackgroundURLSession:completionHandler:).\n\n5. Silent push notifications — The system wakes the app to process content-available pushes, giving roughly 30 seconds of execution time.\n\nConstraints: The system aggressively manages background execution based on battery, thermal state, and user behavior. Apps that abuse background modes face throttling or termination. Always test with the device unplugged and consider the user's battery expectations."
  },
  {
    "topic": "lifecycle",
    "level": 3,
    "question": "How does BGTaskScheduler work, and what is the correct way to register, schedule, and handle background tasks?",
    "hint": "Consider both the registration step at launch time and the scheduling step when entering background.",
    "answer": "BGTaskScheduler (iOS 13+) provides a modern API for scheduling background work. Here is the complete workflow:\n\n1. Registration in Info.plist — Add task identifiers to the BGTaskSchedulerPermittedIdentifiers array (under Permitted background task scheduler identifiers). Each identifier is a reverse-DNS string like com.myapp.refresh.\n\n2. Register handlers at launch — In application(_:didFinishLaunchingWithOptions:) or the App init, call:\n   BGTaskScheduler.shared.register(forTaskWithIdentifier: \"com.myapp.refresh\", using: nil) { task in\n       self.handleAppRefresh(task: task as! BGAppRefreshTask)\n   }\n   The using: nil parameter means the handler runs on a serial background queue. You can pass a specific DispatchQueue if needed. Registration must happen before the app finishes launching.\n\n3. Schedule tasks — Typically done in sceneDidEnterBackground or applicationDidEnterBackground:\n   let request = BGAppRefreshTaskRequest(identifier: \"com.myapp.refresh\")\n   request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60) // No earlier than 15 min\n   try? BGTaskScheduler.shared.submit(request)\n   For processing tasks, use BGProcessingTaskRequest and optionally set requiresNetworkConnectivity and requiresExternalPower.\n\n4. Handle the task — In the handler closure:\n   - Set an expirationHandler on the task that cancels your work and calls task.setTaskCompleted(success: false).\n   - Perform the work (fetch data, process database, etc.).\n   - Call task.setTaskCompleted(success: true) when done.\n   - Re-schedule the next occurrence of the task from within the handler.\n\n5. Testing — Use the debugger command: e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"com.myapp.refresh\"] to trigger tasks during development.\n\nKey considerations:\n- The system decides the actual execution time based on usage patterns, battery, and connectivity. earliestBeginDate is a minimum, not a guarantee.\n- Only one pending request per identifier is allowed; submitting a new one replaces the old.\n- Processing tasks can run for several minutes but are typically scheduled during overnight charging.\n- Always handle the expiration case gracefully to avoid being penalized by the system scheduler."
  },
  {
    "topic": "lifecycle",
    "level": 3,
    "question": "Walk through the complete lifecycle of a push notification from server to UI, including how the app responds differently depending on its state.",
    "hint": "Consider the three app states (not running, background, foreground) and both visible and silent notifications.",
    "answer": "The push notification lifecycle involves multiple stages and varies by app state:\n\n1. Registration:\n   - App calls UIApplication.shared.registerForRemoteNotifications().\n   - System contacts APNs and returns a device token via application(_:didRegisterForRemoteNotificationsWithDeviceToken:).\n   - App sends this token to its backend server.\n   - User must also grant permission via UNUserNotificationCenter.requestAuthorization(options:).\n\n2. Server sends notification:\n   - Backend sends the payload to APNs with the device token.\n   - APNs delivers it to the device.\n\n3. Notification Service Extension (optional):\n   - If present, didReceive(_:withContentHandler:) is called before display.\n   - Can modify the notification content (decrypt end-to-end encrypted payload, download attachment images, modify title/body).\n   - Has ~30 seconds; if it times out, serviceExtensionTimeWillExpire() is called and the original notification is shown.\n\n4. Delivery behavior depends on app state:\n\n   App in foreground:\n   - UNUserNotificationCenterDelegate's userNotificationCenter(_:willPresent:withCompletionHandler:) is called.\n   - You decide whether to show a banner, play sound, or update badge by passing options to the completion handler.\n   - No system banner is shown by default; you must opt in.\n\n   App in background or not running (visible notification):\n   - System displays the notification banner/alert, plays sound, updates badge.\n   - When user taps the notification, userNotificationCenter(_:didReceive:withCompletionHandler:) is called.\n   - If app was not running, it launches and this callback fires after didFinishLaunching.\n   - The response object contains the notification content and any action identifier.\n\n   Silent notification (content-available: 1):\n   - application(_:didReceiveRemoteNotification:fetchCompletionHandler:) is called.\n   - App gets ~30 seconds to fetch data and call the completion handler with .newData, .noData, or .failed.\n   - System may throttle silent notifications; not guaranteed to wake the app.\n\n5. Notification actions:\n   - Custom actions defined via UNNotificationCategory and UNNotificationAction.\n   - User interacts via the expanded notification interface.\n   - didReceive response includes the actionIdentifier to determine which action was tapped.\n\n6. Notification Content Extension (optional):\n   - Custom UI displayed when user long-presses or expands the notification.\n   - Defined in a separate extension target conforming to UNNotificationContentExtension.\n\nKey gotchas: The delegate must be set before application(_:didFinishLaunchingWithOptions:) returns to handle notifications that launched the app. Device tokens can change, so always send the latest token to your server."
  },
  {
    "topic": "lifecycle",
    "level": 4,
    "question": "Explain the UIScene lifecycle in a multi-window iPad app. How do scene sessions work, and what happens when scenes are created, disconnected, and destroyed?",
    "hint": "Distinguish between a scene session persisting even after a scene is disconnected.",
    "answer": "The UIScene system enables multiple windows of the same app, each with independent lifecycles:\n\nScene Sessions:\n- A UISceneSession represents a persistent record of a scene, even when that scene is not connected (not actively in memory).\n- Sessions survive scene disconnection and app termination. They persist until the user explicitly removes the window from the app switcher or the app calls UIApplication.requestSceneSessionDestruction(_:options:errorHandler:).\n- Each session has a persistentIdentifier, a stateRestorationActivity, and userInfo for storing state.\n\nScene Creation:\n1. User requests a new window (drag to split view, Exposé, or app calls requestSceneSessionActivation).\n2. application(_:configurationForConnecting:options:) is called on AppDelegate. Return a UISceneConfiguration specifying the SceneDelegate class, storyboard, and role.\n3. scene(_:willConnectTo:options:) is called on the SceneDelegate. Set up UIWindow, root view controller, and restore state from session.stateRestorationActivity.\n4. sceneWillEnterForeground(_:) and sceneDidBecomeActive(_:) are called as the scene becomes visible.\n\nScene Lifecycle Transitions:\n- Active <-> Inactive — sceneWillResignActive / sceneDidBecomeActive. Triggered by interruptions (calls, alerts, app switcher).\n- Foreground <-> Background — sceneDidEnterBackground / sceneWillEnterForeground. Each scene transitions independently.\n- A backgrounded scene may continue briefly (beginBackgroundTask still works at the application level).\n\nScene Disconnection:\n- When the system reclaims resources, it calls sceneDidDisconnect(_:). The scene object is deallocated.\n- The session persists. You must release any resources tied to that scene (observers, caches) in sceneDidDisconnect.\n- If you stored state in session.stateRestorationActivity or session.userInfo, it survives disconnection.\n- The scene will be reconnected (scene(_:willConnectTo:options:) called again) when the user returns to that window.\n\nScene Destruction:\n- User swipes away a window in the app switcher.\n- application(_:didDiscardSceneSessions:) is called (potentially at next app launch if the app was not running).\n- Permanently delete any data associated with those sessions (e.g., draft documents, temp files).\n- The session is removed and will not reconnect.\n\nPractical implications:\n- Each scene has its own foreground/background state, so a music app might have one scene active and another backgrounded.\n- Shared state (models, network managers) lives at the application level; per-scene state (UI, navigation) lives with each SceneDelegate.\n- Use NSUserActivity on the session for state restoration across disconnections.\n- Test thoroughly on iPad with multiple windows to catch issues with shared mutable state."
  },
  {
    "topic": "lifecycle",
    "level": 4,
    "question": "How do deep links and universal links integrate with the app lifecycle? Describe the complete flow for handling a universal link when the app is not running.",
    "hint": "Consider the apple-app-site-association file, the entitlements, and which delegate method receives the URL.",
    "answer": "Universal links provide a seamless way to open app content from HTTPS URLs. The complete flow when the app is not running:\n\nSetup (prerequisite):\n1. Apple App Site Association (AASA) file — Host a JSON file at https://yourdomain.com/.well-known/apple-app-site-association. It maps URL paths to your app's bundle ID: {\"applinks\":{\"apps\":[],\"details\":[{\"appIDs\":[\"TEAMID.com.myapp\"],\"paths\":[\"/product/*\",\"/article/*\"]}]}}.\n2. Associated Domains entitlement — Add applinks:yourdomain.com to the app's Associated Domains capability.\n3. Apple's CDN fetches and caches the AASA file when the app is installed or updated.\n\nHandling flow (app not running):\n1. User taps a universal link (e.g., https://yourdomain.com/product/123) in Safari, Messages, Mail, etc.\n2. iOS checks its cached AASA data. If the URL matches a registered path pattern, iOS launches the app instead of opening Safari.\n3. The app process starts. The launch sequence proceeds: main() -> UIApplicationMain -> application(_:didFinishLaunchingWithOptions:). The launchOptions dictionary contains UIApplication.LaunchOptionsKey.userActivity but this is not the primary handling mechanism.\n\n4. Scene-based apps (iOS 13+):\n   - If no existing scene session matches, application(_:configurationForConnecting:options:) is called. The connectionOptions contain the NSUserActivity.\n   - scene(_:willConnectTo:options:) fires. Extract the URL from connectionOptions.userActivities. The activity has activityType == NSUserActivityTypeBrowsingWeb and webpageURL == the tapped URL.\n   - If a scene is already connected but backgrounded, scene(_:continue:) is called instead.\n\n5. Pre-scene apps:\n   - application(_:continue:restorationHandler:) is called with the NSUserActivity.\n\n6. Parse the URL path and query parameters to determine the content to display. Navigate to the appropriate view controller.\n\nDeep links (custom URL schemes):\n- Registered via CFBundleURLSchemes in Info.plist.\n- Handled in scene(_:openURLContexts:) for scene-based apps or application(_:open:options:) for pre-scene apps.\n- Less secure than universal links (any app can claim a scheme) and show a confirmation dialog.\n\nKey considerations:\n- Universal links only work from other apps/web, not from your own app's WKWebView.\n- The AASA file must be served over HTTPS with correct content-type (application/json).\n- Use UIApplicationOpenURLOptionsKey values to determine the source app.\n- Always implement fallback handling — if parsing fails, navigate to a sensible default screen.\n- Test with the swcd (Shared Web Credentials daemon) and the Apple AASA validator: https://search.developer.apple.com/appsearch-validation-tool/."
  },
  {
    "topic": "lifecycle",
    "level": 4,
    "question": "Describe how WidgetKit timeline lifecycle works. What is the relationship between TimelineProvider, TimelineEntry, and getTimeline?",
    "hint": "Think about how the system requests a batch of entries and a reload policy, not individual updates.",
    "answer": "WidgetKit uses a timeline-based architecture where the widget provides a series of dated entries upfront, and the system renders them at the appropriate times:\n\nCore components:\n\n1. TimelineEntry — A protocol requiring a date property. Each entry represents the widget's state at a specific point in time. You add custom properties for the data to display (e.g., struct MyEntry: TimelineEntry { let date: Date; let headline: String }).\n\n2. TimelineProvider (or IntentTimelineProvider for configurable widgets) — Provides three functions:\n   - placeholder(in:) — Returns a single entry used for the widget's placeholder appearance (redacted/skeleton UI) when no data is available yet. Called synchronously.\n   - getSnapshot(in:completion:) — Returns a single representative entry for the widget gallery and transient displays. Should return quickly, using sample data if the context.isPreview is true.\n   - getTimeline(in:completion:) — The core method. Returns a Timeline<Entry> containing an array of entries and a TimelineReloadPolicy.\n\n3. Timeline and ReloadPolicy:\n   - The Timeline struct wraps [Entry] and a policy.\n   - .atEnd — The system requests a new timeline after the last entry's date has passed.\n   - .after(Date) — The system requests a new timeline after the specified date.\n   - .never — The system does not automatically request a new timeline. The app must trigger a reload by calling WidgetCenter.shared.reloadTimelines(ofKind:) or WidgetCenter.shared.reloadAllTimelines().\n\nLifecycle flow:\n1. System calls getTimeline when the widget is first added, when the reload policy triggers, or when the app explicitly requests a reload.\n2. The provider fetches data (network, database, shared UserDefaults via App Groups) and constructs entries for future time slots.\n3. The system caches these entries and renders the appropriate one based on the current date.\n4. When no more entries are available or the reload policy triggers, the system calls getTimeline again.\n\nReload triggers:\n- Automatic based on reload policy.\n- WidgetCenter.shared.reloadTimelines(ofKind:) from the main app or extensions.\n- Significant time/location changes.\n- The system budgets reloads (typically 40-70 per day) to conserve battery. High-relevance widgets may receive more.\n\nImportant constraints:\n- Widgets cannot run arbitrary code at render time; the timeline is the only mechanism.\n- Network requests in getTimeline should be fast; use URLSession with reasonable timeouts.\n- Shared data between app and widget uses App Groups (UserDefaults or file container).\n- For widgets that respond to user interaction (iOS 17+ interactive widgets), button/toggle actions trigger an AppIntent that can update shared state and then call reloadTimelines.\n- Keep entries lightweight to minimize memory footprint."
  },
  {
    "topic": "lifecycle",
    "level": 5,
    "question": "How would you diagnose and optimize app launch time? Describe the tools, metrics, and architectural strategies for reducing both pre-main and post-main time.",
    "hint": "Consider dyld, static initializers, DYLD_PRINT_STATISTICS, Instruments, and lazy initialization patterns.",
    "answer": "App launch optimization requires understanding and measuring both pre-main and post-main phases:\n\nPre-main optimization:\n\nDiagnostics:\n- Set DYLD_PRINT_STATISTICS or DYLD_PRINT_STATISTICS_DETAILS environment variable in the scheme to see dyld timing breakdown.\n- Use Instruments App Launch template to profile the entire launch.\n- MetricKit MXAppLaunchMetric provides field data from real users.\n- Xcode Organizer shows launch time percentiles.\n\nOptimization strategies:\n- Reduce dynamic library count — Each dylib adds load time. Merge small frameworks, use static linking where possible. Apple recommends fewer than 6 non-system dylibs.\n- Eliminate +load methods — Move initialization to +initialize (lazy) or explicit initialization calls.\n- Remove C++ static initializers — Use lazy initialization or dispatch_once patterns.\n- Reduce Objective-C class/category/selector count — Each requires registration work by the runtime. Use Swift structs/enums where appropriate.\n- Enable dyld3 closure caching (automatic on iOS 13+) — Pre-computes launch closures on install.\n\nPost-main optimization:\n\nDiagnostics:\n- Instruments Time Profiler and App Launch templates.\n- os_signpost to measure custom intervals.\n- XCTest measureMetrics for automated launch time testing.\n- MetricKit for production data.\n\nOptimization strategies:\n- Defer non-essential work — Only perform work critical to displaying the first frame in didFinishLaunching. Use lazy initialization, background queues, or post-first-frame dispatch for analytics SDKs, prefetching, and non-visible setup.\n- Reduce main thread work — Move JSON parsing, database migrations, and heavy computation off the main thread.\n- Minimize storyboard complexity — Complex storyboards with many view controllers instantiate everything at once. Use code-based UI or smaller storyboards.\n- Optimize view controller hierarchy — Reduce the depth and complexity of the initial view hierarchy. Flatten deeply nested views.\n- Use launch storyboard effectively — The static launch screen buys perceived time while the app initializes.\n- Implement phased loading — Show a lightweight skeleton UI immediately, then populate with data asynchronously.\n\nArchitectural strategies:\n- Dependency injection with lazy resolution — Register services at launch but only instantiate when first accessed.\n- Module initialization registry — Instead of scattered didFinishLaunching code, use a protocol-based system where modules register lightweight initializers that can be prioritized and parallelized.\n- Feature flags for launch — Disable expensive features during launch, enable after first frame.\n- Binary size optimization — Smaller binaries load faster. Remove dead code with -dead_strip, use Asset Catalogs for images, audit dependencies.\n\nTarget metrics: Apple considers a good launch to be under 400ms for warm launches. The App Launch template in Instruments shows the time to first fully rendered frame."
  },
  {
    "topic": "lifecycle",
    "level": 5,
    "question": "Explain how the system manages app lifecycle during memory pressure scenarios. What happens to suspended apps, and how should an app prepare for sudden termination?",
    "hint": "Think about jetsam, the difference between suspension and termination, and what state you should persist and when.",
    "answer": "iOS aggressively manages memory through a system called Jetsam (also known as memorystatus), which terminates processes to keep the system responsive:\n\nMemory pressure levels:\n1. Normal — Sufficient memory available.\n2. Warning — System is approaching memory limits. UIApplication.didReceiveMemoryWarningNotification is sent to foreground apps.\n3. Critical — System begins terminating suspended apps. If still insufficient, background apps and eventually the foreground app may be terminated.\n\nJetsam mechanics:\n- Each process has a Jetsam priority band. Foreground apps have the highest priority; suspended apps have the lowest.\n- Within a priority band, the system typically terminates the largest memory consumer first.\n- Jetsam kills are immediate and non-negotiable — no delegate callbacks, no signal handlers. The process receives SIGKILL.\n- This differs from a graceful termination where applicationWillTerminate(_:) is called.\n\nApp states during memory pressure:\n- Suspended apps are terminated first without any notification. The app's state is simply gone.\n- Background apps receive didReceiveMemoryWarning and have a brief opportunity to reduce memory.\n- Foreground apps receive didReceiveMemoryWarning (and the UIViewController's didReceiveMemoryWarning method). Release caches, image buffers, and any reconstructable data.\n\nPreparing for sudden termination:\n\n1. Save state at transition points, not just at termination:\n   - Save critical state in sceneDidEnterBackground/applicationDidEnterBackground. Do not rely on applicationWillTerminate, as it may not be called.\n   - Use beginBackgroundTask to ensure save operations complete.\n   - For documents, enable autosave at regular intervals.\n\n2. Use appropriate persistence:\n   - Core Data with NSPersistentContainer handles most crash-safe persistence.\n   - UserDefaults.synchronize() is no longer needed (system auto-syncs) but writes should be in sceneDidEnterBackground.\n   - For critical data, use atomic file writes (write to temp, rename) to prevent corruption.\n\n3. Design for reconstructability:\n   - Keep a clear separation between cached data (reconstructable from network/disk) and user-generated data (must be persisted immediately).\n   - Cache images and computed data lazily; release in didReceiveMemoryWarning and reconstruct on demand.\n\n4. Monitor memory usage:\n   - Use os_proc_available_memory() to check available memory.\n   - Use Instruments Allocations and VM Tracker to profile memory footprint.\n   - Track dirty memory (your actual footprint) vs. clean memory (memory-mapped files the system can purge).\n   - Use MetricKit MXMemoryMetric for production data on peak memory and suspension counts.\n\n5. Reduce memory footprint:\n   - Use autoreleasepool blocks in loops processing large datasets.\n   - Downsample images to display size using ImageIO rather than loading full-resolution UIImages.\n   - Use NSCache instead of Dictionary for caches — NSCache auto-evicts under memory pressure.\n   - Profile with Xcode Memory Debugger to find leaks and abandoned memory.\n\nKey insight: Design your app assuming it can be killed at any moment without warning. Every piece of important state should either be persisted continuously or be reconstructable from persisted identifiers."
  },
  {
    "topic": "accessibility",
    "level": 1,
    "question": "What are accessibilityLabel, accessibilityHint, and accessibilityValue, and when should you use each one?",
    "hint": "Think about what VoiceOver reads first, what provides additional context, and what communicates a current state.",
    "answer": "These three properties form the core of VoiceOver's description of a UI element:\n\naccessibilityLabel — A short, descriptive label that identifies the element. VoiceOver reads this first when the user focuses on the element. It should describe what the element is, not what it does. Examples: \"Play\" for a play button, \"Profile photo\" for an image, \"Search\" for a search field. Do not include the element type (\"button\", \"field\") as VoiceOver adds that automatically from the accessibility traits.\n\naccessibilityHint — An optional phrase that describes what happens when the user activates the element. VoiceOver reads this after a brief pause following the label. It should start with a verb and describe the result of the action. Examples: \"Plays the current track\", \"Opens your profile settings\". Hints can be turned off by users in Settings, so never put critical information in hints. Use them to disambiguate when the label alone is not sufficient.\n\naccessibilityValue — Represents the current value of an element that has a changeable state. Used for sliders, progress bars, text fields, switches, and similar controls. Examples: \"50%\" for a volume slider, \"On\" for a toggle switch, \"3 of 10\" for a page indicator. VoiceOver reads it after the label: \"Volume, 50%, adjustable\".\n\nIn SwiftUI, these map to modifiers:\n.accessibilityLabel(\"Play\")\n.accessibilityHint(\"Plays the current track\")\n.accessibilityValue(\"50%\")\n\nBest practices:\n- Always set accessibilityLabel for custom controls and images that convey meaning.\n- Mark decorative images with .accessibilityHidden(true) or set their image accessibility to none.\n- Keep labels concise — one to three words is ideal.\n- Update accessibilityValue dynamically as the element's state changes."
  },
  {
    "topic": "accessibility",
    "level": 1,
    "question": "What is Dynamic Type, and how do you support it in both UIKit and SwiftUI?",
    "hint": "Think about preferred font styles, UIFontMetrics, and the @ScaledMetric property wrapper.",
    "answer": "Dynamic Type is iOS's system for allowing users to choose their preferred text size from Settings > Accessibility > Display & Text Size. Supporting it means your app's text scales appropriately for all users, including those with low vision.\n\nUIKit support:\n\n1. Preferred fonts — Use UIFont.preferredFont(forTextStyle:) with styles like .body, .headline, .caption1, etc. These fonts automatically scale with the user's preference.\n   let label = UILabel()\n   label.font = UIFont.preferredFont(forTextStyle: .body)\n   label.adjustsFontForContentSizeCategory = true\n\n2. UIFontMetrics — For custom fonts that should scale with Dynamic Type:\n   let customFont = UIFont(name: \"MyCustomFont\", size: 17)!\n   label.font = UIFontMetrics(forTextStyle: .body).scaledFont(for: customFont)\n   label.adjustsFontForContentSizeCategory = true\n\n3. adjustsFontForContentSizeCategory — Set to true on UILabel, UITextField, and UITextView so they automatically update when the user changes their text size preference without needing to reload.\n\nSwiftUI support:\n\n1. System fonts — SwiftUI's .font(.body), .font(.headline), etc. support Dynamic Type automatically with no extra work.\n\n2. Custom fonts — Use .font(.custom(\"MyFont\", size: 17, relativeTo: .body)) to make custom fonts scale relative to a text style.\n\n3. @ScaledMetric — A property wrapper that scales numeric values (spacing, padding, icon sizes) proportionally with Dynamic Type:\n   @ScaledMetric(relativeTo: .body) private var iconSize: CGFloat = 24\n   Image(systemName: \"star\").frame(width: iconSize, height: iconSize)\n\nBest practices:\n- Test with the largest accessibility sizes (AX1 through AX5) — layouts often break at these sizes.\n- Use flexible layouts (stack views, scroll views) that can accommodate varying text sizes.\n- Never hard-code fixed heights for text-containing views.\n- Support the five accessibility text sizes in addition to the seven standard sizes.\n- Use Accessibility Inspector or the Dynamic Type environment override in Xcode to test quickly."
  },
  {
    "topic": "accessibility",
    "level": 1,
    "question": "What is accessibilityIdentifier and how does it differ from accessibilityLabel? When would you use each?",
    "hint": "Think about who the audience is for each property — end users or automated tests.",
    "answer": "accessibilityIdentifier and accessibilityLabel serve completely different purposes despite both being string properties on accessibility elements:\n\naccessibilityIdentifier:\n- Purpose: A programmatic identifier used exclusively for UI testing and automation.\n- Audience: Developers and test frameworks (XCUITest, Appium, etc.).\n- Not read by VoiceOver — users never hear or see this value.\n- Should be stable, unique, and descriptive for test code: \"login_button\", \"email_text_field\", \"profile_avatar\".\n- Can use technical naming conventions since end users never encounter it.\n- In XCUITest: app.buttons[\"login_button\"].tap()\n- In SwiftUI: .accessibilityIdentifier(\"login_button\")\n\naccessibilityLabel:\n- Purpose: A human-readable description of the element for assistive technologies.\n- Audience: End users who rely on VoiceOver, Switch Control, or other assistive tech.\n- Read aloud by VoiceOver when the element is focused.\n- Should be localized and natural-sounding: \"Log in\", \"Email address\", \"Profile photo\".\n- Should not include the element type (VoiceOver adds \"button\", \"text field\" automatically).\n\nWhen to use each:\n- Use accessibilityLabel on every meaningful UI element so VoiceOver users can understand your app. This is required for accessibility compliance.\n- Use accessibilityIdentifier on elements you need to find in UI tests. Not every element needs one — only those your tests interact with or verify.\n- You can (and often should) set both on the same element. They are independent properties.\n\nCommon mistake: Using accessibilityLabel as a test identifier. This creates fragile tests that break when you localize the app or reword labels. Always use accessibilityIdentifier for testing."
  },
  {
    "topic": "accessibility",
    "level": 2,
    "question": "What are accessibility traits, and how do they affect VoiceOver behavior? Name at least six commonly used traits.",
    "hint": "Think about how VoiceOver knows that an element is a button, a header, or an adjustable slider.",
    "answer": "Accessibility traits are characteristics that describe how an accessibility element behaves and how VoiceOver should present it to the user. They inform VoiceOver about the element's role, state, and behavior.\n\nIn UIKit, traits are set via accessibilityTraits (a UIAccessibilityTraits option set). In SwiftUI, use .accessibilityAddTraits() and .accessibilityRemoveTraits().\n\nCommonly used traits:\n\n1. .button — Indicates the element is tappable. VoiceOver announces \"button\" after the label and instructs \"double tap to activate.\"\n\n2. .header — Marks the element as a section header. VoiceOver provides a rotor option to navigate between headers, which is extremely useful for quickly scanning long screens. Use this on section titles.\n\n3. .link — Indicates a hyperlink. VoiceOver announces \"link\" and the Links rotor lets users jump between links.\n\n4. .image — Indicates an image element. VoiceOver announces \"image\" after the label. If the image is decorative, combine with .accessibilityHidden(true) instead.\n\n5. .staticText — Default trait for labels. Indicates non-interactive text content.\n\n6. .adjustable — Indicates the element's value can be adjusted with swipe up/down gestures. Used for sliders, steppers, and pickers. You must implement accessibilityIncrement() and accessibilityDecrement() (or the SwiftUI .accessibilityAdjustableAction modifier).\n\n7. .selected — Indicates the element is currently selected (e.g., the active tab in a tab bar). VoiceOver announces \"selected\" before the label.\n\n8. .notEnabled — Indicates the element is disabled. VoiceOver announces \"dimmed\" and the user cannot activate it.\n\n9. .updatesFrequently — Tells VoiceOver the element's value changes often (e.g., a timer label). VoiceOver may poll it periodically.\n\n10. .startsMediaSession — Tells VoiceOver that activating this element starts media playback, so VoiceOver should not read its confirmation.\n\n11. .causesPageTurn — Indicates the element causes a page change (e.g., in a book reader).\n\n12. .summaryElement — Provides a summary of the app state shown on the status bar or similar area.\n\nTraits can be combined: element.accessibilityTraits = [.button, .selected]. In SwiftUI, this is done with .accessibilityAddTraits([.isButton, .isSelected]).\n\nBest practice: Always mark section headers with .header — it dramatically improves navigation for VoiceOver users."
  },
  {
    "topic": "accessibility",
    "level": 2,
    "question": "How do you post UIAccessibility notifications, and what are the common notification types? When would you use each?",
    "hint": "Think about what happens when new content appears dynamically or when the screen layout changes significantly.",
    "answer": "UIAccessibility notifications inform VoiceOver and other assistive technologies about dynamic UI changes. They are posted via UIAccessibility.post(notification:argument:).\n\nCommon notification types:\n\n1. .announcement — VoiceOver reads the provided string aloud. Use for transient messages that are not tied to a visible element: error messages, success confirmations, loading status updates.\n   UIAccessibility.post(notification: .announcement, argument: \"Message sent successfully\")\n   The argument is the string to announce. Note: announcements can be interrupted by user actions.\n\n2. .screenChanged — Tells VoiceOver that the screen has changed significantly (e.g., a new view controller was presented, a modal appeared). VoiceOver plays a screen-change sound and moves focus to the element passed as the argument (or the first element if nil).\n   UIAccessibility.post(notification: .screenChanged, argument: newViewController.view)\n\n3. .layoutChanged — Tells VoiceOver that part of the screen layout has changed (elements added, removed, or rearranged) but it is not a full screen change. VoiceOver moves focus to the argument element without the screen-change sound.\n   UIAccessibility.post(notification: .layoutChanged, argument: errorLabel)\n   Use after showing/hiding views, inserting table rows, or revealing error messages.\n\n4. .pageScrolled — Posted when a scroll view pages. Argument is a string describing the new position (e.g., \"Page 3 of 10\"). VoiceOver reads this string.\n\n5. .closedCaptioning — Notifies that closed captioning should be toggled.\n\nIn SwiftUI, use the AccessibilityNotification API (iOS 15+):\n   AccessibilityNotification.Announcement(\"Message sent\").post()\n   AccessibilityNotification.LayoutChanged(newElement).post()\n   AccessibilityNotification.ScreenChanged(newElement).post()\n\nBest practices:\n- Use .screenChanged for modal presentations and navigation pushes.\n- Use .layoutChanged for partial UI updates (showing an error label, expanding a section).\n- Use .announcement sparingly — only for information that does not have a corresponding visible element to focus on.\n- Always move focus to the most relevant element after a layout change so the user is not lost on the screen.\n- Test with VoiceOver on to verify that announcements are not cut off by subsequent UI changes."
  },
  {
    "topic": "accessibility",
    "level": 2,
    "question": "What color contrast requirements exist for iOS accessibility, and how do you verify and ensure compliance?",
    "hint": "Think about WCAG guidelines and the tools Apple provides for testing contrast ratios.",
    "answer": "Color contrast is fundamental to accessibility, ensuring text and UI elements are readable for users with low vision or color blindness.\n\nWCAG 2.1 Requirements:\n- Level AA (minimum):\n  - Normal text (under 18pt or 14pt bold): contrast ratio of at least 4.5:1 against background.\n  - Large text (18pt+ or 14pt+ bold): contrast ratio of at least 3:1.\n  - UI components and graphical objects: contrast ratio of at least 3:1 against adjacent colors.\n- Level AAA (enhanced):\n  - Normal text: 7:1 ratio.\n  - Large text: 4.5:1 ratio.\n\nApple-specific considerations:\n- iOS supports Increase Contrast accessibility setting (Settings > Accessibility > Display & Text Size > Increase Contrast). Apps should detect and respond to this.\n- In UIKit: UIAccessibility.isDarkerSystemColorsEnabled or observe UIAccessibility.darkerSystemColorsStatusDidChangeNotification.\n- In SwiftUI: @Environment(\\.colorSchemeContrast) var contrast, which returns .increased or .standard.\n- System colors like UIColor.label, UIColor.secondaryLabel automatically adapt to both dark mode and increased contrast settings.\n\nVerification tools:\n\n1. Accessibility Inspector (Xcode > Open Developer Tool) — Run an audit on the simulator or device. It flags contrast issues and shows the exact contrast ratio for focused elements.\n\n2. Xcode color contrast calculator — In Accessibility Inspector, use the Color Contrast Calculator to input foreground and background colors and check the ratio.\n\n3. Environment overrides in Xcode debugger — Toggle Increase Contrast, Dark Mode, and other settings without leaving the debugger.\n\n4. Third-party tools — WebAIM Contrast Checker, Colour Contrast Analyser, Stark plugin.\n\nBest practices:\n- Use semantic/system colors (UIColor.label, .systemBackground, .tintColor) that automatically provide correct contrast in all appearances.\n- When using custom colors, define separate color sets in Asset Catalog for Light, Dark, High Contrast Light, and High Contrast Dark appearances.\n- Never rely solely on color to convey information (e.g., red/green for error/success). Add icons, text, or patterns.\n- Test with Color Filters (Settings > Accessibility > Display & Text Size > Color Filters) to simulate various forms of color blindness.\n- Support Smart Invert (UIAccessibilityIsInvertColorsEnabled) and ensure images/media are marked with accessibilityIgnoresInvertColors = true so they don't get inverted."
  },
  {
    "topic": "accessibility",
    "level": 3,
    "question": "How do accessibility containers work, and when should you use accessibilityElements or accessibilityContainerType?",
    "hint": "Think about complex custom views where the default VoiceOver traversal order is incorrect.",
    "answer": "Accessibility containers control how VoiceOver groups and navigates through child elements. They are essential for complex custom views where the default traversal order does not match the logical reading order.\n\naccessibilityElements (UIKit):\n- An ordered array of accessibility elements that overrides the default element discovery.\n- Set on a container view to explicitly define which child elements VoiceOver sees and in what order.\n- Elements not in this array are invisible to VoiceOver.\n- Example: A custom calendar view where VoiceOver should navigate day cells left-to-right, top-to-bottom:\n  calendarView.accessibilityElements = dayCells.sorted { $0.frame.origin.y == $1.frame.origin.y ? $0.frame.origin.x < $1.frame.origin.x : $0.frame.origin.y < $1.frame.origin.y }\n\naccessibilityContainerType (iOS 11+):\n- Defines the type of container for VoiceOver navigation hints:\n  - .none — Not a container.\n  - .dataTable — A table with rows and columns. VoiceOver provides table-specific navigation.\n  - .list — A list of items. VoiceOver announces \"list, N items\" and provides list navigation.\n  - .landmark — A significant section of the page (like HTML landmarks). VoiceOver announces landmarks in the rotor.\n  - .semanticGroup — Groups related elements together logically.\n\nSwiftUI equivalents:\n- .accessibilityChildren — Provides custom child elements.\n- .accessibilityElement(children: .combine) — Merges all children into a single element with a combined label.\n- .accessibilityElement(children: .contain) — Acts as a container; children remain individual elements.\n- .accessibilityElement(children: .ignore) — Hides children and uses the parent as the element.\n\nWhen to use containers:\n\n1. Custom collection views — When your layout doesn't use UICollectionView/UITableView but has a grid of items. Set accessibilityContainerType = .list or .dataTable.\n\n2. Reordering elements — When visual layout order differs from logical reading order (e.g., a card with a title at the bottom that should be read first).\n\n3. Grouping related elements — Combine a label + value pair into a single accessibility element rather than having VoiceOver read them separately:\n   In SwiftUI: HStack { Text(\"Price\"); Text(\"$9.99\") }.accessibilityElement(children: .combine)\n\n4. Custom data tables — Implement UIAccessibilityContainerDataTable protocol for proper row/column/header navigation in grid-like views.\n\n5. Hiding decorative containers — Intermediate container views that have no semantic meaning should pass through to their children or be hidden.\n\nBest practice: Test by swiping through your screen with VoiceOver to verify the order makes sense. If you hear elements out of logical order or VoiceOver is reading irrelevant container views, restructure your accessibility elements."
  },
  {
    "topic": "accessibility",
    "level": 3,
    "question": "How do you implement custom accessibility actions, and what is the accessibility custom rotor? Provide examples of when each is useful.",
    "hint": "Think about providing shortcuts for actions that would otherwise require complex gesture sequences.",
    "answer": "Custom accessibility actions and custom rotors extend VoiceOver's functionality for complex interfaces that go beyond simple tap interactions.\n\nCustom Accessibility Actions:\n\nIn UIKit:\n- Override accessibilityCustomActions on an element to provide additional actions beyond the default activate (double-tap).\n- Each UIAccessibilityCustomAction has a name (read by VoiceOver), target, and selector.\n- User accesses them by swiping up/down after VoiceOver says \"Actions available.\"\n\nExample — A message cell with delete, reply, and forward:\n  cell.accessibilityCustomActions = [\n      UIAccessibilityCustomAction(name: \"Reply\", target: self, selector: #selector(replyToMessage)),\n      UIAccessibilityCustomAction(name: \"Forward\", target: self, selector: #selector(forwardMessage)),\n      UIAccessibilityCustomAction(name: \"Delete\", target: self, selector: #selector(deleteMessage))\n  ]\n\nIn SwiftUI:\n  .accessibilityAction(named: \"Reply\") { replyToMessage() }\n  .accessibilityAction(named: \"Forward\") { forwardMessage() }\n  .accessibilityAction(named: \"Delete\") { deleteMessage() }\n\nUse cases: Swipe-to-delete alternatives, long-press menu actions, drag-and-drop reordering (provide \"Move up\"/\"Move down\" actions), any gesture-based interaction that needs a VoiceOver equivalent.\n\nCustom Accessibility Rotor:\n\nThe rotor is a two-finger twist gesture that lets VoiceOver users choose a navigation mode (headings, links, form controls, etc.). Custom rotors add app-specific navigation options.\n\nIn UIKit:\n- Create UIAccessibilityCustomRotor with a name and an itemSearch callback.\n- The callback receives a UIAccessibilityCustomRotorSearchPredicate with the search direction (.previous or .next) and current item.\n- Return a UIAccessibilityCustomRotorItemResult pointing to the next matching element.\n\nExample — Navigate between unread messages:\n  let unreadRotor = UIAccessibilityCustomRotor(name: \"Unread Messages\") { predicate in\n      let currentIndex = self.unreadMessages.firstIndex(where: { $0.cell == predicate.currentItem.targetElement }) ?? -1\n      let nextIndex = predicate.searchDirection == .next ? currentIndex + 1 : currentIndex - 1\n      guard unreadMessages.indices.contains(nextIndex) else { return nil }\n      return UIAccessibilityCustomRotorItemResult(targetElement: unreadMessages[nextIndex].cell, targetRange: nil)\n  }\n  self.accessibilityCustomRotors = [unreadRotor]\n\nIn SwiftUI (iOS 15+):\n  .accessibilityRotor(\"Unread Messages\") {\n      ForEach(unreadMessages) { message in\n          AccessibilityRotorEntry(message.title, id: message.id)\n      }\n  }\n\nUse cases for custom rotors:\n- Navigate between specific content types (unread items, bookmarks, errors, search results).\n- Jump between sections in a complex document.\n- Navigate a map between points of interest.\n- Skip between items of a specific category in a long list.\n\nBest practice: Custom actions replace gesture-based interactions that VoiceOver users cannot perform. Custom rotors provide efficient navigation through large content that would otherwise require tedious sequential swiping."
  },
  {
    "topic": "accessibility",
    "level": 3,
    "question": "How do you support the Reduce Motion accessibility preference, and what are the best practices for motion-sensitive users?",
    "hint": "Think about how to detect the setting and what alternative visual feedback to provide.",
    "answer": "Reduce Motion is an accessibility setting (Settings > Accessibility > Motion) for users who experience discomfort from animations, parallax effects, and motion-heavy UI transitions. Supporting it is important for vestibular disorder accommodations.\n\nDetecting the preference:\n\nUIKit:\n- Check UIAccessibility.isReduceMotionEnabled at runtime.\n- Observe UIAccessibility.reduceMotionStatusDidChangeNotification for changes.\n\nSwiftUI:\n- Use @Environment(\\.accessibilityReduceMotion) var reduceMotion.\n- This updates automatically when the setting changes.\n\nWhat to modify when Reduce Motion is enabled:\n\n1. Replace slide/zoom transitions with cross-dissolve:\n   if UIAccessibility.isReduceMotionEnabled {\n       modalPresentationStyle = .overFullScreen\n       modalTransitionStyle = .crossDissolve\n   }\n\n2. Disable parallax and motion effects:\n   guard !UIAccessibility.isReduceMotionEnabled else { return }\n   let motionEffect = UIInterpolatingMotionEffect(...)\n   view.addMotionEffect(motionEffect)\n\n3. Reduce or eliminate spring animations:\n   In SwiftUI:\n   withAnimation(reduceMotion ? .none : .spring()) { ... }\n   Or use .animation(.default, value: state) which respects the system setting automatically in some contexts.\n\n4. Stop auto-playing animations (Lottie, GIFs, video backgrounds):\n   Show a static frame instead, or provide a play button.\n\n5. Simplify hero transitions and shared element animations.\n\n6. Use .contentTransition(.opacity) instead of .contentTransition(.numericText()) in SwiftUI.\n\nSwiftUI's transaction system:\n- SwiftUI's withAnimation respects reduce motion partially, but explicit checks give you more control.\n- Use the .transaction modifier to conditionally disable animation:\n  .transaction { transaction in\n      if reduceMotion { transaction.animation = nil }\n  }\n\nRelated preferences to also support:\n- UIAccessibility.prefersCrossFadeTransitions (iOS 14+) — The user prefers cross-fade over sliding transitions. A more specific preference than Reduce Motion.\n- UIAccessibility.isVideoAutoplayEnabled (iOS 13+) — Whether auto-play for videos is enabled. Respect this for video content.\n- @Environment(\\.accessibilityReduceTransparency) — Reduce blur and transparency effects that can cause readability issues.\n\nBest practices:\n- Never completely remove feedback — replace motion with opacity changes, color shifts, or scale changes.\n- Test your app with Reduce Motion enabled to ensure all interactions still feel responsive and navigable.\n- Consider making animations shorter and simpler as a default, not just when Reduce Motion is on.\n- Auto-playing carousels and scrolling banners should pause or provide manual controls regardless of the Reduce Motion setting."
  },
  {
    "topic": "accessibility",
    "level": 4,
    "question": "How do you use Accessibility Inspector to audit an app, and what are the key audits it performs? How does this relate to WCAG compliance?",
    "hint": "Think about the Inspector's audit categories and how they map to WCAG success criteria.",
    "answer": "Accessibility Inspector is a developer tool in Xcode (Xcode menu > Open Developer Tool > Accessibility Inspector) that helps audit and debug accessibility issues on simulators and connected devices.\n\nKey features:\n\n1. Element Inspector:\n   - Point at any UI element to see its accessibility properties: label, value, hint, traits, frame, identifier.\n   - Shows the element hierarchy and container relationships.\n   - Helps verify that labels are set correctly and traits match the element's behavior.\n\n2. Audit tool:\n   - Runs automated accessibility checks on the current screen.\n   - Reports issues with severity levels (warning, error).\n   - Categories of audits:\n     a. Element description — Missing accessibility labels on interactive elements. Maps to WCAG 1.1.1 (Non-text Content) and 4.1.2 (Name, Role, Value).\n     b. Contrast — Insufficient color contrast between text and background. Maps to WCAG 1.4.3 (Contrast Minimum) and 1.4.6 (Contrast Enhanced).\n     c. Hit area — Touch targets smaller than 44x44 points. Maps to WCAG 2.5.5 (Target Size).\n     d. Element detection — Elements that might be inaccessible or have conflicting properties.\n     e. Clipped text — Text that may be truncated at larger Dynamic Type sizes. Relates to WCAG 1.4.4 (Resize Text).\n     f. Traits — Missing or incorrect accessibility traits.\n\n3. Settings panel:\n   - Override accessibility settings in real time: Dynamic Type size, Bold Text, Reduce Motion, Increase Contrast, Reduce Transparency, Invert Colors.\n   - Faster than changing settings on the device for testing.\n\n4. Color Contrast Calculator:\n   - Input foreground and background colors.\n   - Shows the exact contrast ratio and pass/fail for WCAG AA and AAA levels.\n\nWCAG compliance mapping:\n- WCAG 1.1.1 (Non-text Content) — Every image, icon, and non-text element needs a text alternative. Audit checks for missing labels.\n- WCAG 1.3.1 (Info and Relationships) — Structure conveyed visually must be programmatic. Headers need .header trait, lists need container types.\n- WCAG 1.4.3/1.4.6 (Contrast) — Text contrast ratios. Audit measures pixel-level contrast.\n- WCAG 2.1.1 (Keyboard) — All functionality available via assistive tech. Custom actions replace gesture-only interactions.\n- WCAG 2.4.3 (Focus Order) — Logical navigation order. Inspector shows traversal order.\n- WCAG 4.1.2 (Name, Role, Value) — All controls have accessible names, roles (traits), and values. Inspector verifies all three.\n\nLimitations:\n- Automated audits catch only ~30-40% of accessibility issues.\n- Cannot verify that labels are meaningful (only that they exist).\n- Cannot verify logical reading order or user flow.\n- Manual VoiceOver testing is still essential.\n\nBest practice workflow:\n1. Run Accessibility Inspector audit on every screen during development.\n2. Fix all reported issues.\n3. Manually test with VoiceOver, navigating through the entire flow.\n4. Test with Dynamic Type at the largest sizes.\n5. Test with Increase Contrast and Reduce Motion enabled.\n6. Include accessibility testing in your CI pipeline using XCUITest accessibility audits (iOS 17+): try app.performAccessibilityAudit()."
  },
  {
    "topic": "accessibility",
    "level": 4,
    "question": "How do you make complex custom views (like a chart or a custom drawing view) accessible to VoiceOver users?",
    "hint": "Think about creating virtual accessibility elements that don't correspond to actual subviews.",
    "answer": "Complex custom views that use Core Graphics, Metal, or SpriteKit for rendering don't have a natural view hierarchy for VoiceOver to traverse. You must create a virtual accessibility layer that describes the content.\n\nApproach 1: Accessibility Elements (UIKit)\n\nCreate UIAccessibilityElement instances that represent logical parts of the view:\n\nclass ChartView: UIView {\n    override var isAccessibilityElement: Bool {\n        get { false }  // Container is not an element itself\n        set { }\n    }\n\n    override var accessibilityElements: [Any]? {\n        get {\n            return dataPoints.enumerated().map { index, point in\n                let element = UIAccessibilityElement(accessibilityContainer: self)\n                element.accessibilityLabel = \"\\(point.label)\"\n                element.accessibilityValue = \"\\(point.value) units, \\(point.percentage) percent\"\n                element.accessibilityTraits = .staticText\n                element.accessibilityFrameInContainerSpace = rectForDataPoint(at: index)\n                return element\n            }\n        }\n        set { }\n    }\n}\n\nKey properties:\n- accessibilityFrameInContainerSpace — Defines the region on screen for this virtual element. VoiceOver uses this for spatial navigation and to draw the focus rectangle.\n- The container (ChartView) must not be an accessibility element itself (isAccessibilityElement = false) so VoiceOver descends into its children.\n\nApproach 2: accessibilityElements with custom descriptions\n\nFor a chart, provide both individual data point navigation and a summary:\n- First element: A summary (\"Bar chart showing monthly revenue. January through June. Range: $10,000 to $50,000\").\n- Subsequent elements: Individual data points.\n- Custom rotor: Navigate between data points by category, high points, low points.\n\nApproach 3: SwiftUI with AXChartDescriptor (iOS 15+)\n\nFor charts, Apple provides Audio Graphs through AXChartDescriptor:\n- Implement the AXChartDescriptorRepresentable protocol.\n- Provide AXDataSeriesDescriptor objects with data points.\n- VoiceOver can then play an audio representation of the chart (sonification) and navigate data points.\n\nstruct MyChartView: View, AXChartDescriptorRepresentable {\n    func makeChartDescriptor() -> AXChartDescriptor {\n        let xAxis = AXCategoricalDataAxisDescriptor(title: \"Month\", categoryOrder: months)\n        let yAxis = AXNumericDataAxisDescriptor(title: \"Revenue\", range: 0...50000, gridlinePositions: []) { \"$\\(Int($0))\" }\n        let series = AXDataSeriesDescriptor(name: \"Revenue\", isContinuous: false, dataPoints: dataPoints.map { AXDataPoint(x: $0.month, y: $0.revenue) })\n        return AXChartDescriptor(title: \"Monthly Revenue\", summary: nil, xAxis: xAxis, yAxis: yAxis, additionalAxes: [], series: [series])\n    }\n}\n\nApproach 4: Custom drawing views (whiteboards, art apps)\n\n- Provide an overview label describing the canvas state.\n- Create accessibility elements for meaningful objects on the canvas.\n- Implement custom actions for operations (undo, change tool, etc.).\n- Consider providing an alternative list-based representation of canvas objects.\n\nBest practices:\n- Update accessibilityElements when the data changes and post a .layoutChanged notification.\n- Provide multiple levels of detail: summary first, then individual elements.\n- For charts, always implement AXChartDescriptorRepresentable when targeting iOS 15+.\n- Test with VoiceOver to ensure the virtual elements have correct frames and a logical navigation order."
  },
  {
    "topic": "accessibility",
    "level": 4,
    "question": "Describe how SwiftUI accessibility modifiers work and how they differ from UIKit's accessibility API. Cover grouping, sorting, and representation.",
    "hint": "Think about .accessibilityElement(children:), .accessibilitySortPriority, and .accessibilityRepresentation.",
    "answer": "SwiftUI provides a declarative accessibility API through view modifiers that is fundamentally different from UIKit's imperative approach:\n\nCore modifiers:\n\n1. .accessibilityLabel(_:) / .accessibilityValue(_:) / .accessibilityHint(_:) — Same conceptual purpose as UIKit but applied as view modifiers. They can also accept Text views for attributed content.\n\n2. .accessibilityAddTraits(_:) / .accessibilityRemoveTraits(_:) — Add or remove traits. SwiftUI automatically assigns traits based on view type (Button gets .isButton, NavigationLink gets .isLink), so you typically add supplementary traits like .isHeader.\n\n3. .accessibilityElement(children:) — Controls how a view's children appear to VoiceOver:\n   - .combine — Merges all children into a single element. Labels are concatenated. Use for related info that should be read as one unit (e.g., a card with title + subtitle + price).\n   - .contain — Children remain separate elements within a container. The container itself is not an element.\n   - .ignore — Hides children entirely. The parent becomes the element with whatever label you set. Use when you want full control over the accessibility representation.\n\n4. .accessibilitySortPriority(_:) — Controls VoiceOver navigation order among siblings. Higher values are visited first. Default is 0. Use when visual layout order differs from logical reading order.\n   HStack {\n       Text(\"$9.99\").accessibilitySortPriority(0)\n       Text(\"Premium Plan\").accessibilitySortPriority(1)  // Read first\n   }\n\n5. .accessibilityHidden(_:) — Completely hides the element from VoiceOver. Use for decorative images, redundant labels, or elements that would be confusing.\n\n6. .accessibilityAction(_:_:) — Adds custom actions beyond the default activate action. Multiple actions can be added, and named variants provide labeled actions.\n\n7. .accessibilityRepresentation — (iOS 15+) Provides an entirely different view tree for accessibility purposes. The visual view and the accessibility view can be completely different structures:\n   ComplexCustomView()\n       .accessibilityRepresentation {\n           VStack {\n               Text(summary)\n               ForEach(items) { item in\n                   Text(item.description)\n               }\n           }\n       }\n   This is powerful for views where the visual representation is fundamentally different from the logical content.\n\n8. .accessibilityInputLabels(_:) — Provides alternative labels for Voice Control (\"tap X\" commands). Useful when the visible label differs from what a user might say.\n\n9. .accessibilityRotor — Creates custom rotor entries for navigation.\n\n10. .accessibilityFocused(_:) — Binds accessibility focus to a state variable, allowing programmatic focus management.\n\nKey differences from UIKit:\n\n- Declarative vs. imperative — SwiftUI modifiers compose naturally in the view hierarchy. UIKit requires setting properties on individual elements.\n- Automatic trait inference — SwiftUI automatically sets traits based on view type. UIKit requires manual trait assignment.\n- Combine pattern — SwiftUI's .accessibilityElement(children: .combine) has no direct UIKit equivalent; you'd need to create a custom accessibility element manually.\n- No accessibilityElements array — SwiftUI uses the view hierarchy itself, modified by accessibilityElement(children:) and accessibilityHidden, instead of manually setting an elements array.\n- Focus management — SwiftUI's @AccessibilityFocusState is more ergonomic than posting UIAccessibility.layoutChanged notifications.\n\nBest practices:\n- Use .combine for any group of labels that form a single piece of information.\n- Use .ignore when you provide a custom label on the parent.\n- Always test VoiceOver navigation order; use .accessibilitySortPriority when needed.\n- Use .accessibilityRepresentation for complex custom views instead of trying to make the visual hierarchy work for accessibility."
  },
  {
    "topic": "accessibility",
    "level": 5,
    "question": "Design a comprehensive accessibility testing strategy for a large iOS app. What automated tests, manual processes, and CI integrations would you implement?",
    "hint": "Consider XCUITest accessibility audits, snapshot testing, manual VoiceOver testing protocols, and integrating checks into CI/CD.",
    "answer": "A comprehensive accessibility testing strategy combines automated checks, structured manual testing, and CI/CD integration:\n\n1. Automated XCUITest Accessibility Audits (iOS 17+):\n\nXCUITest provides performAccessibilityAudit() which checks for common issues:\n\nfunc testAccessibilityAudit() throws {\n    let app = XCUIApplication()\n    app.launch()\n    // Navigate to each major screen\n    try app.performAccessibilityAudit()\n}\n\n- Configure which audits to run: .all, .dynamicType, .contrast, .elementDetection, .sufficientElementDescription, .hitRegion.\n- Filter false positives with the audit issue handler closure.\n- Run these tests in CI for every PR.\n\n2. Custom XCUITest assertions:\n\n- Verify critical elements have accessibility labels:\n  XCTAssertFalse(app.buttons[\"submit_button\"].label.isEmpty)\n- Check that accessibility identifiers exist for testable elements.\n- Verify VoiceOver reading order by checking element positions in the accessibility hierarchy.\n- Test Dynamic Type by setting the content size category:\n  app.launchArguments += [\"-UIPreferredContentSizeCategoryName\", \"UICTContentSizeCategoryAccessibilityExtraExtraExtraLarge\"]\n  Then verify no truncation and no overlapping elements using frame assertions.\n\n3. Snapshot/screenshot testing for visual regression:\n\n- Capture screenshots at each Dynamic Type size (all 12 sizes from XS to AX5).\n- Capture in both Light and Dark mode with Increase Contrast on/off.\n- Use snapshot testing libraries (swift-snapshot-testing) to detect visual regressions.\n- Store reference images in the repo and compare in CI.\n\n4. Static analysis and linting:\n\n- Custom SwiftLint rules or a dedicated tool to flag:\n  - UIImageView without accessibilityLabel.\n  - UIButton without accessibilityLabel or title.\n  - Missing .accessibilityElement modifiers on custom views.\n- Integrate with pre-commit hooks or CI checks.\n\n5. Manual VoiceOver testing protocol:\n\nCreate a structured test script that QA and developers follow:\n- Navigate every screen using VoiceOver swipe gestures only.\n- Verify all interactive elements are reachable and have meaningful labels.\n- Check reading order matches logical flow.\n- Test all custom actions are accessible.\n- Verify rotor navigation (headers, links, custom rotors) works correctly.\n- Test with Braille display if possible.\n- Schedule dedicated VoiceOver testing sprints (e.g., before each release).\n\n6. Additional manual testing:\n\n- Switch Control — Navigate the entire app using Switch Control to verify all elements are reachable.\n- Voice Control — Use Voice Control to tap buttons, links, and controls by name.\n- Full Keyboard Access — Navigate with an external keyboard (Tab, Enter, arrows).\n- Dynamic Type — Test at the five accessibility sizes (AX1-AX5) to check for layout issues.\n- Reduce Motion — Verify all animations respect the preference.\n- Smart Invert / Classic Invert — Check that images and videos don't get inverted.\n- Increase Contrast — Verify text remains readable.\n\n7. CI/CD integration:\n\n- Run accessibility audit tests on every PR (fast, automated).\n- Run Dynamic Type screenshot tests on every PR.\n- Run full snapshot suite nightly (all combinations of size/contrast/mode).\n- Block PRs that introduce new accessibility audit failures.\n- Generate accessibility reports as build artifacts.\n\n8. User testing:\n\n- Partner with users who actually rely on assistive technologies.\n- Include accessibility in beta testing programs.\n- Gather feedback from Apple's accessibility engineering team during WWDC labs.\n\n9. Metrics and monitoring:\n\n- Track the percentage of screens covered by accessibility audits.\n- Track the number of accessibility audit failures over time.\n- Monitor App Store reviews mentioning accessibility.\n- Use analytics to understand what percentage of users enable assistive technologies.\n\n10. Developer education:\n\n- Include accessibility checklist in PR templates.\n- Run periodic workshops on VoiceOver testing.\n- Pair developers with accessibility consultants for complex features.\n- Maintain an internal accessibility style guide with do's and don'ts.\n\nThis layered approach catches most issues automatically, ensures critical paths are manually verified, and creates a culture where accessibility is part of the definition of done."
  },
  {
    "topic": "accessibility",
    "level": 5,
    "question": "How would you architect an app to be fully accessible from the ground up, including supporting VoiceOver, Switch Control, Voice Control, Full Keyboard Access, and Dynamic Type at all sizes?",
    "hint": "Think about design system foundations, semantic view hierarchies, and how each assistive technology interacts with your views differently.",
    "answer": "Building an app that is fully accessible across all assistive technologies requires architectural decisions from the very beginning:\n\n1. Design System with Accessibility Built In:\n\n- Create a component library where every component has accessibility baked in by default:\n  - Buttons always derive their accessibilityLabel from their title. Image-only buttons require a mandatory label parameter.\n  - Text components use preferredFont/scaledFont exclusively. No hard-coded font sizes.\n  - All spacing uses @ScaledMetric so padding and margins scale with Dynamic Type.\n  - Touch targets enforce a minimum 44x44pt hit area using .frame(minWidth: 44, minHeight: 44) regardless of visual size.\n  - Color tokens include high-contrast variants automatically selected via UITraitCollection.\n\n- Enforce accessibility at the component level so individual feature developers cannot accidentally create inaccessible UI.\n\n2. Semantic View Hierarchy:\n\n- Structure views so the visual hierarchy matches the accessibility hierarchy. Avoid z-stacking unrelated content.\n- Use .accessibilityElement(children: .combine) on logical groups (list rows, cards, form fields).\n- Mark all section titles with .isHeader trait for rotor-based header navigation.\n- Use .accessibilityContainerType(.list) on scrollable lists and .dataTable on grid views.\n- Provide .accessibilityRotor for all list views with useful filter criteria.\n\n3. VoiceOver Considerations:\n\n- Every meaningful element has a label. Decorative elements are hidden.\n- Dynamic content changes post .announcement, .layoutChanged, or .screenChanged notifications.\n- Custom views implement accessibilityElements or use .accessibilityRepresentation.\n- All gesture-based interactions have equivalent custom accessibility actions.\n- Focus management: After navigation events, focus moves to the appropriate element using AccessibilityFocusState.\n\n4. Switch Control / Full Keyboard Access:\n\n- These technologies navigate via the focusable element hierarchy. Ensure:\n  - All interactive elements are focusable (UIKit: canBecomeFocused, SwiftUI: .focusable()).\n  - Tab order is logical (matches reading order, skip decorative elements).\n  - Custom controls respond to the .accessibilityActivate() action.\n  - No interaction requires gestures that Switch Control cannot simulate (multi-touch, long press without a fallback).\n- Test keyboard shortcuts: Cmd+key combinations for power users. Expose via UIKeyCommand.\n- Implement proper focus styling so keyboard/switch users can see which element is focused.\n\n5. Voice Control:\n\n- Voice Control lets users say \"tap [label]\" to activate elements. Ensure:\n  - Visible text matches accessibilityLabel. If they diverge, use .accessibilityInputLabels to provide alternatives.\n  - Buttons with icons only have clear labels that a user could reasonably guess.\n  - No two visible elements on the same screen have identical labels (creates ambiguity).\n  - Test by enabling Voice Control and attempting to interact with every element by voice.\n\n6. Dynamic Type at All Sizes:\n\n- Layout strategy: Use stack-based layouts (VStack/HStack with adaptive switching). At large sizes, horizontal layouts may need to become vertical:\n  ViewThatFits {\n      HStack { content }\n      VStack { content }\n  }\n  Or use AX size class detection: @Environment(\\.dynamicTypeSize) var typeSize, and switch layout when typeSize.isAccessibilitySize.\n\n- Scrollability: Wrap all screens in ScrollView. Content that fits at small sizes may overflow at AX5.\n- Images: Scale with @ScaledMetric. Don't let images consume the entire screen at large sizes — cap with maxHeight.\n- Table/list rows: Use self-sizing cells. Never hard-code row heights.\n- Navigation bars: Large titles help. Custom title views must scale.\n- Multi-line support: Ensure all labels can wrap (numberOfLines = 0 in UIKit, SwiftUI wraps by default).\n\n7. Architecture Patterns:\n\n- ViewModel accessibility properties: ViewModels should provide computed properties for accessibility labels, hints, and values. This keeps accessibility logic testable:\n  var priceAccessibilityLabel: String { \"\\(product.name), \\(formattedPrice)\" }\n\n- Accessibility protocol: Define a protocol like AccessibleViewModel that requires accessibility properties. Enforce via linting.\n\n- Feature flags: Use feature flags to A/B test accessibility improvements without risking regressions.\n\n8. Testing Infrastructure:\n\n- Unit tests for ViewModel accessibility properties.\n- XCUITest accessibility audits on every screen.\n- Snapshot tests at 4 key Dynamic Type sizes (default, XXXL, AX1, AX5).\n- CI enforcement: PRs cannot merge with accessibility audit failures.\n- Quarterly manual testing with actual assistive technology users.\n\n9. Continuous Maintenance:\n\n- Accessibility section in PR review checklist.\n- Design reviews include accessibility review (contrast, touch targets, text alternatives).\n- Regression alerts: Monitor user-reported accessibility issues in support channels.\n- iOS version updates: Test accessibility with each iOS beta (Apple changes VoiceOver behavior).\n\nThe key principle: Accessibility is not a feature to be added later — it is a quality attribute that must be designed into every layer of the application, from the design system through the architecture to the testing pipeline."
  },
  {
    "topic": "cicd",
    "level": 0,
    "question": "What are the three main dependency managers available for iOS projects?",
    "hint": "Think about the tools that manage third-party libraries.",
    "answer": "The three main dependency managers are:\n1. CocoaPods — uses a Podfile, centralized spec repo, modifies Xcode project/workspace. Oldest and most widely used.\n2. Carthage — uses a Cartfile, decentralized, builds frameworks that you manually link. Less intrusive.\n3. Swift Package Manager (SPM) — Apple's built-in tool, uses Package.swift, integrated into Xcode since Xcode 11. Preferred for new projects.\nSPM is now the recommended choice as it's native, requires no extra tooling, and supports binary targets."
  },
  {
    "topic": "cicd",
    "level": 0,
    "question": "What is the purpose of Xcode schemes and build configurations?",
    "hint": "Think about how you switch between Debug and Release builds.",
    "answer": "A scheme defines which targets to build, the build configuration to use, and actions to perform (build, run, test, profile, analyze, archive).\nBuild configurations (typically Debug and Release) control compiler settings like optimization level, preprocessor macros, and code signing.\nDebug configuration enables debugging symbols, disables optimization, and may include extra logging.\nRelease configuration enables optimization (-O), strips debug symbols, and uses production signing."
  },
  {
    "topic": "cicd",
    "level": 0,
    "question": "What is TestFlight and how is it used for app distribution?",
    "hint": "Think about how beta testers get access to your app before it goes to the App Store.",
    "answer": "TestFlight is Apple's platform for distributing beta versions of iOS apps to testers.\nYou upload a build to App Store Connect, add internal testers (up to 100, from your team) or external testers (up to 10,000, requires beta review).\nInternal testers get access immediately; external testers require an initial review.\nTestFlight builds expire after 90 days. Testers install via the TestFlight app.\nIt supports multiple build groups, release notes per build, and automatic update notifications."
  },
  {
    "topic": "cicd",
    "level": 1,
    "question": "Explain the Xcode build phases and their execution order.",
    "hint": "Think about what happens from source code to final binary.",
    "answer": "Xcode build phases execute in this order:\n1. Dependencies — resolves target dependencies\n2. Compile Sources — compiles .swift/.m files into object files\n3. Link Binary With Libraries — links object files with frameworks and libraries\n4. Copy Bundle Resources — copies assets, storyboards, xibs, and other resources into the app bundle\n5. Run Script — executes custom shell scripts (e.g., SwiftLint, code generation)\nYou can add custom build phases like 'Run Script' for tasks like incrementing build numbers, running linters, or generating code. The order of build phases matters and can be rearranged in Xcode."
  },
  {
    "topic": "cicd",
    "level": 1,
    "question": "What is the difference between a certificate and a provisioning profile in iOS code signing?",
    "hint": "One proves identity, the other grants permissions.",
    "answer": "Certificate: A digital identity that proves who signed the app. Issued by Apple, contains a public key paired with a private key stored in your Keychain.\nTypes: Development (for debugging on devices) and Distribution (for App Store/Ad Hoc/Enterprise).\n\nProvisioning Profile: A document that ties together an App ID, certificates, device UDIDs (for development/ad-hoc), and entitlements.\nIt tells iOS: 'this app, signed by this developer, is allowed to run on these devices with these capabilities.'\n\nWithout a valid provisioning profile, iOS won't launch the app. Without a valid certificate, you can't sign the app."
  },
  {
    "topic": "cicd",
    "level": 1,
    "question": "How does Swift Package Manager resolve dependencies, and what is the Package.resolved file?",
    "hint": "Think about version resolution and reproducibility.",
    "answer": "SPM uses semantic versioning to resolve dependencies. In Package.swift, you specify version requirements (from:, .upToNextMajor, .upToNextMinor, exact, branch, revision).\n\nResolution process:\n1. Reads all Package.swift manifests in the dependency graph\n2. Applies version constraints from all packages\n3. Uses PubGrub algorithm to find compatible versions\n4. Writes the resolved versions to Package.resolved\n\nPackage.resolved is a lock file that records exact resolved versions for reproducible builds. It should be committed to version control for apps (ensuring CI builds match local) but not for libraries (let consumers resolve)."
  },
  {
    "topic": "cicd",
    "level": 2,
    "question": "Compare Fastlane's match, gym, and deliver tools and when you would use each.",
    "hint": "Think about the different stages of the iOS deployment pipeline.",
    "answer": "match: Manages code signing certificates and provisioning profiles in a shared Git repo or cloud storage. Ensures the entire team uses the same signing identity, eliminating 'code signing hell.'\nUsage: `fastlane match development`, `fastlane match appstore`\n\ngym (alias: build_app): Builds and packages your app into an .ipa file. Wraps xcodebuild with sensible defaults.\nUsage: `fastlane gym --scheme MyApp --export_method app-store`\n\ndeliver (alias: upload_to_app_store): Uploads builds, screenshots, and metadata to App Store Connect. Can submit for review.\nUsage: `fastlane deliver --ipa MyApp.ipa`\n\nTypical pipeline: match → gym → deliver (sign → build → upload)."
  },
  {
    "topic": "cicd",
    "level": 2,
    "question": "What are xcconfig files and how do they help manage build settings across configurations?",
    "hint": "Think about externalizing build settings from the Xcode project file.",
    "answer": "xcconfig (Xcode Configuration) files are plain-text files that define build settings outside of the .xcodeproj.\n\nBenefits:\n- Version control friendly (plain text vs opaque pbxproj)\n- Shared settings across targets via #include\n- Environment-specific configs (Debug.xcconfig, Staging.xcconfig, Release.xcconfig)\n- Cleaner merge conflicts\n\nSyntax: KEY = value, supports variable substitution $(inherited), conditional settings [config=Debug].\n\nAssign to targets in Project → Info → Configurations. Settings cascade: xcconfig → project → target (target wins).\n\nCommon use: API URLs, bundle IDs, signing identities per environment."
  },
  {
    "topic": "cicd",
    "level": 2,
    "question": "How would you set up environment-based configurations (Debug, Staging, Release) in an iOS project?",
    "hint": "Think about how different API endpoints and settings vary across environments.",
    "answer": "Approach:\n1. Create custom build configurations in Project → Info (duplicate Release for Staging)\n2. Create xcconfig files per environment with different values (API_URL, BUNDLE_ID_SUFFIX, etc.)\n3. Use User-Defined build settings or Info.plist variables: $(API_BASE_URL)\n4. Read at runtime: Bundle.main.infoDictionary?[\"API_BASE_URL\"]\n\nAlternative: Compiler flags (-DSTAGING) with #if STAGING / #if RELEASE checks.\n\nFor schemes: Create separate schemes (App-Debug, App-Staging, App-Release) each using the appropriate configuration.\n\nFor CI: Pass the scheme name as a parameter to select the environment automatically."
  },
  {
    "topic": "cicd",
    "level": 3,
    "question": "How does Xcode Cloud work and what are its advantages over third-party CI solutions?",
    "hint": "Think about Apple's native CI/CD integration.",
    "answer": "Xcode Cloud is Apple's built-in CI/CD service integrated into Xcode and App Store Connect.\n\nHow it works:\n- Workflows define triggers (branch push, PR, tag, schedule), actions (build, test, analyze, archive), and post-actions (notify, deploy to TestFlight)\n- Runs on Apple-managed infrastructure (macOS VMs with Xcode pre-installed)\n- Configured via Xcode UI or App Store Connect web\n\nAdvantages over third-party (GitHub Actions, Bitrise, etc.):\n- Zero infrastructure setup — Apple manages macOS runners\n- Deep Xcode integration — results appear in Xcode navigator\n- Automatic TestFlight deployment\n- Free tier (25 compute hours/month)\n- ci_scripts hooks (ci_post_clone.sh, ci_pre_xcodebuild.sh) for customization\n\nLimitations: Less flexible than Jenkins/GitHub Actions, limited to Apple ecosystem, fewer customization options."
  },
  {
    "topic": "cicd",
    "level": 3,
    "question": "What are SPM plugins and how can they be used in a build pipeline?",
    "hint": "Think about extending the build process with custom commands.",
    "answer": "SPM plugins extend the build process with custom functionality. Two types:\n\n1. Build Tool Plugins: Run automatically during builds. Generate source code or resources.\n- Conform to BuildToolPlugin protocol\n- Return build commands (prebuild or build commands)\n- Example: Code generation from .proto files, SwiftGen for assets\n\n2. Command Plugins: Run on-demand via `swift package <command>`.\n- Conform to CommandPlugin protocol\n- Example: Formatting (swift-format), linting, documentation generation\n\nPlugin structure:\n```\nPlugins/MyPlugin/MyPlugin.swift\n```\n\nDeclared in Package.swift with .plugin target.\n\nAdvantages: Native integration, no external tools needed, cross-platform, sandboxed execution for safety."
  },
  {
    "topic": "cicd",
    "level": 3,
    "question": "What is periphery and how does it complement SwiftLint in a CI pipeline?",
    "hint": "One checks style, the other checks for dead code.",
    "answer": "SwiftLint: Enforces Swift style and conventions. Catches style violations, naming issues, code complexity, and common anti-patterns. Rule-based, configurable via .swiftlint.yml.\n\nperiphery: Detects unused code (dead code elimination). Finds unused classes, protocols, functions, properties, enum cases, and imports that SwiftLint cannot detect.\n\nHow periphery works:\n- Builds the project to get the index store\n- Analyzes the index to find declarations with no references\n- Reports unused code with file/line locations\n\nCI integration:\n- SwiftLint: Run as build phase or CI step, fail on violations\n- periphery: Run periodically (not every build — it's slower), report unused code\n\nTogether they ensure code quality (SwiftLint) and codebase hygiene (periphery)."
  },
  {
    "topic": "cicd",
    "level": 4,
    "question": "How would you optimize build times in a large iOS project with 50+ modules?",
    "hint": "Think about caching, parallelism, and dependency graph optimization.",
    "answer": "Strategies for build optimization:\n\n1. Module graph optimization:\n- Minimize cross-module dependencies\n- Use protocols/interfaces at module boundaries to break recompilation chains\n- Avoid circular dependencies\n\n2. Caching:\n- Enable Xcode build cache (DerivedData)\n- Use remote build caching (Bazel, or tools like CacheKit)\n- SPM: cache resolved packages\n\n3. Build settings:\n- Debug: SWIFT_COMPILATION_MODE = singlefile (parallel compilation)\n- Enable EAGER_LINKING\n- Use explicit modules (SWIFT_ENABLE_EXPLICIT_MODULES)\n- Minimize bridging header usage\n\n4. CI-specific:\n- Warm DerivedData cache between builds\n- Selective testing (only test changed modules)\n- Parallelize independent jobs\n\n5. Code-level:\n- Reduce type inference complexity\n- Avoid expensive compile-time features in hot paths\n- Split large files"
  },
  {
    "topic": "cicd",
    "level": 4,
    "question": "Explain the iOS app signing process end-to-end, from development to App Store submission.",
    "hint": "Trace the journey from creating a CSR to the app appearing on the store.",
    "answer": "End-to-end signing process:\n\n1. Certificate creation:\n- Generate CSR (Certificate Signing Request) from Keychain → sends public key to Apple\n- Apple issues a certificate (public key + Apple's signature)\n- Private key stays in Keychain\n\n2. App ID registration:\n- Register Bundle ID in Apple Developer portal\n- Enable capabilities (push notifications, iCloud, etc.)\n\n3. Provisioning profile:\n- Development: ties App ID + Dev Certificate + Device UDIDs\n- Distribution: ties App ID + Distribution Certificate (no devices for App Store)\n\n4. Code signing during build:\n- Xcode signs the binary with your private key\n- Embeds the provisioning profile in the .app bundle\n- Signs frameworks, extensions, and app clips separately\n\n5. Submission:\n- Archive → export signed .ipa\n- Upload via Xcode, altool, or Transporter\n- Apple re-signs with Apple's distribution certificate for App Store delivery\n\n6. Installation:\n- iOS verifies the chain: Apple root CA → Apple signing cert → provisioning profile → app signature"
  },
  {
    "topic": "cicd",
    "level": 4,
    "question": "How do you manage build numbers and versioning in a CI/CD pipeline?",
    "hint": "Think about CFBundleShortVersionString vs CFBundleVersion and automation.",
    "answer": "Version (CFBundleShortVersionString): Marketing version shown to users (e.g., 2.5.1). Semantic versioning: major.minor.patch. Manually bumped.\n\nBuild number (CFBundleVersion): Internal build identifier. Must be unique per version for App Store. Auto-incremented in CI.\n\nCI automation strategies:\n1. CI build number: Use $CI_BUILD_NUMBER or $GITHUB_RUN_NUMBER as build number\n2. Timestamp-based: YYYYMMDDHHmm format (e.g., 202602171030)\n3. Git-based: git rev-list --count HEAD\n4. Fastlane: increment_build_number, latest_testflight_build_number + 1\n\nSet in CI:\n- agvtool new-version -all $BUILD_NUMBER\n- PlistBuddy -c 'Set :CFBundleVersion $BUILD_NUMBER'\n- Fastlane: increment_build_number(build_number: ENV['CI_BUILD_NUMBER'])\n\nApp Store requires each upload to have a unique build number per version."
  },
  {
    "topic": "cicd",
    "level": 5,
    "question": "Design a complete CI/CD pipeline for a large iOS app with 30+ SPM modules, multiple app targets, and automated release process.",
    "hint": "Think about pipeline stages, parallelism, caching, testing strategy, and release automation.",
    "answer": "Pipeline design:\n\n1. PR Pipeline (triggered on every PR):\n- Lint: SwiftLint + SwiftFormat check (parallel, fast)\n- Build: Incremental build with cached DerivedData\n- Test: Selective unit tests (only changed modules + dependents via dependency graph analysis)\n- Snapshot tests: Run only if UI-related modules changed\n- Code coverage: Enforce minimum per-module thresholds\n- periphery: Weekly scheduled run for dead code\n\n2. Merge Pipeline (triggered on merge to main):\n- Full build (all targets)\n- Full test suite (unit + integration + UI)\n- Archive → upload to TestFlight (internal)\n- Notify team via Slack\n\n3. Release Pipeline (triggered by tag):\n- Version bump validation\n- Full test suite + performance tests\n- Archive all app targets\n- Upload to App Store Connect\n- Submit for review (automated via Fastlane deliver)\n- Create GitHub release with changelog\n\nInfrastructure:\n- Self-hosted Mac runners for speed + remote caching\n- Fastlane for orchestration (Fastfile with lanes per pipeline)\n- match for signing across all CI machines\n- Modular Fastfile: one lane per module for selective testing\n- Artifacts: dSYMs uploaded to crash reporter, .ipa archived"
  },
  {
    "topic": "cicd",
    "level": 5,
    "question": "How would you implement a modular CI strategy where only affected modules are tested on each PR?",
    "hint": "Think about dependency graph analysis and selective test execution.",
    "answer": "Selective testing strategy:\n\n1. Dependency graph construction:\n- Parse Package.swift / project to build a directed acyclic graph of module dependencies\n- Tool: custom script or use `swift package show-dependencies --format json`\n\n2. Change detection:\n- `git diff --name-only origin/main...HEAD` → list of changed files\n- Map files to modules (each module has known source paths)\n\n3. Impact analysis:\n- For each changed module, find all downstream dependents (transitive closure)\n- These are the 'affected' modules that need testing\n\n4. Selective execution:\n- Generate xcodebuild commands targeting only affected test targets\n- `xcodebuild test -only-testing:ModuleATests -only-testing:ModuleBTests`\n\n5. Safety nets:\n- Full test suite runs on merge to main (not just PR)\n- Weekly full regression runs\n- If core/shared modules change, run everything\n\n6. Caching:\n- Cache test results by module + commit hash\n- Skip tests for modules with no changes and no changed dependencies\n\nThis can reduce PR test times from 30+ minutes to under 5 minutes."
  },
  {
    "topic": "cicd",
    "level": 5,
    "question": "What strategies exist for managing code signing across a large team with multiple CI machines?",
    "hint": "Think about centralized credential management and automation.",
    "answer": "Strategies for team-wide code signing:\n\n1. Fastlane match (recommended):\n- Stores certificates and profiles in encrypted Git repo or Google Cloud/S3\n- All team members and CI machines use the same identity\n- `match development`, `match appstore` — generates or fetches\n- Encryption via MATCH_PASSWORD environment variable\n- Nuke and regenerate when certificates expire\n\n2. Xcode Automatic Signing:\n- Works for small teams but breaks on CI (needs Apple ID, 2FA)\n- Not recommended for CI environments\n\n3. Manual with Keychain import:\n- Export .p12 + .mobileprovision, import on CI machines\n- `security import cert.p12 -k build.keychain`\n- Copy profiles to ~/Library/MobileDevice/Provisioning Profiles/\n\n4. Enterprise approach:\n- Dedicated signing service (signing as a service)\n- HSM-backed certificate storage\n- API-driven signing (custom tooling)\n\nBest practices:\n- Never commit certificates to source control unencrypted\n- Rotate certificates before expiry (Apple certificates last 1 year)\n- Use CI-specific keychain (not login keychain)\n- Set keychain timeout to prevent locking during long builds"
  },
  {
    "topic": "system-design",
    "level": 0,
    "question": "What is the difference between online-first and offline-first app architectures?",
    "hint": "Think about what happens when the user has no internet connection.",
    "answer": "Online-first: App requires internet to function. Data is fetched from the server on demand. Offline state shows errors or empty states.\n\nOffline-first: App works fully without internet. Data is stored locally and synced when connectivity returns.\n\nKey differences:\n- Data source: Online-first reads from network; offline-first reads from local database\n- User experience: Offline-first provides seamless experience regardless of connectivity\n- Complexity: Offline-first requires local storage, sync logic, and conflict resolution\n- Examples: Online-first = social media feed; Offline-first = note-taking app, email client\n\nOffline-first is preferred for apps where users expect to work without internet (travel, poor connectivity areas)."
  },
  {
    "topic": "system-design",
    "level": 0,
    "question": "What is API pagination and why is it important for mobile apps?",
    "hint": "Think about loading large datasets efficiently.",
    "answer": "API pagination is the practice of dividing large datasets into smaller chunks (pages) that are loaded incrementally.\n\nWhy it's important for mobile:\n- Memory: Loading 10,000 items at once would consume excessive memory\n- Network: Smaller payloads = faster response times, less data usage\n- UI: Users only see a screenful at a time anyway\n\nCommon strategies:\n1. Offset-based: ?page=2&limit=20 — simple but can miss/duplicate items if data changes\n2. Cursor-based: ?after=lastItemId&limit=20 — stable, handles insertions/deletions\n3. Keyset: ?created_before=timestamp&limit=20 — efficient for sorted data\n\nMobile implementation: Load first page on appear, trigger next page when user scrolls near the bottom (infinite scroll). Show loading indicator at bottom."
  },
  {
    "topic": "system-design",
    "level": 0,
    "question": "What is a feature flag system and why would you use one in a mobile app?",
    "hint": "Think about controlling feature visibility without app updates.",
    "answer": "A feature flag (or feature toggle) is a mechanism to enable or disable features at runtime without deploying new code.\n\nUse cases:\n- Gradual rollout: Enable feature for 5% of users, then 25%, then 100%\n- A/B testing: Show different UI variants to measure impact\n- Kill switch: Instantly disable a broken feature server-side\n- Development: Work on features behind flags, merge to main without shipping\n\nImplementation:\n- Backend service returns flag values (Firebase Remote Config, LaunchDarkly, custom)\n- App checks flag before showing feature: if featureFlags.isEnabled(.newCheckout)\n- Cache flags locally for offline access\n- Default values for when server is unreachable\n\nBenefits: Decouples deployment from release, reduces risk, enables experimentation."
  },
  {
    "topic": "system-design",
    "level": 1,
    "question": "How would you design a simple image loading and caching system for an iOS app?",
    "hint": "Think about memory cache, disk cache, and async loading.",
    "answer": "Two-level cache design:\n\n1. Memory cache (NSCache):\n- Fast access, limited size\n- Automatically evicts under memory pressure\n- Key: image URL string, Value: UIImage\n\n2. Disk cache:\n- Persistent across app launches\n- Store in Caches directory (system can purge)\n- Key: MD5/SHA256 hash of URL\n- Set max size and TTL (time-to-live)\n\nLoading flow:\n1. Check memory cache → return if found\n2. Check disk cache → decode, store in memory cache, return\n3. Download from network → store in both caches, return\n\nAdditional considerations:\n- Cancel in-flight requests when cells are reused (prepareForReuse)\n- Downscale images to display size before caching\n- Use URLSession for download (supports HTTP caching headers)\n- Deduplicate concurrent requests for the same URL"
  },
  {
    "topic": "system-design",
    "level": 1,
    "question": "What are the main considerations when designing a networking layer for an iOS app?",
    "hint": "Think about abstraction, error handling, and testability.",
    "answer": "Key considerations:\n\n1. Abstraction: Protocol-based API client that hides URLSession details. Define endpoints as types (enum or struct) with path, method, parameters, headers.\n\n2. Error handling: Map HTTP errors to domain-specific errors. Handle network unreachable, timeout, server errors, and parsing errors distinctly.\n\n3. Authentication: Centralized token management. Automatic token refresh on 401. Thread-safe token storage.\n\n4. Testability: Protocol for the network client so tests can inject mock responses. No singleton patterns.\n\n5. Serialization: Generic request/response handling with Codable. Custom date decoding strategies.\n\n6. Interceptors: Request/response middleware for logging, analytics, header injection.\n\n7. Retry logic: Automatic retry for transient failures with exponential backoff.\n\n8. Cancellation: Return cancellable tokens so callers can cancel in-flight requests."
  },
  {
    "topic": "system-design",
    "level": 1,
    "question": "How would you design a push notification handling system in an iOS app?",
    "hint": "Think about registration, receiving, and routing to the correct screen.",
    "answer": "Components:\n\n1. Registration:\n- Request permission (UNUserNotificationCenter.requestAuthorization)\n- Register for remote notifications (UIApplication.registerForRemoteNotifications)\n- Send device token to backend\n- Handle token refresh\n\n2. Receiving:\n- Foreground: UNUserNotificationCenterDelegate.willPresent → decide to show banner or handle silently\n- Background: didReceiveRemoteNotification with completionHandler\n- Terminated: Launch options contain notification payload\n\n3. Routing:\n- Parse notification payload to determine destination (deep link URL or action type)\n- Central NotificationRouter that maps payload → screen\n- Handle the case where user taps notification while app is in any state\n\n4. Silent notifications:\n- content-available: 1 for background data sync\n- Limited to ~2-3 per hour by iOS\n\n5. Rich notifications:\n- Notification Service Extension for modifying content (decrypt, download image)\n- Notification Content Extension for custom UI"
  },
  {
    "topic": "system-design",
    "level": 2,
    "question": "Design a search feature with debounce and autocomplete for an iOS app.",
    "hint": "Think about reducing API calls while keeping the UI responsive.",
    "answer": "Architecture:\n\n1. UI Layer:\n- UISearchBar or .searchable modifier\n- Show results in a list below search bar\n- Loading indicator, empty state, error state\n\n2. Debounce:\n- Don't send API request on every keystroke\n- Wait 300-500ms after user stops typing\n- Combine: textPublisher.debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n- Cancel previous request when new text arrives\n\n3. Local + Remote:\n- First show local results (recent searches, cached results) — instant\n- Then fetch remote results — replace/merge with local\n- Minimum query length (e.g., 3 characters) before hitting API\n\n4. Caching:\n- Cache recent search results by query string\n- LRU cache with TTL\n- Pre-populate cache with popular searches\n\n5. Performance:\n- Throttle rapid API calls\n- Use GET with query params (cacheable by URLCache)\n- Pagination for large result sets\n- Highlight matching text in results"
  },
  {
    "topic": "system-design",
    "level": 2,
    "question": "How would you design an analytics and logging infrastructure for an iOS app?",
    "hint": "Think about event collection, batching, and privacy.",
    "answer": "Design:\n\n1. Event model:\n- Structured events: name, properties dict, timestamp, session ID, user ID\n- Standard properties: app version, OS version, device model, locale\n\n2. Collection:\n- Protocol-based analytics service for multiple providers (Firebase, Mixpanel, custom)\n- Facade pattern: single API, multiple backends\n- AnalyticsService.track(.screenViewed(name: \"Home\"))\n\n3. Batching:\n- Don't send every event immediately — batch and flush\n- Flush triggers: timer (every 30s), batch size (50 events), app backgrounding\n- Persist unsent events to disk (survive crashes)\n\n4. Privacy:\n- Respect ATT (App Tracking Transparency) framework\n- Allow user opt-out\n- Anonymize PII\n- Comply with GDPR/CCPA\n\n5. Logging (debug):\n- os_log with categories and levels\n- Subsystem-based filtering\n- OSLogStore for retrieving logs\n\n6. Crash reporting: Integrate with Sentry/Crashlytics, attach breadcrumbs from analytics events."
  },
  {
    "topic": "system-design",
    "level": 2,
    "question": "How would you design app-wide theming and dark mode support?",
    "hint": "Think about centralized theme management and dynamic color switching.",
    "answer": "Design:\n\n1. Theme model:\n- Define a Theme protocol with colors, fonts, spacing, corner radii\n- Concrete implementations: LightTheme, DarkTheme, CustomTheme\n- Use semantic color names: backgroundColor, primaryText, secondaryText, accent\n\n2. SwiftUI approach:\n- Use Color assets with 'Any Appearance' and 'Dark Appearance' variants\n- @Environment(\\.colorScheme) to detect current mode\n- Custom EnvironmentKey for theme object\n\n3. UIKit approach:\n- UIColor(dynamicProvider:) for colors that adapt automatically\n- Asset catalog with color sets (light/dark variants)\n- traitCollectionDidChange to handle runtime changes\n\n4. Centralized management:\n- ThemeManager observable object\n- Override system theme: UIWindow.overrideUserInterfaceStyle\n- Persist user preference in UserDefaults\n\n5. Considerations:\n- Images: Use SF Symbols (auto-adapt) or provide light/dark variants\n- Status bar, navigation bar appearance\n- Third-party views may need manual theming\n- Launch screen must use Asset Catalog colors"
  },
  {
    "topic": "system-design",
    "level": 3,
    "question": "Design a real-time chat system for an iOS app.",
    "hint": "Think about WebSockets, message persistence, and offline handling.",
    "answer": "Architecture:\n\n1. Transport:\n- WebSocket (URLSessionWebSocketTask) for real-time bidirectional communication\n- Fallback to long-polling if WebSocket unavailable\n- Reconnection logic with exponential backoff\n\n2. Message model:\n- ID (UUID), sender, content, timestamp, status (sending, sent, delivered, read)\n- Support text, images, files (upload separately, send URL in message)\n\n3. Local persistence:\n- Core Data or SwiftData for message history\n- NSFetchedResultsController for efficient list updates\n- Index on conversationId + timestamp for fast queries\n\n4. Sync:\n- On connect: fetch missed messages since last known timestamp\n- Optimistic UI: show message immediately as 'sending', update status on server ack\n- Conflict resolution: server timestamp is source of truth\n\n5. Offline:\n- Queue outgoing messages locally\n- Flush queue when connectivity returns\n- Show pending indicator on unsent messages\n\n6. Performance:\n- Pagination: load latest 50 messages, fetch older on scroll up\n- Image thumbnails inline, full-size on tap\n- Typing indicators via WebSocket events\n- Read receipts batched to reduce traffic"
  },
  {
    "topic": "system-design",
    "level": 3,
    "question": "Design a sync engine for an iOS app that handles conflict resolution.",
    "hint": "Think about local changes, remote changes, and what happens when both modify the same record.",
    "answer": "Sync engine design:\n\n1. Change tracking:\n- Each record has: id, updatedAt, syncStatus (synced, pendingUpload, pendingDelete, conflict)\n- Track local modifications with a dirty flag or changelog table\n\n2. Sync flow:\n- Push: Upload local changes (pendingUpload) to server\n- Pull: Fetch remote changes since lastSyncTimestamp\n- Apply: Merge remote changes into local database\n\n3. Conflict detection:\n- Conflict: local record modified AND remote record modified since last sync\n- Compare updatedAt timestamps or use version numbers\n\n4. Conflict resolution strategies:\n- Last-writer-wins: Higher timestamp wins (simple, may lose data)\n- Server-wins: Always prefer server version\n- Client-wins: Always prefer local version\n- Field-level merge: Merge non-conflicting field changes, flag true conflicts\n- User resolution: Present both versions, let user choose\n\n5. Implementation:\n- Background sync on timer + connectivity change + app foreground\n- Exponential backoff on failure\n- Batch operations for efficiency\n- Persistent sync state (lastSyncTimestamp, pending queue) survives app termination\n\n6. Edge cases: Deleted on server but modified locally, re-created items, cascading deletes."
  },
  {
    "topic": "system-design",
    "level": 3,
    "question": "How would you design a modular iOS application architecture for a team of 20+ developers?",
    "hint": "Think about feature modules, shared code, and independent development.",
    "answer": "Modular architecture:\n\n1. Module types:\n- Feature modules: Self-contained features (Home, Profile, Checkout)\n- Core modules: Shared utilities (Networking, Persistence, Analytics)\n- UI module: Design system, reusable components\n- App module: Composition root, dependency wiring, navigation\n\n2. Package structure (SPM):\n- Each module is a Swift Package with its own tests\n- Clear dependency rules: Features depend on Core, never on each other\n- Module interface (protocol) vs implementation separation\n\n3. Navigation:\n- Coordinator or Router pattern at app level\n- Feature modules expose entry points (views/view controllers)\n- Deep linking maps URLs to feature entry points\n\n4. Team workflow:\n- Each team owns 1-3 feature modules\n- Modules can be built and tested independently\n- Demo apps per module for rapid iteration\n\n5. Benefits:\n- Parallel development without merge conflicts\n- Faster build times (only rebuild changed modules)\n- Clear ownership and boundaries\n- Easier onboarding (new devs learn one module)\n\n6. Pitfalls to avoid: Shared mutable state, circular dependencies, over-abstraction at boundaries."
  },
  {
    "topic": "system-design",
    "level": 4,
    "question": "Design a payment flow for an iOS app that handles StoreKit 2, receipt validation, and edge cases.",
    "hint": "Think about the purchase lifecycle, server-side validation, and interrupted transactions.",
    "answer": "Payment flow design:\n\n1. Product loading:\n- Fetch product IDs from your server (not hardcoded)\n- Product.products(for: ids) to get StoreKit products\n- Display with localized price (displayPrice)\n\n2. Purchase flow:\n- product.purchase() → Transaction.updates for real-time monitoring\n- Verify transaction with Transaction.currentEntitlements\n- Finish transaction only after your server acknowledges\n\n3. Server-side validation (critical):\n- Send signed transaction (JWS) to your server\n- Server verifies with Apple's App Store Server API\n- Server grants entitlement in your database\n- Client receives confirmation, calls transaction.finish()\n\n4. Edge cases:\n- Interrupted purchases (ask-to-buy, authentication failure): Listen to Transaction.updates on app launch\n- Refunds: App Store Server Notifications V2 (REFUND type)\n- Subscription grace period: Check renewalInfo.gracePeriodExpirationDate\n- Family Sharing: Check transaction.ownershipType\n- Sandbox vs production: Different verification endpoints\n\n5. Restore purchases:\n- AppStore.sync() to refresh transactions\n- Iterate Transaction.currentEntitlements\n\n6. Testing: StoreKit Testing in Xcode (local configuration file), sandbox accounts."
  },
  {
    "topic": "system-design",
    "level": 4,
    "question": "Design a plugin/extension system that allows third-party features to be added to your iOS app at runtime.",
    "hint": "Think about protocol-based contracts, dynamic loading, and sandboxing.",
    "answer": "Plugin system design:\n\n1. Plugin contract:\n- Define protocols that plugins must conform to\n- protocol Plugin { var id: String; var name: String; func initialize(); func createView() -> AnyView }\n- Versioned API: PluginAPIv1, PluginAPIv2\n\n2. Discovery & loading:\n- Option A: Embedded frameworks — plugins bundled at build time, loaded via Bundle.load()\n- Option B: App Extensions — separate binary targets, sandboxed by iOS\n- Option C: Configuration-driven — plugins are just different configurations of built-in components\n\n3. Registration:\n- PluginRegistry maintains list of available plugins\n- Plugins register capabilities (can handle file type X, provides screen Y)\n- Dependency resolution: plugins can declare dependencies on other plugins\n\n4. Sandboxing:\n- Plugins communicate through defined interfaces only\n- No direct access to app's internal state\n- Resource limits (memory, CPU time)\n\n5. UI integration:\n- Plugin provides SwiftUI View or UIViewController\n- Host app provides navigation, theming, and common services\n- Slot-based UI: defined extension points where plugins can inject UI\n\n6. Versioning:\n- Semantic versioning for plugin API\n- Graceful degradation if plugin API version mismatch\n- Migration support for plugin data between versions"
  },
  {
    "topic": "system-design",
    "level": 4,
    "question": "How would you design a comprehensive error handling and monitoring system for a production iOS app?",
    "hint": "Think about error categorization, user-facing messages, and observability.",
    "answer": "Error handling system:\n\n1. Error taxonomy:\n- Network errors: timeout, no connection, server error (5xx), client error (4xx)\n- Business logic errors: validation, authorization, insufficient funds\n- System errors: storage full, permission denied, hardware unavailable\n- Unexpected errors: crashes, assertion failures\n\n2. Error model:\n- AppError enum conforming to LocalizedError\n- Categorized by recoverability: retryable, user-actionable, fatal\n- Each error carries: code, user message, debug info, recovery suggestions\n\n3. Presentation:\n- ErrorPresenter service that maps errors to UI (alert, banner, inline)\n- Never show raw technical errors to users\n- Provide clear actions: Retry, Go to Settings, Contact Support\n\n4. Monitoring:\n- Crash reporting (Sentry/Crashlytics) with breadcrumbs\n- Non-fatal error logging with severity levels\n- Custom metrics: error rate per endpoint, error rate per screen\n- MetricKit for system-level diagnostics (hangs, disk writes)\n\n5. Alerting:\n- Server-side dashboards for error rate spikes\n- PagerDuty/Slack alerts for crash rate above threshold\n- Per-version error tracking (detect regressions)\n\n6. Recovery:\n- Automatic retry with backoff for transient errors\n- Circuit breaker pattern for repeatedly failing endpoints\n- Graceful degradation: show cached data when network fails"
  },
  {
    "topic": "system-design",
    "level": 5,
    "question": "Design the architecture for a large-scale iOS app that supports 10 million daily active users, with offline capability, real-time features, and a modular codebase maintained by 50+ engineers.",
    "hint": "Think holistically: architecture, data, networking, team organization, CI/CD, monitoring.",
    "answer": "Comprehensive architecture:\n\n1. App architecture:\n- Micro-features: Each feature is an SPM package with its own views, models, and tests\n- Dependency injection via composition root (no global singletons)\n- Unidirectional data flow within features (TCA or custom Redux-like)\n- Coordinator-based navigation with deep link support\n\n2. Data layer:\n- Offline-first with SwiftData/Core Data per feature module\n- Background sync engine with conflict resolution (vector clocks for multi-device)\n- Encrypted local storage for sensitive data (Keychain + CryptoKit)\n- Cache hierarchy: memory → disk → network\n\n3. Networking:\n- gRPC or GraphQL for efficient data transfer\n- WebSocket for real-time features (chat, live updates)\n- Request coalescing and deduplication\n- Certificate pinning with key rotation support\n- CDN for static assets with delta updates\n\n4. Team organization:\n- Platform team: core modules, CI/CD, build system\n- Feature teams: own their modules end-to-end\n- Design system team: shared UI components\n- Architecture guild: cross-team decisions and standards\n\n5. CI/CD:\n- Selective builds and tests based on dependency graph\n- Automated release trains (weekly releases)\n- Feature flags for gradual rollout (1% → 10% → 100%)\n- Automated rollback on crash rate spike\n\n6. Monitoring:\n- Real-time crash monitoring with automatic JIRA ticket creation\n- Performance budgets per screen (launch time, scroll FPS, memory)\n- A/B testing infrastructure for data-driven decisions\n- Custom MetricKit payloads for production diagnostics\n\n7. Scale considerations:\n- App binary size budget and monitoring\n- Modular on-demand resources (ODR) for large assets\n- Background processing for heavy operations\n- Adaptive quality based on device capability and network"
  },
  {
    "topic": "system-design",
    "level": 5,
    "question": "Design a complete offline-first sync architecture with conflict resolution for a collaborative document editing app on iOS.",
    "hint": "Think about CRDTs, operational transforms, and eventual consistency.",
    "answer": "Collaborative offline-first architecture:\n\n1. Data model:\n- Documents stored locally (SwiftData/SQLite)\n- Each change is an Operation (insert, delete, format) with: id, documentId, userId, timestamp, vectorClock, payload\n- Operations are immutable and append-only\n\n2. Conflict-free approach (CRDTs):\n- Use CRDTs (Conflict-free Replicated Data Types) for automatic merge\n- Text: Use a sequence CRDT like RGA (Replicated Growable Array) or Yjs-style\n- Each character has a unique ID (userId + lamportTimestamp)\n- Concurrent inserts at same position resolve deterministically by comparing IDs\n- Deletes are tombstones (mark deleted, never remove)\n\n3. Sync protocol:\n- Each device maintains a vector clock (map of userId → lastSeenTimestamp)\n- Sync request: send vector clock → server returns all operations the device hasn't seen\n- Bidirectional: push local ops, pull remote ops\n- Causal ordering: apply ops in vector clock order\n\n4. Network layer:\n- WebSocket for real-time sync when online\n- Batch HTTP sync for reconnection (push/pull all pending)\n- Exponential backoff on failure\n- Background sync via BGTaskScheduler\n\n5. Storage:\n- Operations log: append-only table, indexed by documentId + vectorClock\n- Materialized view: current document state (rebuilt from ops or incrementally updated)\n- Periodic compaction: squash old operations into snapshots to bound storage growth\n\n6. Edge cases:\n- Device offline for weeks: large sync payload → paginate operations\n- Conflicting deletes: tombstone + undo support\n- Permission changes while offline: validate ops server-side, reject unauthorized\n- Clock skew: use Lamport timestamps, not wall clock\n\n7. Testing:\n- Property-based tests: random operations on multiple replicas always converge\n- Network simulation: test sync under packet loss, reordering, duplication\n- Stress test: 100+ concurrent editors on same document"
  },
  {
    "topic": "system-design",
    "level": 5,
    "question": "How would you design a testability-first architecture that enables comprehensive testing at all levels for a complex iOS app?",
    "hint": "Think about dependency boundaries, test doubles, and how architecture decisions affect testability.",
    "answer": "Testability-first architecture:\n\n1. Dependency management:\n- All external dependencies behind protocols (NetworkService, StorageService, LocationService)\n- Constructor injection everywhere — no implicit dependencies\n- Environment-based injection in SwiftUI (@Environment)\n- Factory protocols for creating child dependencies\n\n2. Architecture layers (each independently testable):\n- Domain: Pure Swift, no framework imports. Business logic, entities, use cases. Test with plain XCTest, no mocks needed.\n- Data: Repository implementations, API clients, local storage. Test with mock backends.\n- Presentation: ViewModels/Reducers. Test state transitions with mock use cases.\n- UI: SwiftUI Views. Snapshot test with mock ViewModels.\n\n3. Test doubles strategy:\n- Protocols with single implementation → mock in tests\n- Use Sourcery or Swift macros for auto-generating mocks\n- Shared test utilities module with common mocks and fixtures\n- Builder pattern for test data: User.fixture(name: \"Test\")\n\n4. Testing pyramid:\n- Unit tests (70%): Fast, isolated, test logic and state\n- Integration tests (20%): Test module interactions, real DB with in-memory store\n- UI tests (5%): Critical user flows only, use page object pattern\n- Snapshot tests (5%): Design system components, key screens\n\n5. Test infrastructure:\n- Deterministic: Inject Clock protocol instead of Date(), inject Scheduler instead of DispatchQueue\n- No flaky tests: Ban sleep/wait in unit tests, use XCTestExpectation for async\n- Parallel execution: Tests must not share state\n- CI: Run unit tests on every PR, integration on merge, UI tests nightly\n\n6. Contract testing:\n- Define API contracts (OpenAPI/Swagger)\n- Auto-generate mock server from contracts\n- Test client against mock server, test server against same contracts\n- Catch API drift before it reaches production"
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "struct Point {\n    var x: Int\n    var y: Int\n}\n\nvar a = Point(x: 1, y: 2)\nvar b = a\nb.x = 10\nprint(a.x, b.x)",
    "hint": "Think about how structs behave when assigned to a new variable.",
    "answer": "Prints '1 10'. Structs are value types in Swift. When 'b = a' is executed, a full copy of the struct is made. Modifying b.x does not affect a.x because they are independent copies in memory."
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "class Dog {\n    var name: String\n    init(name: String) { self.name = name }\n}\n\nlet dog1 = Dog(name: \"Rex\")\nlet dog2 = dog1\ndog2.name = \"Buddy\"\nprint(dog1.name)",
    "hint": "Think about how classes behave when assigned to a new variable.",
    "answer": "Prints 'Buddy'. Classes are reference types. Both dog1 and dog2 point to the same object in memory. Changing dog2.name also changes dog1.name because they reference the same instance. Note that 'let' on a reference type only prevents reassignment of the reference, not mutation of the object's properties."
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "var name: String? = nil\nif let unwrapped = name {\n    print(unwrapped)\n} else {\n    print(\"No name\")\n}\nname = \"Swift\"\nprint(name!)",
    "hint": "Consider what happens when an optional is nil vs when it has a value.",
    "answer": "Prints 'No name' then 'Swift'. The first if-let fails because name is nil, so the else branch executes. Then name is assigned 'Swift', and force unwrapping with ! extracts the value. Force unwrapping a nil optional would crash, but here it's safe because we just assigned a value."
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "func greet(_ name: String?) {\n    guard let name = name else {\n        print(\"Anonymous\")\n        return\n    }\n    print(\"Hello, \\(name)!\")\n}\n\ngreet(nil)\ngreet(\"Giga\")",
    "hint": "Think about how guard-let handles nil values and when it exits early.",
    "answer": "Prints 'Anonymous' then 'Hello, Giga!'. The first call passes nil, so guard-let fails and the else block executes, printing 'Anonymous' and returning early. The second call passes a valid string, so guard-let succeeds, the unwrapped name is available for the rest of the function, and 'Hello, Giga!' is printed."
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "let numbers = [3, 1, 4, 1, 5]\nvar sum = 0\nfor number in numbers {\n    sum += number\n}\nprint(sum)\nprint(numbers.count)",
    "hint": "Trace the loop accumulation and remember what .count returns.",
    "answer": "Prints '14' then '5'. The for loop adds each element: 3+1+4+1+5 = 14. The .count property returns the number of elements in the array, which is 5. The original array is not modified by the loop."
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "let closure = { (a: Int, b: Int) -> Int in\n    return a * b\n}\nlet result = closure(3, 4)\nprint(result)\n\nlet add: (Int, Int) -> Int = { $0 + $1 }\nprint(add(5, 6))",
    "hint": "Consider the two different closure syntaxes and what they return.",
    "answer": "Prints '12' then '11'. The first closure explicitly names parameters a and b and returns their product (3 * 4 = 12). The second closure uses shorthand argument names $0 and $1, and returns their sum (5 + 6 = 11). Both are valid closure syntaxes in Swift."
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "let age = 25\nlet message = \"I am \\(age) years old and in \\(age >= 18 ? \"adult\" : \"minor\") category\"\nprint(message)",
    "hint": "String interpolation can contain expressions, not just variables.",
    "answer": "Prints 'I am 25 years old and in adult category'. String interpolation with \\() can evaluate any expression, including the ternary operator. Since age (25) >= 18 is true, the ternary evaluates to 'adult'."
  },
  {
    "topic": "code-challenge",
    "level": 0,
    "question": "What will be printed?",
    "code": "var fruits = [\"Apple\", \"Banana\", \"Cherry\"]\nfruits.append(\"Date\")\nfruits.insert(\"Avocado\", at: 1)\nfruits.remove(at: 0)\nprint(fruits.first ?? \"Empty\")\nprint(fruits.count)",
    "hint": "Trace each mutation step by step and track the array contents.",
    "answer": "Prints 'Avocado' then '4'. Starting with [Apple, Banana, Cherry], append adds Date: [Apple, Banana, Cherry, Date]. Insert at index 1 gives [Apple, Avocado, Banana, Cherry, Date]. Remove at index 0 removes Apple: [Avocado, Banana, Cherry, Date]. So .first is 'Avocado' and .count is 4."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "struct Address {\n    var city: String?\n}\nstruct Person {\n    var address: Address?\n}\n\nlet person = Person(address: Address(city: \"Tbilisi\"))\nlet city = person.address?.city?.uppercased()\nprint(city ?? \"Unknown\")\n\nlet nobody = Person(address: nil)\nprint(nobody.address?.city?.uppercased() ?? \"Unknown\")",
    "hint": "Optional chaining short-circuits at the first nil in the chain.",
    "answer": "Prints 'TBILISI' then 'Unknown'. For person, address is non-nil and city is non-nil, so the entire chain succeeds and uppercased() returns 'TBILISI'. For nobody, address is nil, so the chain short-circuits immediately — city and uppercased() are never evaluated — returning nil, which the ?? operator replaces with 'Unknown'."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "let score: Int? = nil\nlet displayScore = score ?? 0\nprint(type(of: displayScore))\nprint(displayScore)\n\nlet name: String? = \"Swift\"\nlet greeting = \"Hello, \" + (name ?? \"World\")\nprint(greeting)",
    "hint": "The nil coalescing operator unwraps the optional or provides a default, and the result type is non-optional.",
    "answer": "Prints 'Int', '0', then 'Hello, Swift'. The nil coalescing operator ?? returns the unwrapped value if non-nil, or the default. Since score is nil, displayScore is 0 of type Int (not Int?). For name, since it has a value 'Swift', the default 'World' is ignored. The result of ?? is always the non-optional type."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "enum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qr(String)\n}\n\nlet code = Barcode.qr(\"ABCDEF\")\n\nswitch code {\ncase .upc(let a, _, _, let d):\n    print(\"UPC: \\(a)-\\(d)\")\ncase .qr(let value):\n    print(\"QR: \\(value)\")\n}",
    "hint": "Think about how associated values are extracted in switch statements.",
    "answer": "Prints 'QR: ABCDEF'. The enum Barcode has two cases with associated values. Since code is .qr(\"ABCDEF\"), the second case matches and extracts the associated String value into 'value'. The .upc case demonstrates partial binding with underscores to ignore certain associated values, but it doesn't match here."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nlet result = numbers\n    .filter { $0 % 2 == 0 }\n    .map { $0 * $0 }\n    .reduce(0, +)\n\nprint(result)",
    "hint": "Trace each transformation: filter, then map, then reduce.",
    "answer": "Prints '220'. First, filter keeps even numbers: [2, 4, 6, 8, 10]. Then map squares each: [4, 16, 36, 64, 100]. Finally, reduce sums them: 4 + 16 + 36 + 64 + 100 = 220. These higher-order functions chain together to form a pipeline, each operating on the output of the previous one."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "struct Counter {\n    var count = 0\n\n    mutating func increment() {\n        count += 1\n    }\n\n    func display() -> String {\n        return \"Count: \\(count)\"\n    }\n}\n\nvar c = Counter()\nc.increment()\nc.increment()\nc.increment()\nprint(c.display())\n\nlet fixed = Counter()\n// fixed.increment() // Would this compile?",
    "hint": "Think about the 'mutating' keyword and why it matters for value types declared with let.",
    "answer": "Prints 'Count: 3'. The mutating keyword allows a method to modify properties of a value type. After three calls to increment(), count is 3. The commented-out line would NOT compile because 'fixed' is declared with let, making the struct immutable — you cannot call mutating methods on a let constant of a value type."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "protocol Describable {\n    var description: String { get }\n}\n\nextension Describable {\n    var description: String { \"I am Describable\" }\n}\n\nstruct Cat: Describable {\n    var description: String { \"I am a Cat\" }\n}\n\nstruct Robot: Describable {}\n\nlet cat: Describable = Cat()\nlet robot: Describable = Robot()\nprint(cat.description)\nprint(robot.description)",
    "hint": "Consider which implementation is used when the type provides its own vs using the default.",
    "answer": "Prints 'I am a Cat' then 'I am Describable'. Since 'description' is declared in the protocol itself (not just in the extension), dynamic dispatch is used. Cat provides its own implementation which overrides the default, so 'I am a Cat' is printed. Robot doesn't provide one, so it falls back to the protocol extension's default implementation."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "enum Direction: String, CaseIterable {\n    case north = \"N\"\n    case south = \"S\"\n    case east = \"E\"\n    case west = \"W\"\n}\n\nprint(Direction.north.rawValue)\nprint(Direction(rawValue: \"S\")!)\nprint(Direction(rawValue: \"X\") ?? .north)\nprint(Direction.allCases.count)",
    "hint": "Consider raw values, failable initializers, and CaseIterable.",
    "answer": "Prints 'N', 'south', 'north', then '4'. Direction.north.rawValue is the associated raw string 'N'. Initializing with rawValue 'S' returns .south (force-unwrapped here). Initializing with 'X' returns nil since no case matches, so ?? provides .north as default. CaseIterable provides allCases which contains all 4 enum cases."
  },
  {
    "topic": "code-challenge",
    "level": 1,
    "question": "What will be printed?",
    "code": "let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet flattened = matrix.flatMap { $0 }\nlet compact: [Int] = [nil, 1, nil, 2, 3, nil].compactMap { $0 }\nprint(flattened)\nprint(compact)",
    "hint": "flatMap flattens nested arrays, compactMap removes nils.",
    "answer": "Prints '[1, 2, 3, 4, 5, 6, 7, 8, 9]' then '[1, 2, 3]'. flatMap on an array of arrays concatenates the inner arrays into a single flat array. compactMap applies a transform and filters out nil results — here the transform is identity { $0 }, so it simply removes the nil values from the array."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "func makeCounter() -> () -> Int {\n    var count = 0\n    return {\n        count += 1\n        return count\n    }\n}\n\nlet counter1 = makeCounter()\nlet counter2 = makeCounter()\nprint(counter1())\nprint(counter1())\nprint(counter2())\nprint(counter1())",
    "hint": "Each call to makeCounter creates a new captured variable. Closures capture by reference.",
    "answer": "Prints '1', '2', '1', '3'. Each call to makeCounter() creates a new 'count' variable. counter1 and counter2 each capture their own independent count. Closures capture variables by reference, so each call to counter1() increments its own captured count. counter2 has its own count starting at 0, so counter2() returns 1. Then counter1() returns 3 because its count was already at 2."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What is wrong with this code?",
    "code": "class ViewController {\n    var onComplete: (() -> Void)?\n    var name = \"Main\"\n\n    func setup() {\n        onComplete = {\n            print(\"Done from \\(self.name)\")\n        }\n    }\n\n    deinit {\n        print(\"ViewController deallocated\")\n    }\n}",
    "hint": "Think about what self means inside the closure and who owns what.",
    "answer": "This code creates a retain cycle. The ViewController owns onComplete (strong reference), and the closure captures self strongly. This creates a cycle: ViewController -> onComplete -> self (ViewController). Neither can be deallocated. The fix is to use a capture list: onComplete = { [weak self] in print(\"Done from \\(self?.name ?? \"\")\" ) }. Using [weak self] breaks the cycle by not incrementing the reference count."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "func printType<T>(_ value: T) {\n    print(type(of: value))\n}\n\nprintType(42)\nprintType(3.14)\nprintType(\"Hello\")\nprintType([1, 2, 3])\nprintType((1, \"two\"))",
    "hint": "Swift infers generic types at the call site.",
    "answer": "Prints 'Int', 'Double', 'String', 'Array<Int>', '(Int, String)'. Swift's type inference determines T at each call site. Integer literals default to Int, floating-point literals to Double. The array is inferred as Array<Int>, and the tuple's type includes both element types. Generics are resolved at compile time through type specialization."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "protocol Greetable {\n    func greet() -> String\n}\n\nextension Greetable {\n    func greet() -> String { \"Hello\" }\n    func farewell() -> String { \"Goodbye\" }\n}\n\nstruct English: Greetable {\n    func greet() -> String { \"Hi\" }\n    func farewell() -> String { \"Bye\" }\n}\n\nlet a: English = English()\nlet b: Greetable = English()\nprint(a.greet(), a.farewell())\nprint(b.greet(), b.farewell())",
    "hint": "Check whether each method is declared in the protocol or only in the extension.",
    "answer": "Prints 'Hi Bye' then 'Hi Goodbye'. greet() is declared in the protocol, so it uses dynamic dispatch — both a and b call English's implementation. farewell() is only defined in the extension (not in the protocol), so it uses static dispatch. When the type is English, the compiler sees English's farewell(). When the type is Greetable, the compiler uses the extension's farewell(). This is the protocol witness table vs static dispatch distinction."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "class Logger {\n    lazy var timestamp: String = {\n        print(\"Computing timestamp\")\n        return \"2024-01-01\"\n    }()\n\n    init() {\n        print(\"Logger initialized\")\n    }\n}\n\nlet logger = Logger()\nprint(\"Before access\")\nprint(logger.timestamp)\nprint(logger.timestamp)",
    "hint": "Lazy properties are initialized on first access, not during init.",
    "answer": "Prints 'Logger initialized', 'Before access', 'Computing timestamp', '2024-01-01', '2024-01-01'. The lazy property's closure is not executed during init. It runs only on the first access to timestamp. On the second access, the cached value is returned without re-executing the closure. Note: lazy properties require 'var' and the containing instance must also be 'var' (here 'let' works because Logger is a class, a reference type)."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "class Score {\n    var value: Int = 0 {\n        willSet {\n            print(\"Will change from \\(value) to \\(newValue)\")\n        }\n        didSet {\n            print(\"Changed from \\(oldValue) to \\(value)\")\n            if value > 100 { value = 100 }\n        }\n    }\n}\n\nlet s = Score()\ns.value = 50\ns.value = 150",
    "hint": "didSet can modify the property, but does that trigger willSet/didSet again?",
    "answer": "Prints 'Will change from 0 to 50', 'Changed from 0 to 50', 'Will change from 50 to 150', 'Changed from 50 to 150'. When value is set to 50, willSet fires then didSet fires. When set to 150, willSet fires with newValue 150, then didSet fires and clamps value to 100. Importantly, setting value inside didSet does NOT re-trigger willSet/didSet — Swift prevents infinite recursion. The final value is 100."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "struct Secret: Codable {\n    var key: String\n    private var _value: String\n\n    var value: String { _value }\n\n    enum CodingKeys: String, CodingKey {\n        case key\n        case _value = \"secret_value\"\n    }\n}\n\nlet json = #\"{\"key\": \"API\", \"secret_value\": \"12345\"}\"#\nlet decoded = try! JSONDecoder().decode(Secret.self, from: json.data(using: .utf8)!)\nprint(decoded.key)\nprint(decoded.value)",
    "hint": "CodingKeys map between JSON keys and Swift property names.",
    "answer": "Prints 'API' then '12345'. CodingKeys allows custom mapping between JSON field names and Swift property names. The case '_value = \"secret_value\"' maps the JSON key 'secret_value' to the Swift property '_value'. The computed property 'value' then exposes _value read-only. This pattern is common for handling snake_case JSON keys or hiding internal property names."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "public struct Library {\n    public private(set) var books: [String] = []\n    internal var location: String = \"Main\"\n    fileprivate var budget: Double = 1000.0\n    private var secretCode: Int = 42\n\n    public mutating func addBook(_ book: String) {\n        books.append(book)\n    }\n}\n\nvar lib = Library()\nlib.addBook(\"Swift\")\nprint(lib.books)\n// lib.books.append(\"Kotlin\") // Does this compile?",
    "hint": "The setter has a different access level than the getter.",
    "answer": "Prints '[\"Swift\"]'. The 'public private(set)' modifier means books can be read publicly but only set privately (within the struct). So lib.books is readable, but lib.books.append('Kotlin') won't compile because append mutates the array, requiring write access. You must use the addBook method instead, which has internal access to the private setter."
  },
  {
    "topic": "code-challenge",
    "level": 2,
    "question": "What will be printed?",
    "code": "var x = 10\nlet closure1 = { [x] in\n    print(\"closure1: \\(x)\")\n}\nlet closure2 = {\n    print(\"closure2: \\(x)\")\n}\nx = 20\nclosure1()\nclosure2()",
    "hint": "Compare a capture list [x] versus a direct capture.",
    "answer": "Prints 'closure1: 10' then 'closure2: 20'. With the capture list [x], the value of x is copied at the time the closure is created (value semantics capture), so it captures 10. Without a capture list, closure2 captures x by reference, so it sees the current value 20 when executed. Capture lists create an independent copy for value types."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "actor BankAccount {\n    var balance: Int = 100\n\n    func withdraw(_ amount: Int) -> Bool {\n        guard balance >= amount else { return false }\n        balance -= amount\n        return true\n    }\n\n    nonisolated func accountType() -> String {\n        return \"Savings\"\n    }\n}\n\nlet account = BankAccount()\nprint(account.accountType())\n// print(account.balance) // Does this compile outside async context?",
    "hint": "Actor properties are isolated by default. What about nonisolated methods?",
    "answer": "Prints 'Savings'. The nonisolated method accountType() can be called synchronously from anywhere because it doesn't access any actor-isolated state. The commented line would NOT compile outside an async context because 'balance' is actor-isolated — you'd need 'await account.balance' inside an async function. Actor isolation ensures only one task accesses mutable state at a time."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed? (Assume this runs in an async context)",
    "code": "func fetchValue() async -> String {\n    try? await Task.sleep(nanoseconds: 100_000_000)\n    return \"fetched\"\n}\n\nfunc demo() async {\n    async let a = fetchValue()\n    async let b = fetchValue()\n    let results = await [a, b]\n    print(results)\n\n    let c = await fetchValue()\n    let d = await fetchValue()\n    print(\"sequential done\")\n}",
    "hint": "async let starts tasks concurrently. Sequential awaits do not.",
    "answer": "Prints '[\"fetched\", \"fetched\"]' then 'sequential done'. The async let bindings for a and b launch both fetchValue() calls concurrently — they run in parallel and complete in roughly 0.1 seconds total. The sequential calls c and d each await before starting the next, taking roughly 0.2 seconds total. async let is Swift's structured concurrency primitive for running tasks in parallel."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "class Animal {\n    func speak() -> String { \"...\" }\n}\n\nclass Dog: Animal {\n    override func speak() -> String { \"Woof\" }\n}\n\nclass Cat: Animal {\n    override func speak() -> String { \"Meow\" }\n}\n\nlet animals: [Animal] = [Dog(), Cat(), Dog()]\nfor animal in animals {\n    print(animal.speak())\n}",
    "hint": "Class methods use dynamic dispatch via the vtable.",
    "answer": "Prints 'Woof', 'Meow', 'Woof'. Even though the array type is [Animal], the actual speak() implementation called depends on the runtime type of each object. This is dynamic dispatch via the class vtable. The 'override' keyword indicates the subclass is providing its own implementation, and the virtual method table ensures the correct version is called based on the actual instance type."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "protocol Shape {\n    func area() -> Double\n}\n\nextension Shape {\n    func area() -> Double { 0.0 }\n    func description() -> String { \"Shape with area \\(area())\" }\n}\n\nstruct Circle: Shape {\n    var radius: Double\n    func area() -> Double { .pi * radius * radius }\n    func description() -> String { \"Circle with area \\(area())\" }\n}\n\nlet shape: Shape = Circle(radius: 1)\nprint(shape.area())\nprint(shape.description())",
    "hint": "area() is in the protocol, description() is only in the extension.",
    "answer": "Prints '3.141592653589793' then 'Shape with area 3.141592653589793'. area() is declared in the protocol so it uses dynamic dispatch — Circle's area() is called correctly through the protocol witness table. description() is NOT in the protocol, only in the extension, so it uses static dispatch based on the compile-time type (Shape), calling the extension's version. However, inside that extension method, area() still dispatches dynamically to Circle's implementation."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "print(Int.self)\nprint(type(of: Int.self))\n\nlet metatype: String.Type = String.self\nlet instance = metatype.init(\"Hello\")\nprint(instance)\n\nfunc create<T: LosslessStringConvertible>(_ type: T.Type, from string: String) -> T? {\n    return T(string)\n}\nprint(create(Int.self, from: \"42\") ?? 0)",
    "hint": "Metatypes represent the type itself as a value. .self accesses the metatype.",
    "answer": "Prints 'Int', 'Int.Type', 'Hello', '42'. Int.self is the metatype value of Int. type(of: Int.self) returns Int.Type, which is the metatype type. You can call initializers on metatype values, so String.self.init(\"Hello\") creates a String. The create function accepts a metatype parameter to know which type to instantiate, enabling generic factory patterns."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "@dynamicMemberLookup\nstruct Config {\n    private var storage: [String: String] = [:]\n\n    subscript(dynamicMember key: String) -> String? {\n        get { storage[key] }\n        set { storage[key] = newValue }\n    }\n}\n\nvar config = Config()\nconfig.apiKey = \"abc123\"\nconfig.baseURL = \"https://api.example.com\"\nprint(config.apiKey ?? \"none\")\nprint(config.missing ?? \"default\")",
    "hint": "dynamicMemberLookup translates dot syntax into subscript calls.",
    "answer": "Prints 'abc123' then 'default'. @dynamicMemberLookup allows accessing properties that don't exist as declared members — the compiler translates config.apiKey into config[dynamicMember: \"apiKey\"]. The set subscript stores values in the dictionary, and get retrieves them. config.missing returns nil since no value was stored for that key, so the ?? operator provides 'default'."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "struct User {\n    var name: String\n    var age: Int\n}\n\nlet nameKeyPath = \\User.name\nlet ageKeyPath = \\User.age\n\nvar user = User(name: \"Alice\", age: 30)\nprint(user[keyPath: nameKeyPath])\n\nuser[keyPath: ageKeyPath] = 31\nprint(user[keyPath: ageKeyPath])\n\nlet users = [User(name: \"Bob\", age: 25), User(name: \"Eve\", age: 35)]\nlet names = users.map(\\.name)\nprint(names)",
    "hint": "Key paths are type-safe references to properties that can be used for reading and writing.",
    "answer": "Prints 'Alice', '31', '[\"Bob\", \"Eve\"]'. Key paths like \\User.name create a WritableKeyPath<User, String> that can be used to read or write properties. The subscript syntax user[keyPath:] accesses the property. In the map call, \\.name is shorthand for \\User.name — Swift infers the root type. Key paths enable powerful abstractions for property access without closures."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "@resultBuilder\nstruct StringBuilder {\n    static func buildBlock(_ components: String...) -> String {\n        components.joined(separator: \" \")\n    }\n    static func buildOptional(_ component: String?) -> String {\n        component ?? \"\"\n    }\n    static func buildEither(first component: String) -> String {\n        component\n    }\n    static func buildEither(second component: String) -> String {\n        component\n    }\n}\n\nfunc buildGreeting(@StringBuilder content: () -> String) -> String {\n    content()\n}\n\nlet showTitle = true\nlet result = buildGreeting {\n    \"Hello\"\n    if showTitle {\n        \"Dr.\"\n    }\n    \"World\"\n}\nprint(result)",
    "hint": "Result builders transform the body of a closure using their static build methods.",
    "answer": "Prints 'Hello Dr. World'. The @resultBuilder transforms the closure body. Each string expression becomes a component passed to buildBlock. The if statement is handled by buildEither (first branch since showTitle is true). buildBlock joins all components with spaces. Result builders power SwiftUI's ViewBuilder and enable DSL-like syntax in Swift."
  },
  {
    "topic": "code-challenge",
    "level": 3,
    "question": "What will be printed?",
    "code": "import Combine\n\nlet publisher = [1, 2, 3, 4, 5].publisher\nvar results: [String] = []\n\nlet cancellable = publisher\n    .filter { $0 % 2 == 0 }\n    .map { \"Value: \\($0)\" }\n    .sink { results.append($0) }\n\nprint(results)",
    "hint": "Combine publishers from arrays emit synchronously.",
    "answer": "Prints '[\"Value: 2\", \"Value: 4\"]'. The array publisher emits each element synchronously. filter keeps only even numbers (2, 4), map transforms them to strings. sink collects them into results. Since array publishers are synchronous, all values are processed by the time the print statement executes. This Combine chain demonstrates the publisher-operator-subscriber pattern."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What potential issue exists in this code?",
    "code": "actor Counter {\n    var value = 0\n\n    func increment() async {\n        let current = value\n        try? await Task.sleep(nanoseconds: 1_000_000)\n        value = current + 1\n    }\n}\n\nlet counter = Counter()\nawait withTaskGroup(of: Void.self) { group in\n    for _ in 0..<100 {\n        group.addTask {\n            await counter.increment()\n        }\n    }\n}\nprint(await counter.value)",
    "hint": "Consider what happens to actor isolation across suspension points.",
    "answer": "The final value will likely be 1, not 100. This is actor reentrancy. When increment() hits the await (Task.sleep), the actor suspends and allows other tasks to run. Each task reads value (which is still 0 for most of them since they all read before any write completes), sleeps, then writes current + 1 = 0 + 1 = 1. While actors prevent data races, they don't prevent logical races across suspension points. The fix is to avoid reading state before a suspension point and writing it after, or to perform the entire read-modify-write atomically without intervening awaits."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What is wrong with this code under strict concurrency checking?",
    "code": "class UserCache {\n    var users: [String: String] = [:]\n\n    func addUser(id: String, name: String) {\n        users[id] = name\n    }\n}\n\nactor UserService {\n    let cache = UserCache()\n\n    func registerUser(id: String, name: String) {\n        cache.addUser(id: id, name: name)\n    }\n}\n\nlet service = UserService()\nawait service.registerUser(id: \"1\", name: \"Alice\")",
    "hint": "Think about whether UserCache is safe to use across concurrency domains.",
    "answer": "UserCache is a non-Sendable class being stored in an actor. While the actor serializes access to its own state, UserCache is a mutable reference type. If a reference to cache ever escapes the actor (e.g., returned from a method), it could be mutated from outside the actor's serialized context. Under strict concurrency checking (Swift 6), the compiler would flag UserCache as not conforming to Sendable. The fix is to either make UserCache a struct, mark it @unchecked Sendable with manual synchronization, make it an actor itself, or ensure it conforms to Sendable by making it immutable."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What will be printed?",
    "code": "@propertyWrapper\nstruct Clamped<Value: Comparable> {\n    private var value: Value\n    private let range: ClosedRange<Value>\n\n    var wrappedValue: Value {\n        get { value }\n        set { value = min(max(newValue, range.lowerBound), range.upperBound) }\n    }\n\n    var projectedValue: ClosedRange<Value> { range }\n\n    init(wrappedValue: Value, _ range: ClosedRange<Value>) {\n        self.range = range\n        self.value = min(max(wrappedValue, range.lowerBound), range.upperBound)\n    }\n}\n\nstruct Player {\n    @Clamped(0...100) var health: Int = 150\n    @Clamped(0...10) var level: Int = 1\n}\n\nvar player = Player()\nprint(player.health)\nplayer.health = -50\nprint(player.health)\nprint(player.$health)",
    "hint": "The property wrapper clamps values to the range on both init and set. The projected value is accessed with $.",
    "answer": "Prints '100', '0', '0...100'. On initialization, health = 150 is clamped to the range 0...100, resulting in 100. Setting health to -50 clamps it to 0 (the lower bound). The projected value ($health) exposes the range itself (0...100). Property wrappers encapsulate get/set logic, wrappedValue is the main value, and projectedValue provides additional information accessed via the $ prefix."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What will be printed?",
    "code": "protocol Drawable {\n    func draw() -> String\n}\n\nstruct Circle: Drawable {\n    func draw() -> String { \"Circle\" }\n}\n\nstruct Square: Drawable {\n    func draw() -> String { \"Square\" }\n}\n\nfunc makeShape(round: Bool) -> some Drawable {\n    if round {\n        return Circle()\n    } else {\n        return Circle() // NOT Square()\n    }\n}\n\n// func badShape(round: Bool) -> some Drawable {\n//     if round { return Circle() }\n//     else { return Square() } // Would this compile?\n// }\n\nlet shape = makeShape(round: true)\nprint(shape.draw())",
    "hint": "Opaque return types (some) require all return paths to return the same concrete type.",
    "answer": "Prints 'Circle'. The function makeShape returns 'some Drawable', an opaque return type. This means the function hides the concrete type but guarantees it's always the SAME concrete type from all return paths. Both branches return Circle, so this compiles. The commented-out badShape would NOT compile because it returns Circle in one branch and Square in another — opaque types require a single underlying concrete type. This is different from 'any Drawable' which can return different types."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What will be printed?",
    "code": "protocol Animal {\n    associatedtype Food\n    func eat(_ food: Food)\n}\n\nstruct Grass {}\nstruct Fish {}\n\nstruct Cow: Animal {\n    func eat(_ food: Grass) { print(\"Cow eats grass\") }\n}\n\nstruct Cat: Animal {\n    func eat(_ food: Fish) { print(\"Cat eats fish\") }\n}\n\nfunc feedAll(_ animals: [any Animal]) {\n    for animal in animals {\n        print(type(of: animal))\n    }\n}\n\nlet animals: [any Animal] = [Cow(), Cat()]\nfeedAll(animals)",
    "hint": "Existential types (any Protocol) allow heterogeneous collections of protocols with associated types.",
    "answer": "Prints 'Cow' then 'Cat'. The 'any Animal' existential type (introduced in Swift 5.7) allows creating heterogeneous arrays of types conforming to protocols with associated types. Without 'any', you couldn't put Cow and Cat in the same array because they have different associated Food types. Note that you can't call animal.eat() inside feedAll because the compiler doesn't know the concrete Food type. Type erasure with 'any' enables collection storage at the cost of some type information."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What potential issue exists in this code?",
    "code": "@MainActor\nclass ViewModel {\n    var data: [String] = []\n\n    func loadData() {\n        data = [\"Loading...\"]\n        Task {\n            let result = await fetchFromNetwork()\n            self.data = result\n        }\n    }\n\n    func fetchFromNetwork() async -> [String] {\n        try? await Task.sleep(nanoseconds: 1_000_000_000)\n        return [\"Item 1\", \"Item 2\"]\n    }\n}",
    "hint": "Think about what thread loadData() must be called on and whether the Task inherits the actor context.",
    "answer": "The code works correctly but has a subtle design consideration. Since ViewModel is @MainActor, all its methods including loadData() must be called from the main actor. The Task {} created inside inherits the @MainActor context, so self.data = result also runs on the main actor — this is correct for UI updates. However, fetchFromNetwork() also runs on the main actor (since it's a method on a @MainActor class), which means the 1-second sleep blocks the main actor from processing other tasks. For actual network calls, the work should be moved to a nonisolated function or use Task.detached to avoid blocking the main actor's executor."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What will be printed?",
    "code": "struct AnyAnimal {\n    private let _speak: () -> String\n    private let _type: () -> String\n\n    init<A: CustomStringConvertible>(_ animal: A, speak: @escaping () -> String) {\n        _speak = speak\n        _type = { String(describing: type(of: animal)) }\n    }\n\n    func speak() -> String { _speak() }\n    func animalType() -> String { _type() }\n}\n\nlet dog = AnyAnimal(\"Dog\") { \"Woof\" }\nlet cat = AnyAnimal(\"Cat\") { \"Meow\" }\nlet animals = [dog, cat]\nfor a in animals {\n    print(\"\\(a.animalType()): \\(a.speak())\")\n}",
    "hint": "This is a manual type erasure pattern — closures capture the concrete type's behavior.",
    "answer": "Prints 'String: Woof' then 'String: Meow'. This demonstrates manual type erasure. AnyAnimal wraps different types behind a uniform interface using closures to capture behavior. The _speak closure stores the speak behavior, and _type captures the concrete type. Note that animalType() returns 'String' because the init parameter is the string literal 'Dog'/'Cat' (type String), not a custom Dog/Cat type. Type erasure is used when you need a concrete type that wraps any conforming type — similar to how AnyPublisher works in Combine."
  },
  {
    "topic": "code-challenge",
    "level": 4,
    "question": "What will be printed?",
    "code": "func processStream() async {\n    let stream = AsyncStream<Int> { continuation in\n        for i in 1...3 {\n            continuation.yield(i)\n        }\n        continuation.finish()\n    }\n\n    var collected: [Int] = []\n    for await value in stream {\n        collected.append(value)\n    }\n    print(collected)\n\n    var secondPass: [Int] = []\n    for await value in stream {\n        secondPass.append(value)\n    }\n    print(secondPass)\n}",
    "hint": "Think about whether an AsyncStream can be iterated more than once.",
    "answer": "Prints '[1, 2, 3]' then '[]'. AsyncStream conforms to AsyncSequence but can only be iterated ONCE. The first for-await loop consumes all values (1, 2, 3). The second loop immediately finishes because the stream is already exhausted — it has no values left to yield. This is different from regular sequences like arrays which can be iterated multiple times. AsyncStream is a unicast, single-consumer construct."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What will be printed? (Assume this runs in an async context)",
    "code": "func demo() async {\n    let result = await withTaskGroup(of: Int.self) { group in\n        group.addTask { 1 }\n        group.addTask { 2 }\n        group.addTask { 3 }\n\n        var sum = 0\n        group.cancelAll()\n\n        for await value in group {\n            sum += value\n        }\n        return sum\n    }\n    print(result)\n}",
    "hint": "Does cancelAll() prevent already-added tasks from returning results?",
    "answer": "Prints a value between 0 and 6 (most likely 6). cancelAll() sets the cancellation flag on child tasks, but it does NOT prevent tasks from completing or discard their results. Since these tasks are trivial (just return an integer) and were likely already completed by the time cancelAll() is called, they still produce results. Cancellation in Swift is cooperative — tasks must check Task.isCancelled or call Task.checkCancellation() to actually stop. The for-await loop still collects all returned values. If the tasks had checked for cancellation, they could have thrown or returned early."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What will be printed?",
    "code": "func structuredDemo() async throws {\n    try await withThrowingTaskGroup(of: String.self) { group in\n        group.addTask {\n            try await Task.sleep(nanoseconds: 2_000_000_000)\n            print(\"Task 1 finished\")\n            return \"A\"\n        }\n        group.addTask {\n            try await Task.sleep(nanoseconds: 100_000_000)\n            throw CancellationError()\n        }\n        group.addTask {\n            try await Task.sleep(nanoseconds: 500_000_000)\n            print(\"Task 3 finished\")\n            return \"C\"\n        }\n\n        for try await value in group {\n            print(value)\n        }\n    }\n    print(\"Done\")\n}",
    "hint": "What happens to sibling tasks when one throws in a ThrowingTaskGroup?",
    "answer": "Task 2 throws after ~0.1 seconds. When 'for try await' encounters the thrown error, Swift's structured concurrency automatically cancels all remaining child tasks in the group. Task 1 and Task 3 receive cancellation (their Task.sleep will throw CancellationError), so 'Task 1 finished' and 'Task 3 finished' are NOT printed. The error propagates out of withThrowingTaskGroup, so 'Done' is also NOT printed. This demonstrates structured concurrency's lifetime guarantee: when a group scope exits (normally or via error), all child tasks are cancelled and awaited."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What will be printed?",
    "code": "final class Box<T> {\n    private var _value: T\n    private var _isUnique: Bool {\n        mutating get {\n            isKnownUniquelyReferenced(&self) // Hypothetical\n            return true\n        }\n    }\n\n    var value: T {\n        get { _value }\n        set { _value = newValue }\n    }\n\n    init(_ value: T) { _value = value }\n}\n\nstruct COWArray<Element> {\n    private var storage: Box<[Element]>\n\n    init(_ elements: [Element]) {\n        storage = Box(elements)\n    }\n\n    var elements: [Element] {\n        get { storage.value }\n        set {\n            if !isKnownUniquelyReferenced(&storage) {\n                storage = Box(newValue)\n            } else {\n                storage.value = newValue\n            }\n        }\n    }\n}\n\nvar a = COWArray([1, 2, 3])\nvar b = a\nprint(a.elements === b.elements as AnyObject?) // Conceptual\nb.elements = [4, 5, 6]\nprint(a.elements)\nprint(b.elements)",
    "hint": "isKnownUniquelyReferenced checks if the reference is uniquely held. Copy only happens on mutation.",
    "answer": "Prints '[1, 2, 3]' then '[4, 5, 6]'. This demonstrates Copy-on-Write implementation. When 'b = a', both share the same Box storage (no copy yet). When b.elements is set, isKnownUniquelyReferenced(&storage) returns false because both a and b reference the same Box. So a new Box is created for b with the new data. a's storage remains unchanged. This is how Swift's standard library collections (Array, Dictionary, String) implement COW — they use a reference-counted buffer internally and only copy on mutation when the buffer is shared. The key function isKnownUniquelyReferenced only works with Swift class instances (not Obj-C classes)."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What will be printed?",
    "code": "class Base {\n    func method() { print(\"Base\") }\n    @objc dynamic func dynamicMethod() { print(\"Base dynamic\") }\n}\n\nclass Derived: Base {\n    override func method() { print(\"Derived\") }\n    override func dynamicMethod() { print(\"Derived dynamic\") }\n}\n\nextension Base {\n    func extensionMethod() { print(\"Base extension\") }\n    @objc func objcExtension() { print(\"Base objc ext\") }\n}\n\nextension Derived {\n    override func objcExtension() { print(\"Derived objc ext\") }\n}\n\nlet obj: Base = Derived()\nobj.method()\nobj.dynamicMethod()\nobj.extensionMethod()\nobj.objcExtension()",
    "hint": "Consider vtable dispatch, message dispatch, and static dispatch in extensions.",
    "answer": "Prints 'Derived', 'Derived dynamic', 'Base extension', 'Derived objc ext'. Regular method() uses vtable dispatch — Derived's override is called. dynamicMethod() uses Objective-C message dispatch (due to @objc dynamic), so Derived's override is called. extensionMethod() in a class extension uses static dispatch — the compile-time type is Base, so Base's version is called. objcExtension() uses @objc which enables Objective-C message dispatch, allowing the override in Derived's extension to work. This illustrates Swift's three dispatch mechanisms: static (extensions), vtable (class methods), and message (objc dynamic)."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What will be printed?",
    "code": "struct SmallStruct {\n    let a: Int8\n    let b: Int8\n}\n\nstruct PaddedStruct {\n    let a: Int8\n    let b: Int64\n    let c: Int8\n}\n\nstruct ReorderedStruct {\n    let b: Int64\n    let a: Int8\n    let c: Int8\n}\n\nprint(MemoryLayout<SmallStruct>.size)\nprint(MemoryLayout<SmallStruct>.stride)\nprint(MemoryLayout<PaddedStruct>.size)\nprint(MemoryLayout<PaddedStruct>.stride)\nprint(MemoryLayout<ReorderedStruct>.size)\nprint(MemoryLayout<ReorderedStruct>.stride)",
    "hint": "Consider alignment requirements and padding between fields.",
    "answer": "Prints '2', '2', '17', '24', '10', '16'. SmallStruct has two Int8s: size=2, stride=2 (no padding needed). PaddedStruct: Int8 (1 byte) + 7 bytes padding (to align Int64) + Int64 (8 bytes) + Int8 (1 byte) = 17 bytes size, but stride rounds up to 24 for alignment of arrays. ReorderedStruct: Int64 (8 bytes) + Int8 (1 byte) + Int8 (1 byte) = 10 bytes size, stride is 16. This shows that field ordering affects memory layout in Swift. Unlike C, Swift may reorder struct fields for optimization in some cases, but in practice the layout follows declaration order. Understanding MemoryLayout is crucial for unsafe pointer operations and interop."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What will be printed?",
    "code": "import Observation\n\n@Observable\nclass UserModel {\n    var name = \"Alice\"\n    var age = 30\n\n    var summary: String {\n        \"\\(name), age \\(age)\"\n    }\n}\n\nlet user = UserModel()\nprint(user.name)\nuser.name = \"Bob\"\nprint(user.name)\n\n// What mechanism tracks property access internally?",
    "hint": "Think about how @Observable transforms stored properties under the hood.",
    "answer": "Prints 'Alice' then 'Bob'. The @Observable macro (introduced with the Observation framework in iOS 17) transforms stored properties by generating backing storage with an underscore prefix and replacing the original properties with computed properties that call access() in the getter and withMutation() in the setter. Internally, it uses an ObservationRegistrar that tracks which properties are accessed during a withObservationTracking call. Unlike Combine's @Published which uses publishers, Observation uses a registrar pattern — when any observed property changes, the registered handler fires. The computed property 'summary' is automatically tracked because accessing it reads 'name' and 'age', triggering their access tracking."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What will be printed? (Assume this runs in an async context)",
    "code": "func demonstrateLifetime() async {\n    let result: String = await withTaskGroup(of: String.self) { group in\n        group.addTask {\n            try? await Task.sleep(nanoseconds: 500_000_000)\n            return \"slow\"\n        }\n        group.addTask {\n            return \"fast\"\n        }\n\n        let first = await group.next()!\n\n        group.cancelAll()\n\n        var remaining: [String] = []\n        for await value in group {\n            remaining.append(value)\n        }\n\n        return \"first: \\(first), remaining: \\(remaining)\"\n    }\n    print(result)\n}",
    "hint": "cancelAll() cancels remaining tasks, but what about tasks that already completed or are about to complete?",
    "answer": "Most likely prints 'first: fast, remaining: [\"slow\"]' or 'first: fast, remaining: []'. The 'fast' task completes immediately and is likely the first result from group.next(). After cancelAll(), the 'slow' task receives cancellation. Since it uses try? await Task.sleep, the sleep will throw CancellationError (caught by try?), and the task returns 'slow' early. The for-await loop collects any remaining completed results. The key insight is that cancelAll() doesn't remove tasks from the group — they still need to be awaited. Structured concurrency guarantees that withTaskGroup won't return until ALL child tasks complete, even cancelled ones. The cancelled task may still return its value if it catches the cancellation error."
  },
  {
    "topic": "code-challenge",
    "level": 5,
    "question": "What is the issue with this code and how would you fix it?",
    "code": "final class SerialExecutor: SerialExecutor {\n    let queue = DispatchQueue(label: \"custom.serial\")\n\n    func enqueue(_ job: consuming ExecutorJob) {\n        let unownedJob = UnownedJob(job)\n        queue.async {\n            unownedJob.runSynchronously(on: self.asUnownedSerialExecutor())\n        }\n    }\n\n    func asUnownedSerialExecutor() -> UnownedSerialExecutor {\n        UnownedSerialExecutor(ordinary: self)\n    }\n}\n\nactor DatabaseActor {\n    nonisolated var unownedExecutor: UnownedSerialExecutor {\n        executor.asUnownedSerialExecutor()\n    }\n    private let executor = SerialExecutor()\n    var data: [String] = []\n\n    func insert(_ value: String) {\n        data.append(value)\n    }\n}",
    "hint": "Think about the lifecycle of the custom executor and when the actor accesses it.",
    "answer": "The class name conflicts with the protocol name SerialExecutor, but assuming that's fixed (e.g., named CustomSerialExecutor), the real issue is lifetime management. The custom executor is stored as a private property of the actor, but unownedExecutor returns an UnownedSerialExecutor — this means there's no strong reference keeping the executor alive from the runtime's perspective. If the actor's executor property were ever released prematurely (e.g., during deinitialization ordering), the unowned reference would dangle. Additionally, the custom executor must ensure thread safety of its own state. In practice, custom executors should be long-lived objects (often global or static), and care must be taken that runSynchronously is called on the exact same executor instance. The DispatchQueue-backed executor pattern works but must handle reentrancy — if actor code calls another actor method that bounces back, the serial queue could deadlock."
  }
];
