// ============================================
// QUESTION BANK — iOS Interview Practice
// 15 topics × 6 levels (Intern → Staff)
// ============================================
var QUESTION_BANK = [

    // =============================================
    // SWIFT LANGUAGE
    // =============================================
    // Level 0 — Intern
    { topic: 'swift', level: 0, question: 'What is the difference between var and let in Swift?', hint: 'Think about mutability.', answer: 'let declares a constant (immutable) — its value cannot be changed after assignment. var declares a variable (mutable) — its value can be reassigned. Prefer let by default for safety and clarity.' },
    { topic: 'swift', level: 0, question: 'What are optionals in Swift and why do they exist?', hint: 'Think about representing the absence of a value.', answer: 'Optionals represent a value that may or may not exist. They are an enum with two cases: .some(value) and .none (nil). They exist to provide compile-time safety against null pointer exceptions, forcing developers to explicitly handle missing values.' },
    { topic: 'swift', level: 0, question: 'What are the basic data types in Swift?', hint: 'Think about numbers, text, and logic.', answer: 'Int (integers), Double/Float (decimals), String (text), Bool (true/false), Character (single character). Swift also has compound types like Array, Dictionary, Set, and Tuple. All are value types.' },
    { topic: 'swift', level: 0, question: 'How do you unwrap an optional in Swift?', hint: 'There are several ways — some safe, some not.', answer: 'Safe: if let (optional binding), guard let (early exit), nil coalescing ?? (default value), optional chaining ?. (propagates nil). Unsafe: force unwrapping ! (crashes if nil). Always prefer safe unwrapping in production code.' },
    { topic: 'swift', level: 0, question: 'What is a function in Swift and how do you define one?', hint: 'Think about the func keyword, parameters, and return types.', answer: 'A function is a reusable block of code. Defined with func keyword: func greet(name: String) -> String { return "Hello, \\(name)" }. Functions have parameter labels (external names), parameter names (internal), return types (-> Type), and can have default parameter values.' },

    // Level 1 — Junior
    { topic: 'swift', level: 1, question: 'Explain the difference between struct and class in Swift.', hint: 'Consider value vs reference semantics, inheritance, and deinit.', answer: 'Structs are value types (copied on assignment), classes are reference types (shared via pointers). Classes support inheritance and deinit, structs do not. Structs are stack-allocated (usually), classes are heap-allocated. Swift favors structs by default — use classes only when you need identity, inheritance, or Objective-C interop.' },
    { topic: 'swift', level: 1, question: 'What is a closure in Swift? How does it capture values?', hint: 'Think about functions as first-class citizens and capture lists.', answer: 'A closure is a self-contained block of functionality that can be passed around. It captures and stores references to variables and constants from the surrounding context (closing over them). By default, closures capture values by strong reference; use capture lists [weak self] or [unowned self] to change this behavior and avoid retain cycles.' },
    { topic: 'swift', level: 1, question: 'What are enums in Swift and how are they more powerful than in other languages?', hint: 'Think about associated values, raw values, and pattern matching.', answer: 'Swift enums can have associated values (different data per case), raw values (backed by String, Int, etc.), computed properties, methods, and conform to protocols. They support pattern matching via switch. They are value types. Example: enum Result<Success, Failure> with .success(value) and .failure(error) cases.' },
    { topic: 'swift', level: 1, question: 'What is the difference between a protocol and a class in Swift?', hint: 'Think about blueprints vs implementations.', answer: 'A protocol defines a blueprint of methods, properties, and requirements without implementation. A class provides concrete implementation. Protocols enable polymorphism without inheritance — any type (struct, class, enum) can conform. Protocols can have default implementations via extensions. Unlike classes, protocols support multiple conformance.' },
    { topic: 'swift', level: 1, question: 'What are guard statements and when should you use them?', hint: 'Think about early exit and unwrapping optionals.', answer: 'guard provides early exit when conditions aren\'t met. guard let unwraps optionals — the unwrapped value is available for the rest of the scope. The else branch must exit (return, throw, break, continue). Use guard for precondition checks at the start of functions to reduce nesting and improve readability.' },

    // Level 2 — Middle
    { topic: 'swift', level: 2, question: 'What are generics in Swift and when would you use them?', hint: 'Think about type-safe code that works with any type.', answer: 'Generics allow you to write flexible, reusable functions and types that can work with any type, subject to requirements you define. Example: Array<Element> is generic. Use them to avoid code duplication while maintaining type safety. Add constraints with where clauses or protocol conformances like <T: Comparable>.' },
    { topic: 'swift', level: 2, question: 'Explain the difference between map, flatMap, and compactMap.', hint: 'All three transform collections, but handle optionals and nesting differently.', answer: 'map transforms each element and returns an array of results. compactMap transforms each element, unwraps optional results, and discards nils. flatMap transforms each element into a sequence and flattens the result into a single array. On optionals, flatMap unwraps and transforms if non-nil, returning nil otherwise.' },
    { topic: 'swift', level: 2, question: 'What are property wrappers in Swift and how do you create one?', hint: 'Think about @State, @Published, and wrapping common property logic.', answer: 'Property wrappers encapsulate common get/set logic in a reusable way. Defined with @propertyWrapper and a wrappedValue property. Examples: @State (SwiftUI), @Published (Combine), @AppStorage. Custom wrappers can add validation, clamping, or lazy initialization. The projectedValue (accessed via $) provides additional API.' },
    { topic: 'swift', level: 2, question: 'What is the difference between == and === in Swift?', hint: 'One checks value equality, the other checks identity.', answer: '== checks value equality — whether two values are equal according to the Equatable protocol. === checks reference identity — whether two class instances point to the exact same object in memory. === only works with reference types (classes). Structs don\'t support ===. You can customize == by implementing the static func == method.' },
    { topic: 'swift', level: 2, question: 'How do extensions work in Swift and what can they add?', hint: 'Think about adding functionality to existing types.', answer: 'Extensions add new functionality to existing types without subclassing. They can add computed properties, methods, initializers, subscripts, nested types, and protocol conformances. They cannot add stored properties or override existing methods. Extensions are used extensively to organize code (MARK sections), add protocol conformance, and extend system types.' },

    // Level 3 — Senior
    { topic: 'swift', level: 3, question: 'What is type erasure in Swift and why would you need it?', hint: 'Consider protocols with associated types and how to store them in collections.', answer: 'Type erasure hides the concrete type behind a wrapper, exposing only the protocol interface. Needed because protocols with associated types (PATs) cannot be used as existential types directly. AnyPublisher, AnySequence, AnyHashable are standard examples. In modern Swift 5.7+, the `any` keyword and primary associated types (e.g., any Collection<Int>) reduce this need significantly.' },
    { topic: 'swift', level: 3, question: 'How does Swift\'s copy-on-write (COW) work internally?', hint: 'Think about reference counting and isKnownUniquelyReferenced.', answer: 'COW stores data in a reference-counted buffer. On mutation, Swift checks isKnownUniquelyReferenced — if the buffer has only one reference, it mutates in place (O(1)); otherwise, it copies the buffer first (O(n)). Standard library types like Array, Dictionary, and String use COW. Custom value types can implement COW using a class-based storage box and checking uniqueness before mutation.' },
    { topic: 'swift', level: 3, question: 'What are opaque types (some keyword) and how do they differ from existential types (any keyword)?', hint: 'Think about type identity preservation vs type hiding.', answer: 'some (opaque type) hides the concrete type but preserves its identity — the compiler knows the specific type, enabling optimizations and associated type usage. any (existential type) boxes any conforming type at runtime with dynamic dispatch overhead. some is for returning a single concrete type; any is for accepting multiple different types. some enables static dispatch; any uses dynamic dispatch through a witness table.' },
    { topic: 'swift', level: 3, question: 'Explain Swift\'s access control levels and when to use each.', hint: 'Five levels from most restrictive to least.', answer: 'private: accessible only within the enclosing declaration. fileprivate: accessible within the same file. internal (default): accessible within the module. public: accessible outside the module but cannot be subclassed/overridden. open: accessible outside the module and can be subclassed/overridden. Use private for implementation details, internal for module-level API, public for library interfaces, open for extensible frameworks.' },
    { topic: 'swift', level: 3, question: 'What are result builders in Swift and how do they work?', hint: 'Think about SwiftUI\'s declarative syntax and @ViewBuilder.', answer: 'Result builders transform a sequence of statements into a single combined value using static methods (buildBlock, buildOptional, buildEither, buildArray, etc.). @ViewBuilder is the most common example — it turns sequential view declarations into a combined view. Custom result builders enable DSLs for HTML, SQL, configuration, etc. They work via compiler transformation of the function body into nested builder calls.' },

    // Level 4 — Lead
    { topic: 'swift', level: 4, question: 'Explain Swift\'s ownership model and how borrowing/consuming works in Swift 5.9+.', hint: 'Think about ~Copyable types, consuming, and borrowing parameters.', answer: 'Swift 5.9+ introduces non-copyable types (~Copyable) with exactly one owner at a time. consuming transfers ownership (caller can no longer use the value), borrowing provides read-only access without copying. This enables RAII patterns, unique file handles, and zero-cost abstractions. It eliminates unnecessary ARC overhead for types that should not be copied, bringing Rust-like ownership semantics to Swift.' },
    { topic: 'swift', level: 4, question: 'How do Swift macros work and what kinds exist?', hint: 'Think about @freestanding and @attached macros, and compile-time code generation.', answer: 'Swift macros generate code at compile time. Freestanding macros (#stringify, #warning) produce values or effects. Attached macros (@Observable, @Model) modify declarations — they can add members, peers, accessors, conformances, or extensions. Macros run as compiler plugins in a sandbox, receiving and returning AST nodes via SwiftSyntax. They enable boilerplate elimination while keeping generated code inspectable via "Expand Macro" in Xcode.' },
    { topic: 'swift', level: 4, question: 'How does the Swift runtime differ from the Objective-C runtime, and what are the performance implications?', hint: 'Think about static vs dynamic dispatch, vtables, and protocol witness tables.', answer: 'Swift uses static dispatch by default (inlined at compile time for structs/enums), vtable dispatch for class methods, and protocol witness tables for protocol-typed values. Objective-C uses objc_msgSend for all method calls (dynamic dispatch via selector lookup). Swift is faster due to devirtualization and inlining optimizations. However, @objc and dynamic keyword bridge to the ObjC runtime. The performance gap is significant in tight loops but negligible for UI code.' },

    // Level 5 — Staff
    { topic: 'swift', level: 5, question: 'How would you design a compile-time dependency injection system using Swift macros and the type system?', hint: 'Consider @attached macros, result builders, and phantom types for compile-time safety.', answer: 'Use Swift macros (@attached(member, peer)) to generate protocol conformances and factory methods at compile time. Phantom types with generic constraints encode the dependency graph in the type system, making missing dependencies a compile error. A result builder DSL declares the module graph, and macros expand it into concrete initializers. This eliminates runtime DI failures entirely and provides IDE autocompletion for available dependencies.' },
    { topic: 'swift', level: 5, question: 'How would you design a Swift language feature proposal for improving a pain point you\'ve encountered?', hint: 'Think about the Swift Evolution process, ABI stability, source compatibility, and community impact.', answer: 'Identify a concrete pain point with real-world examples. Draft a proposal following SE-NNNN format: motivation (real codebases affected), proposed solution (syntax, semantics), detailed design (type system implications, ABI impact), alternatives considered, and source compatibility analysis. Prototype with a SwiftSyntax-based macro or compiler fork. Consider ABI stability constraints (changes to stdlib are permanent). Engage swift-forums for pitch discussion, implement in a compiler branch, and iterate based on core team feedback.' },

    // =============================================
    // SWIFTUI
    // =============================================
    // Level 0
    { topic: 'swiftui', level: 0, question: 'What is the role of the body property in a SwiftUI View?', hint: 'Think about declarative UI.', answer: 'The body property is a computed property that returns the view\'s content and layout. SwiftUI calls it whenever the view\'s state changes, and it returns a description of what the UI should look like. SwiftUI then diffs the old and new descriptions to apply only the minimal necessary updates to the screen.' },
    { topic: 'swiftui', level: 0, question: 'What is the difference between HStack, VStack, and ZStack?', hint: 'Think about layout direction.', answer: 'HStack arranges child views horizontally (left to right). VStack arranges them vertically (top to bottom). ZStack layers them on top of each other (back to front, like z-axis). All three take alignment and spacing parameters. They are the fundamental building blocks for composing layouts in SwiftUI.' },
    { topic: 'swiftui', level: 0, question: 'How do you display a list of items in SwiftUI?', hint: 'Think about List and ForEach.', answer: 'Use List for a scrollable, styled list with built-in features like swipe actions and separators. Use ForEach inside a List or ScrollView to iterate over a collection. Items should conform to Identifiable or provide an id key path. Example: List(items) { item in Text(item.name) }.' },

    // Level 1
    { topic: 'swiftui', level: 1, question: 'What is the difference between @State, @Binding, and @ObservedObject?', hint: 'Consider ownership and source of truth.', answer: '@State is for private value-type state owned by the view — it\'s the source of truth. @Binding creates a two-way reference to a @State owned by a parent view. @ObservedObject watches a reference-type ObservableObject owned elsewhere. @StateObject is like @ObservedObject but the view owns the object\'s lifecycle. Use @State for simple local state, @Binding for child views that need to modify parent state.' },
    { topic: 'swiftui', level: 1, question: 'How do view modifiers work in SwiftUI?', hint: 'Think about chaining transformations that return new views.', answer: 'View modifiers are methods that return a new, modified version of the view. They don\'t mutate — they wrap. Each modifier produces a new view type, forming a chain: Text("Hi").font(.title).foregroundColor(.blue). Order matters: .padding().background(.red) adds padding then colors the padded area, while .background(.red).padding() colors only the text area. Custom modifiers use the ViewModifier protocol.' },
    { topic: 'swiftui', level: 1, question: 'What is @EnvironmentObject and when would you use it?', hint: 'Think about passing data deep through the view hierarchy without explicit prop drilling.', answer: '@EnvironmentObject accesses a shared ObservableObject injected into the view hierarchy via .environmentObject(). It avoids passing data through every intermediate view (prop drilling). The object must be injected by an ancestor — if missing at runtime, the app crashes. Use it for app-wide shared state like user session, theme, or navigation state.' },

    // Level 2
    { topic: 'swiftui', level: 2, question: 'How does SwiftUI determine view identity and why does it matter?', hint: 'Structural identity vs explicit identity, and how it affects animations and state preservation.', answer: 'SwiftUI uses structural identity (position in the view hierarchy) and explicit identity (via .id() modifier or ForEach with Identifiable). Identity determines whether a view is "the same" between renders — same identity preserves @State and enables transitions. Changing identity destroys and recreates the view, resetting all state. Using stable, unique IDs in lists is critical for correct diffing and animation.' },
    { topic: 'swiftui', level: 2, question: 'What is the @Observable macro and how does it differ from ObservableObject?', hint: 'Think about granular observation and Swift 5.9+.', answer: '@Observable (Swift 5.9+, Observation framework) automatically tracks which properties each view reads, triggering re-renders only when those specific properties change. ObservableObject with @Published triggers re-renders when any @Published property changes, even if the view doesn\'t use it. @Observable is more efficient — no need for @Published, and views only update for properties they actually access. It replaces @ObservedObject with direct property access.' },
    { topic: 'swiftui', level: 2, question: 'How do you handle navigation in SwiftUI?', hint: 'Think about NavigationStack, NavigationLink, and programmatic navigation.', answer: 'NavigationStack (iOS 16+) manages a path-based navigation stack. NavigationLink pushes views. Programmatic navigation uses NavigationPath or a simple array bound to the stack. .navigationDestination(for:) defines which view to show for each data type. For modals: .sheet(), .fullScreenCover(). For tabs: TabView. NavigationSplitView handles multi-column layouts on iPad. Avoid the deprecated NavigationView.' },

    // Level 3
    { topic: 'swiftui', level: 3, question: 'Explain the SwiftUI rendering pipeline: what happens between a state change and pixels on screen?', hint: 'Think about attribute graph, dependency tracking, and render tree.', answer: 'When state changes, SwiftUI\'s attribute graph (a directed acyclic graph of dependencies) detects which views depend on that state. Only affected body properties are re-evaluated, producing new view descriptions. SwiftUI diffs these against previous descriptions, generating minimal mutations. These are applied to the render tree (backed by CALayer/UIView on iOS). The process is O(n) in changed nodes, not total tree size.' },
    { topic: 'swiftui', level: 3, question: 'How do you create custom animations and transitions in SwiftUI?', hint: 'Think about Animatable, AnimatableData, and custom transitions.', answer: 'Custom animations: conform to Animatable and implement animatableData to tell SwiftUI which value to interpolate. Use withAnimation or .animation() modifier. Custom timing: Animation.timingCurve(). Custom transitions: implement AnyTransition using .modifier(active:identity:) with a ViewModifier that defines start and end states. Combine transitions with .combined(with:). Use matchedGeometryEffect for hero transitions between views.' },
    { topic: 'swiftui', level: 3, question: 'What are the key performance pitfalls in SwiftUI and how do you avoid them?', hint: 'Think about unnecessary re-renders, view identity, and body complexity.', answer: 'Pitfalls: (1) Unnecessary re-renders from ObservableObject — use @Observable or split into focused view models. (2) Unstable view identity causing state reset — use stable IDs. (3) Heavy body computations — extract into separate views with Equatable conformance. (4) Large @State dictionaries/arrays — each mutation triggers full diff. (5) Inline closures creating new instances each render. Solutions: use Instruments SwiftUI profiler, add Self._printChanges() in body to debug re-renders.' },

    // Level 4
    { topic: 'swiftui', level: 4, question: 'How would you build a performant infinite scrolling list with complex cells in SwiftUI?', hint: 'Consider LazyVStack, prefetching, view identity, and avoiding body re-evaluations.', answer: 'Use LazyVStack inside ScrollView (or List) for view recycling. Ensure stable Identifiable IDs to prevent unnecessary recreation. Extract cell views into separate structs with Equatable conformance so SwiftUI can skip unchanged cells. Use .task for async data prefetching when cells appear. Minimize @ObservedObject dependencies per cell. For truly complex cases, use UIViewControllerRepresentable wrapping UICollectionView with DiffableDataSource and compositional layout.' },
    { topic: 'swiftui', level: 4, question: 'How do you bridge SwiftUI and UIKit effectively in a large codebase?', hint: 'Think about UIViewRepresentable, UIHostingController, and data flow between the two.', answer: 'UIKit in SwiftUI: use UIViewRepresentable (wraps UIView) or UIViewControllerRepresentable (wraps UIViewController). Implement makeUIView, updateUIView, and Coordinator for delegate callbacks. SwiftUI in UIKit: use UIHostingController to embed SwiftUI views. Data flow: pass @Binding or ObservableObject to Coordinators. Sizing: override sizeThatFits for proper Auto Layout integration. Common pitfall: UIHostingController not invalidating its size — call view.invalidateIntrinsicContentSize().' },

    // Level 5
    { topic: 'swiftui', level: 5, question: 'How would you design a cross-platform Design System in SwiftUI that supports theming, RTL, accessibility, and dynamic type while remaining maintainable across 50+ engineers?', hint: 'Think about token architecture, component API design, and documentation automation.', answer: 'Build a semantic token layer (colors, typography, spacing, radii) as EnvironmentValues, resolved from platform-specific configurations. Components accept tokens, not raw values. Use ViewModifiers and custom ButtonStyles/ToggleStyles for consistent theming. RTL support via Environment layoutDirection. Mandate accessibilityLabel and dynamic type via @ScaledMetric. Ship as SPM package with snapshot tests for every component × state × configuration. Auto-generate DocC documentation. Showroom app for visual regression testing.' },
    { topic: 'swiftui', level: 5, question: 'How would you architect a SwiftUI app for offline-first operation with real-time sync and conflict resolution?', hint: 'Think about local-first data architecture, SwiftData, and sync strategies.', answer: 'Use SwiftData (or Core Data) as the local source of truth — UI always reads from local store. Implement a sync engine that tracks local mutations as a log of operations. Use CRDTs or operational transform for conflict-free merging. Background sync via URLSession background tasks. Handle schema evolution with lightweight migrations. Optimistic UI: show local changes immediately, reconcile with server asynchronously. Use CloudKit for Apple-native sync or custom WebSocket-based sync for cross-platform.' },

    // =============================================
    // UIKIT
    // =============================================
    // Level 0
    { topic: 'uikit', level: 0, question: 'What is a UIViewController and what is its purpose?', hint: 'Think about managing a screen of content.', answer: 'UIViewController manages a view hierarchy (one screen of content). It handles view lifecycle (viewDidLoad, viewWillAppear, etc.), responds to user interactions, and coordinates with the navigation system. Every screen in a UIKit app is backed by a view controller. It loads its view lazily — the view isn\'t created until it\'s first accessed.' },
    { topic: 'uikit', level: 0, question: 'What is the difference between UITableView and UICollectionView?', hint: 'Think about single-column lists vs flexible grid layouts.', answer: 'UITableView displays a single-column, vertically scrolling list of rows with built-in styling (cell separators, section headers). UICollectionView is more flexible — it supports any layout via UICollectionViewLayout, including grids, horizontal scrolling, and custom arrangements. UICollectionView is the modern choice for most use cases. Both use cell reuse for performance.' },
    { topic: 'uikit', level: 0, question: 'What is the difference between addSubview and presenting a view controller?', hint: 'Think about view hierarchy vs view controller hierarchy.', answer: 'addSubview adds a view as a child of another view within the same view controller. Presenting (present(_:animated:)) shows a new view controller modally on top of the current one, with its own lifecycle and navigation. addSubview is for composing UI within a screen; presenting is for showing a new screen. You can also push onto a UINavigationController stack.' },

    // Level 1
    { topic: 'uikit', level: 1, question: 'What is the difference between frame and bounds in UIKit?', hint: 'Think about the parent coordinate system vs the view\'s own coordinate system.', answer: 'frame is the view\'s position and size in its superview\'s coordinate system. bounds is the view\'s rectangle in its own coordinate system (origin usually 0,0). Changing bounds.origin scrolls the content (like UIScrollView does). After rotation, frame becomes the axis-aligned bounding rect while bounds stays the same. Use frame for positioning relative to parent; bounds for internal layout and content.' },
    { topic: 'uikit', level: 1, question: 'What is the view lifecycle of a UIViewController?', hint: 'Think about the sequence of methods called from loading to disappearing.', answer: 'loadView → viewDidLoad (view loaded into memory, setup once) → viewWillAppear (about to become visible) → viewDidAppear (now visible, start animations) → viewWillDisappear (about to leave screen) → viewDidDisappear (no longer visible). viewDidLoad is called once; the appear/disappear methods are called every time the view is shown/hidden. Use viewDidLoad for one-time setup, viewWillAppear for data refresh.' },
    { topic: 'uikit', level: 1, question: 'How does delegation work in UIKit?', hint: 'Think about protocols and one-to-one communication.', answer: 'Delegation is a design pattern where one object (the delegator) communicates back to another (the delegate) via a protocol. The delegate conforms to a protocol (e.g., UITableViewDelegate) and the delegator holds a weak reference. This enables customization without subclassing. Example: UITableView asks its delegate for cell height, selection handling, etc. Always use weak var delegate to prevent retain cycles.' },

    // Level 2
    { topic: 'uikit', level: 2, question: 'Explain the Auto Layout constraint system and its priority mechanism.', hint: 'Required vs optional constraints and intrinsic content size.', answer: 'Auto Layout uses constraints (linear equations relating view attributes) to calculate positions and sizes. Priorities: 1000 (required) — must be satisfied; < 1000 (optional) — satisfied on best-effort basis. Content Hugging Priority resists growing beyond intrinsic content size; Compression Resistance Priority resists shrinking below it. The layout engine (Cassowary algorithm) solves all constraints simultaneously. Ambiguous layouts have multiple solutions; conflicting required constraints cause runtime errors.' },
    { topic: 'uikit', level: 2, question: 'What is UICollectionViewCompositionalLayout and why was it introduced?', hint: 'Think about complex layouts without custom UICollectionViewLayout subclasses.', answer: 'Compositional Layout (iOS 13+) builds complex collection view layouts from composable pieces: Item → Group → Section → Layout. Each level defines size (fractional, absolute, estimated), spacing, and scrolling behavior. Sections can have different layouts and orthogonal scrolling (e.g., horizontal carousel in a vertical list). It replaces the need for custom UICollectionViewFlowLayout subclasses and handles self-sizing cells automatically.' },
    { topic: 'uikit', level: 2, question: 'What is DiffableDataSource and how does it improve on traditional data sources?', hint: 'Think about identifiable data and automatic animations.', answer: 'UICollectionViewDiffableDataSource (iOS 13+) uses snapshots of identifiable data instead of manual index path management. You apply a NSDiffableDataSourceSnapshot with sections and items — the framework automatically calculates insertions, deletions, and moves with smooth animations. No more "invalid number of items" crashes. Items must be Hashable. It replaces reloadData() with apply(snapshot, animatingDifferences:) for safe, animated updates.' },

    // Level 3
    { topic: 'uikit', level: 3, question: 'How does the UIKit responder chain work and how would you use it?', hint: 'Think about event propagation from hit-testing to first responder.', answer: 'Touch events use hit-testing (hitTest(_:with:)) to find the deepest view at the touch point — it traverses the view tree in reverse order. Events travel up the responder chain: view → superview → ... → view controller → window → UIApplication. Each responder can handle or pass along the event. The first responder receives keyboard/remote events. Use the chain for app-wide gestures, menu commands, undo/redo, and custom inter-component communication.' },
    { topic: 'uikit', level: 3, question: 'How do you implement custom view controller transitions in UIKit?', hint: 'Think about UIViewControllerAnimatedTransitioning and transition coordinators.', answer: 'Implement UIViewControllerTransitioningDelegate to provide custom animation controllers. The animator conforms to UIViewControllerAnimatedTransitioning — implement transitionDuration and animateTransition (using the transitionContext to access from/to views). For interactive transitions, implement UIViewControllerInteractiveTransitioning. Use UIPercentDrivenInteractiveTransition for gesture-driven transitions. Transition coordinators allow alongside animations that sync with the transition.' },

    // Level 4
    { topic: 'uikit', level: 4, question: 'How would you architect a UIKit app to support both iPhone and iPad with different layouts efficiently?', hint: 'Think about size classes, trait collections, and UISplitViewController.', answer: 'Use trait collections (horizontalSizeClass, verticalSizeClass) to adapt layouts dynamically. UISplitViewController provides master-detail on iPad and navigation stack on iPhone. Compositional Layout adapts columns based on container width. Override traitCollectionDidChange for dynamic updates. Define adaptive constraints in Interface Builder or code. Use UIContentContainer methods for size transition animations. Support multitasking (Slide Over, Split View) by not assuming full-screen dimensions.' },
    { topic: 'uikit', level: 4, question: 'How do you implement a high-performance custom drawing view in UIKit?', hint: 'Think about Core Graphics, CALayer, and draw optimization.', answer: 'Override draw(_:) in UIView for Core Graphics rendering — use CGContext for paths, fills, strokes. For better performance: use CAShapeLayer for vector shapes (GPU-accelerated), CATiledLayer for large content. setNeedsDisplay() marks the view dirty; setNeedsDisplay(in: rect) limits redrawing. Avoid drawing in layoutSubviews. For complex rendering: use Metal or Core Image. Profile with Core Animation instrument to detect off-screen rendering and overdraw.' },

    // Level 5
    { topic: 'uikit', level: 5, question: 'How would you design a plugin architecture for a UIKit-based app that allows runtime feature injection?', hint: 'Think about dynamic frameworks, protocol-based contracts, and feature registries.', answer: 'Define feature contracts as protocols in a shared interface module. Each feature is a dynamic framework loaded at runtime via Bundle.load(). Features register themselves with a central FeatureRegistry using a known entry-point protocol. The host app discovers features via registry lookup and presents them through UIViewControllerRepresentable contracts. Use dependency injection containers to provide shared services. Versioned protocols ensure forward/backward compatibility. Test features in isolation with mock registries.' },

    // =============================================
    // COMBINE & ASYNC/AWAIT
    // =============================================
    // Level 0
    { topic: 'combine', level: 0, question: 'What is reactive programming and why is it useful?', hint: 'Think about responding to changes over time.', answer: 'Reactive programming is a paradigm where you declare how data flows and transformations happen, and the system automatically propagates changes. Instead of polling for updates, you subscribe to streams of values. It\'s useful for handling asynchronous events like user input, network responses, and timers in a composable, declarative way — avoiding callback hell and tangled state management.' },
    { topic: 'combine', level: 0, question: 'What is the difference between async/await and completion handlers?', hint: 'Think about readability and error handling.', answer: 'Completion handlers use closures to deliver results asynchronously — they lead to nested callbacks (pyramid of doom) and complex error handling. async/await lets you write asynchronous code that reads like synchronous code — linear flow, try/catch for errors, no nesting. async/await is built into Swift 5.5+, produces cleaner code, and integrates with structured concurrency for automatic cancellation and task management.' },

    // Level 1
    { topic: 'combine', level: 1, question: 'What is Combine and what problem does it solve?', hint: 'Think about reactive programming and event streams.', answer: 'Combine is Apple\'s reactive framework for processing values over time. It provides a declarative API using Publishers (emit values), Operators (transform/filter/combine), and Subscribers (receive values). It solves callback hell, simplifies async data flow, and provides built-in error handling, cancellation, and back-pressure via the Demand system. Common publishers: @Published, NotificationCenter, URLSession, Timer.' },
    { topic: 'combine', level: 1, question: 'What is the role of AnyCancellable in Combine?', hint: 'Think about subscription lifecycle management.', answer: 'AnyCancellable is a type-erased cancellable that automatically cancels the subscription when deallocated. Store subscriptions in a Set<AnyCancellable> property (typically named cancellables) — when the owning object is deallocated, all subscriptions cancel automatically. Without storing the cancellable, the subscription would be cancelled immediately after creation. Call .store(in: &cancellables) on any subscription.' },

    // Level 2
    { topic: 'combine', level: 2, question: 'What is the difference between CurrentValueSubject and PassthroughSubject?', hint: 'One remembers its latest value, the other does not.', answer: 'CurrentValueSubject holds and broadcasts a current value — new subscribers immediately receive the latest value. It requires an initial value and has a .value property. PassthroughSubject does not store any value — subscribers only receive values published after subscribing. Use CurrentValueSubject for state (view model properties), PassthroughSubject for events (button taps, one-shot signals).' },
    { topic: 'combine', level: 2, question: 'How do you combine multiple publishers in Combine?', hint: 'Think about merge, zip, combineLatest.', answer: 'merge combines publishers of the same type into one stream, emitting values from any source as they arrive. zip pairs values from two publishers, emitting tuples only when both have a new value. combineLatest emits the latest values from all publishers whenever any one changes. CombineLatest is common for form validation (combining multiple field publishers). Use switchToLatest to flatten a publisher of publishers, cancelling previous inner subscriptions.' },

    // Level 3
    { topic: 'combine', level: 3, question: 'How does back-pressure work in Combine?', hint: 'Think about the Demand type and how subscribers control flow.', answer: 'Subscribers control flow by requesting values via Subscribers.Demand (.none, .max(n), or .unlimited). Publishers should only emit as many values as demanded, preventing fast producers from overwhelming slow consumers. The receive(_:) method returns additional demand. Most built-in subscribers use .unlimited. Custom subscribers implement back-pressure by requesting .max(1) and requesting more only after processing. This pull-based model prevents buffer overflow.' },
    { topic: 'combine', level: 3, question: 'How would you migrate from Combine to async/await and AsyncSequence?', hint: 'Think about bridging the two worlds and when each is more appropriate.', answer: 'Use publisher.values to convert any Combine publisher into an AsyncSequence. For the reverse, use AsyncStream and feed it into a publisher. Prefer async/await for request-response patterns (network calls, one-shot operations). Prefer Combine for continuous streams (UI bindings, real-time data, complex operator chains). In practice, ViewModels can use async/await internally while exposing @Published properties for SwiftUI binding. Gradual migration is safe — both coexist well.' },

    // Level 4
    { topic: 'combine', level: 4, question: 'How would you design a reactive state management system using Combine for a complex iOS app?', hint: 'Think about unidirectional data flow, reducers, and middleware.', answer: 'Implement a Store that holds state as a CurrentValueSubject. Actions are enums sent via a dispatch method. A pure reducer function takes (State, Action) → State. Middleware intercepts actions for side effects (API calls, logging) and can dispatch new actions. Views subscribe to state slices using .map and .removeDuplicates. This is the Composable Architecture (TCA) pattern. Benefits: predictable state, time-travel debugging, easy testing of reducers as pure functions.' },
    { topic: 'combine', level: 4, question: 'What are custom Combine operators and when should you create one?', hint: 'Think about encapsulating reusable publisher transformation logic.', answer: 'Custom operators extend Publisher to add domain-specific transformations. Implement by creating a new Publisher struct with a custom Subscription that manages demand and output. Example: a .retry(times:delay:) that adds exponential backoff, or .validate() that checks business rules. Use operator composition (chaining existing operators in an extension) for simple cases. Only create custom Subscription-based operators when existing operators can\'t express the logic — they require careful demand management and cancellation handling.' },

    // Level 5
    { topic: 'combine', level: 5, question: 'How would you design a cross-platform reactive framework that unifies Combine, AsyncSequence, and RxSwift under a single abstraction?', hint: 'Think about protocol abstraction, type-erased streams, and platform-specific backends.', answer: 'Define a ReactiveStream protocol with map, filter, flatMap, and subscribe. Use conditional compilation (#if canImport(Combine)) to select backends. Type-erase into AnyReactiveStream. Bridge layers: Combine Publisher → ReactiveStream via .values, RxSwift Observable → ReactiveStream via AsyncStream adapter. Shared operators implemented generically over the protocol. Platform modules provide native integrations. Testing uses a synchronous TestStream. The key challenge is back-pressure semantics — Combine is pull-based, RxSwift is push-based. Use buffering strategies to reconcile.' },

    // =============================================
    // ARCHITECTURE & PATTERNS
    // =============================================
    // Level 0
    { topic: 'architecture', level: 0, question: 'What is MVC and how does iOS use it?', hint: 'Think about Model, View, Controller and their responsibilities.', answer: 'MVC separates an app into Model (data and business logic), View (UI display), and Controller (mediates between Model and View). In iOS/UIKit, UIViewController acts as the controller — it owns the view, handles user events, and updates the model. The criticism of iOS MVC is "Massive View Controller" — controllers tend to grow large because they handle too many responsibilities.' },
    { topic: 'architecture', level: 0, question: 'What is a design pattern and why are they useful?', hint: 'Think about reusable solutions to common problems.', answer: 'A design pattern is a proven, reusable solution to a commonly occurring problem in software design. They provide shared vocabulary (Singleton, Observer, Factory), reduce trial-and-error, and make code more understandable to other developers. iOS commonly uses: Delegation (UITableViewDelegate), Observer (NotificationCenter, KVO), Singleton (URLSession.shared), Factory (creating views), and Strategy (different sorting algorithms).' },

    // Level 1
    { topic: 'architecture', level: 1, question: 'What is the MVVM pattern and how does it work in iOS?', hint: 'Think about separation of concerns between UI, business logic, and data.', answer: 'MVVM separates the app into Model (data & business logic), View (UI display), and ViewModel (transforms model data for the view, handles user actions). The View observes the ViewModel via bindings (@Published, Combine, or @Observable). The ViewModel doesn\'t know about the View (no UIKit/SwiftUI imports). This enables testability — ViewModels are unit tested without UI, and Views become thin display layers.' },
    { topic: 'architecture', level: 1, question: 'What is dependency injection and why is it important?', hint: 'Think about providing dependencies from outside rather than creating them internally.', answer: 'Dependency injection provides an object\'s dependencies from outside rather than having it create them internally. Three types: constructor injection (via init), property injection (setting after creation), method injection (passed as parameters). Benefits: testability (inject mocks), flexibility (swap implementations), decoupling (depend on protocols, not concrete types). Without DI, classes are tightly coupled and hard to test in isolation.' },

    // Level 2
    { topic: 'architecture', level: 2, question: 'What are the SOLID principles and how do you apply them in Swift?', hint: 'Five principles: S, O, L, I, D.', answer: 'Single Responsibility: each type has one reason to change. Open/Closed: open for extension, closed for modification (protocols, generics). Liskov Substitution: subtypes must be substitutable for base types. Interface Segregation: many specific protocols over one general one. Dependency Inversion: depend on abstractions (protocols), not concretions. In Swift, protocols are the primary tool for O, L, I, and D. Extensions enable O without modifying original types.' },
    { topic: 'architecture', level: 2, question: 'What is the Coordinator pattern and when would you use it?', hint: 'Think about extracting navigation logic from view controllers.', answer: 'The Coordinator pattern extracts navigation logic into dedicated objects. Each Coordinator owns a navigation controller and decides which screen to show next based on events from its child view controllers. Benefits: view controllers become reusable (they don\'t know about each other), navigation logic is centralized and testable, and deep linking becomes straightforward. Use it when navigation logic is complex or screens are reused in different flows.' },
    { topic: 'architecture', level: 2, question: 'What is the Repository pattern and how does it help in iOS apps?', hint: 'Think about abstracting data access behind a clean interface.', answer: 'The Repository pattern provides a clean API for data access, hiding whether data comes from network, database, or cache. The repository decides the data source strategy (cache-first, network-first, etc.). Benefits: business logic doesn\'t know about data sources, easy to swap implementations (mock for tests), and caching logic is centralized. Example: UserRepository with methods like getUser(id:) that checks cache, then network, then persists.' },

    // Level 3
    { topic: 'architecture', level: 3, question: 'Compare MVI and MVVM architectures. When would you choose one over the other?', hint: 'Think about unidirectional data flow vs bidirectional bindings.', answer: 'MVVM uses bidirectional bindings — the ViewModel exposes observable state and the View both reads state and sends actions. MVI (Model-View-Intent) enforces unidirectional flow: View emits Intents → Reducer produces new State → View renders State. MVI is more predictable (single state snapshot), easier to debug and test, avoids state inconsistencies. Choose MVI for complex state machines with many transitions; MVVM for simpler screens where bidirectional bindings reduce boilerplate.' },
    { topic: 'architecture', level: 3, question: 'What is Clean Architecture and how does it apply to iOS?', hint: 'Think about layers, dependency rules, and use cases.', answer: 'Clean Architecture organizes code into concentric layers: Entities (business models), Use Cases (business rules), Interface Adapters (ViewModels, Repositories), and Frameworks (UIKit, CoreData). The dependency rule: inner layers never depend on outer layers. This makes business logic framework-independent and highly testable. In iOS: Domain layer (protocols, use cases), Data layer (repositories, API clients), and Presentation layer (ViewModels, Views). Trade-off: more boilerplate but better separation.' },
    { topic: 'architecture', level: 3, question: 'How do you handle deep linking and universal links in an iOS app architecture?', hint: 'Think about URL routing, coordinators, and state restoration.', answer: 'Parse incoming URLs into strongly-typed Route enums. A central Router or DeepLinkHandler maps routes to navigation actions. With Coordinators: the router tells the appropriate coordinator to navigate. With SwiftUI NavigationStack: manipulate the navigation path programmatically. Handle both cold launch (URL in launch options) and warm launch (scene delegate). For Universal Links: configure apple-app-site-association on your server. Test edge cases: app in background, nested deep links, authentication-gated destinations.' },

    // Level 4
    { topic: 'architecture', level: 4, question: 'How would you design a modular architecture for a large iOS app (50+ engineers, 8 teams)?', hint: 'Think about module boundaries, dependency rules, build times, and team autonomy.', answer: 'Layered modules: Feature modules (team-owned), Domain modules (shared business logic), Core modules (networking, storage, analytics), and a thin App shell. Dependency rules: features never depend on each other, only on domain/core. Use SPM for module management with separate repos or a monorepo with local packages. Define module APIs via protocols in interface packages. Each module has independent tests, schemes, and CI pipelines. Wire modules via DI container at app level. Enforce dependency rules with build scripts or linting.' },
    { topic: 'architecture', level: 4, question: 'How do you design a feature flag system for gradual rollouts in an iOS app?', hint: 'Think about remote configuration, local overrides, and code architecture.', answer: 'Define flags as a strongly-typed enum or struct. Flags resolve in priority order: local debug override → remote config (Firebase, LaunchDarkly) → compiled default. Use a FeatureFlagService protocol injected via DI for testability. Architecture: guard feature entry points with flag checks; don\'t scatter checks throughout code. Support percentage rollouts, user segment targeting, and A/B testing. Provide a debug menu for QA to toggle flags. Clean up old flags regularly — track flag age in code comments or linting rules.' },

    // Level 5
    { topic: 'architecture', level: 5, question: 'How would you migrate a 500K+ LOC UIKit app to SwiftUI incrementally with zero regressions across 8 teams shipping in parallel?', hint: 'Think about coexistence strategy, feature flags, testing pyramid, and team coordination.', answer: 'Create a UIHostingController bridge layer for embedding SwiftUI views in UIKit navigation. Migrate screen-by-screen, bottom-up (leaf screens first). Feature flags ship old/new implementations side by side. Establish a shared SwiftUI design system early. Snapshot tests compare UIKit and SwiftUI renders pixel-by-pixel. Contract tests ensure ViewModels produce identical state. Shadow mode runs both implementations during QA. Architecture guild with team representatives coordinates conventions. Timeline: 18-24 months with parallel shipping throughout.' },
    { topic: 'architecture', level: 5, question: 'How would you design a micro-frontend architecture for an iOS super-app hosting features from multiple teams and external partners?', hint: 'Think about runtime isolation, API contracts, versioning, and security sandboxing.', answer: 'Each micro-frontend is a dynamic framework with a standardized entry-point protocol (FeatureModule). Host app discovers and loads features at runtime via a FeatureRegistry. Communication through a typed event bus — features cannot import each other. Shared services (auth, analytics, networking) provided via protocol injection from the host. External partner features run in a WebView sandbox with a JavaScript bridge for native capabilities. Version compatibility matrix ensures host-feature compatibility. Review and signing process for third-party features.' },

    // =============================================
    // MEMORY MANAGEMENT
    // =============================================
    // Level 0
    { topic: 'memory', level: 0, question: 'What is memory management and why does it matter in iOS?', hint: 'Think about limited device resources and app termination.', answer: 'Memory management ensures objects are allocated when needed and freed when no longer used. iOS devices have limited RAM — if your app uses too much, the system terminates it. Good memory management prevents crashes, improves performance, and extends battery life. Swift uses Automatic Reference Counting (ARC) to handle most memory management automatically for reference types (classes).' },
    { topic: 'memory', level: 0, question: 'What is the difference between stack and heap memory?', hint: 'Think about value types vs reference types.', answer: 'Stack: fast, automatic allocation/deallocation, stores value types (structs, enums) and function call frames. Each thread has its own stack. Heap: slower, manually managed (via ARC for Swift), stores reference types (classes). Heap objects can be shared across the app. Stack allocation is a simple pointer bump; heap allocation requires finding free space and is thread-synchronized. Prefer value types for better performance when identity isn\'t needed.' },

    // Level 1
    { topic: 'memory', level: 1, question: 'What is ARC and how does it work?', hint: 'Automatic Reference Counting.', answer: 'ARC automatically manages memory for reference types (classes). Each object has a reference count. Strong references increment the count; releasing them decrements it. When the count reaches 0, the object is deallocated and deinit is called. ARC inserts retain/release calls at compile time — it\'s not garbage collection (no runtime scanning pauses). Value types (structs, enums) don\'t use ARC — they\'re copied and deallocated automatically.' },
    { topic: 'memory', level: 1, question: 'What is the difference between weak and unowned references?', hint: 'Think about optional vs non-optional and lifecycle guarantees.', answer: 'Both prevent retain cycles by not incrementing the reference count. weak is optional — automatically becomes nil when the referenced object is deallocated (safe for uncertain lifetimes). unowned is non-optional — accessing it after the object is deallocated crashes (use only when you guarantee the reference outlives the owner). Common uses: weak for delegates, [weak self] in closures; unowned when parent-child lifecycles are tightly coupled.' },

    // Level 2
    { topic: 'memory', level: 2, question: 'What is a retain cycle and how do you prevent it?', hint: 'Two objects holding strong references to each other.', answer: 'A retain cycle occurs when two or more objects hold strong references to each other, preventing their reference counts from reaching zero — they leak permanently. Common in: closures capturing self, delegate patterns, parent-child relationships. Prevent with: weak delegates, [weak self] or [unowned self] in closure capture lists, breaking circular references by design. Timer invalidation is also important — repeating timers retain their target.' },
    { topic: 'memory', level: 2, question: 'What common patterns in iOS lead to memory leaks?', hint: 'Think about closures, delegates, timers, and notification observers.', answer: 'Common leak patterns: (1) Closures capturing self strongly — use [weak self]. (2) Strong delegate references — always use weak var delegate. (3) Repeating Timer retaining its target — invalidate in deinit or use Combine Timer.publish. (4) NotificationCenter observers not removed (pre-iOS 9, or block-based). (5) Circular references in data models (parent ↔ child). (6) DispatchWorkItem capturing self. Always verify deallocation with deinit print statements during development.' },

    // Level 3
    { topic: 'memory', level: 3, question: 'How would you detect and fix a memory leak in a production iOS app?', hint: 'Think about tools and systematic approaches.', answer: 'Detection: Instruments (Leaks, Allocations), Xcode Memory Graph Debugger (visual object relationships), deinit logs in debug builds. Production: MetricKit for memory footprint monitoring, custom analytics for screen deallocation tracking. Fixing: [weak self] in closures, weak delegates, Timer.invalidate(), breaking model cycles. Systematic prevention: code review rules for closure captures, SwiftLint rules, unit tests verifying deallocation (weak reference becomes nil after scope exit).' },
    { topic: 'memory', level: 3, question: 'How does Swift manage memory for value types vs reference types?', hint: 'Think about stack vs heap, copying, and ARC.', answer: 'Value types (structs, enums): usually stack-allocated, copied on assignment (with COW optimization for stdlib types). No ARC overhead. Reference types (classes): heap-allocated, shared via pointers, managed by ARC. Closures that capture values may cause heap allocation of captured variables (even value types). Large structs containing reference types still incur ARC costs for the references inside. The compiler optimizes by inlining and promoting heap allocations to stack when safe.' },

    // Level 4
    { topic: 'memory', level: 4, question: 'Explain autorelease pools, their purpose in modern Swift, and when you would manually use one.', hint: 'Think about tight loops creating many temporary objects.', answer: 'Autorelease pools defer object deallocation until the pool drains (end of scope). The main run loop has an autorelease pool per iteration. In modern Swift/ARC, they\'re rarely needed explicitly. Use autoreleasepool {} manually in tight loops creating many temporary Objective-C-bridged objects (e.g., NSString from image processing) to prevent memory spikes. Each iteration forces deallocation of temporaries instead of waiting for the outer pool. Also useful in command-line tools without a run loop.' },
    { topic: 'memory', level: 4, question: 'How do you optimize memory usage for an app that processes large images or files?', hint: 'Think about downsampling, streaming, and memory-mapped files.', answer: 'Images: use ImageIO to downsample at load time (CGImageSourceCreateThumbnailAtIndex) instead of loading full resolution into memory. Use UIImage(contentsOfFile:) instead of UIImage(named:) for large one-time images (named: caches permanently). Files: use memory-mapped files (mmap/Data(contentsOf:options:.mappedIfSafe)) for read-only access — the OS pages data in/out as needed. Streaming: process large files in chunks using InputStream. Monitor with os_proc_available_memory() and respond to didReceiveMemoryWarning.' },

    // Level 5
    { topic: 'memory', level: 5, question: 'How would you design a memory profiling SDK that teams integrate to catch leaks before they reach production?', hint: 'Think about runtime object tracking, weak reference sentinels, and CI integration.', answer: 'Track UIViewController lifecycle — assert deallocation within N seconds of dismissal using weak reference sentinels (store weak ref, check nil after delay). Extend to any @Trackable-annotated class. Hook into mirror/runtime to detect strong reference cycles by walking object graphs. Report leaks with stack traces and retain graphs. CI mode: fail tests that detect leaks. Production mode: sample-based monitoring with privacy-safe stack symbolication. Provide an in-app debug overlay showing live allocation counts by type. Zero-overhead in release builds via compile-time stripping.' },

    // =============================================
    // CONCURRENCY
    // =============================================
    // Level 0
    { topic: 'concurrency', level: 0, question: 'What is concurrency and why is it important in iOS?', hint: 'Think about doing multiple things at the same time without freezing the UI.', answer: 'Concurrency means executing multiple tasks overlapping in time. In iOS, the main thread handles UI — if you run slow work (networking, file I/O) on it, the app freezes. Concurrency lets you run heavy tasks on background threads while keeping the UI responsive. iOS provides Grand Central Dispatch (GCD), OperationQueue, and async/await for managing concurrent work.' },
    { topic: 'concurrency', level: 0, question: 'What is the main thread and why is it special in iOS?', hint: 'Think about UI updates and user interaction.', answer: 'The main thread (also called the UI thread) is where all UI updates and user interaction handling must occur. UIKit and SwiftUI are not thread-safe — updating UI from a background thread causes crashes or visual glitches. The main thread runs a run loop that processes touch events, layout, and rendering at up to 120fps. Always dispatch UI work to the main thread using DispatchQueue.main or @MainActor.' },

    // Level 1
    { topic: 'concurrency', level: 1, question: 'What is the difference between synchronous and asynchronous execution?', hint: 'Think about blocking vs non-blocking.', answer: 'Synchronous execution blocks the current thread until the operation completes — nothing else can run on that thread meanwhile. Asynchronous execution starts the operation and returns immediately, allowing the thread to continue other work; the result is delivered later via callback, delegate, Combine publisher, or async/await. Always use async for network calls, file I/O, and heavy computation to avoid blocking the main thread.' },
    { topic: 'concurrency', level: 1, question: 'What is Grand Central Dispatch (GCD) and how do you use it?', hint: 'Think about dispatch queues and quality of service.', answer: 'GCD is a C-based API for executing work on dispatch queues. DispatchQueue.main is the main (serial) queue for UI. DispatchQueue.global(qos:) provides concurrent background queues with priorities: .userInteractive, .userInitiated, .default, .utility, .background. Use async {} to dispatch work without blocking. Use sync {} to block until done (never on main queue — deadlock!). Serial queues execute one task at a time; concurrent queues execute multiple.' },

    // Level 2
    { topic: 'concurrency', level: 2, question: 'How do async/await and structured concurrency work in Swift?', hint: 'Think about Task, TaskGroup, and the suspension model.', answer: 'async marks a function that can suspend (yield the thread) and resume later. await marks suspension points. Structured concurrency via TaskGroup creates child tasks that must complete before the parent — cancellation and errors propagate automatically. Task {} creates unstructured tasks. The runtime uses a cooperative thread pool — suspended tasks don\'t block threads. async let enables concurrent bindings. withThrowingTaskGroup enables dynamic fan-out parallelism.' },
    { topic: 'concurrency', level: 2, question: 'What is a data race and how do you prevent it?', hint: 'Think about multiple threads accessing shared mutable state simultaneously.', answer: 'A data race occurs when two or more threads access the same memory location concurrently and at least one is writing — results are unpredictable. Prevention: (1) Use actors for mutual exclusion. (2) Use serial DispatchQueues for synchronized access. (3) Use immutable data (let, value types). (4) Use locks (NSLock, os_unfair_lock) for fine-grained control. (5) Enable Thread Sanitizer (TSan) in Xcode to detect races during testing. Swift 6 strict concurrency catches many races at compile time.' },

    // Level 3
    { topic: 'concurrency', level: 3, question: 'What is an actor in Swift and how does it prevent data races?', hint: 'Think about mutual exclusion and actor isolation.', answer: 'An actor is a reference type that protects its mutable state with serial access — only one task can execute on the actor at a time. External access requires await (potential suspension point). The compiler enforces actor isolation at compile time, preventing concurrent access to actor state. @MainActor ensures code runs on the main thread. Global actors create shared isolation domains. Actors eliminate entire categories of concurrency bugs by making data races structurally impossible.' },
    { topic: 'concurrency', level: 3, question: 'What is the difference between Task, TaskGroup, and async let?', hint: 'Think about structured vs unstructured concurrency and parallelism patterns.', answer: 'Task {} creates an unstructured task — runs independently, must be manually cancelled. TaskGroup creates structured child tasks that must complete before the parent scope exits — cancellation and errors propagate automatically. async let creates concurrent bindings — multiple async operations run in parallel and are awaited together. Use async let for a fixed number of parallel operations, TaskGroup for dynamic/variable counts, and standalone Task for fire-and-forget or bridging from synchronous code.' },

    // Level 4
    { topic: 'concurrency', level: 4, question: 'Explain the Swift 6 strict concurrency model and Sendable.', hint: 'Think about data isolation, Sendable protocol, and compiler enforcement.', answer: 'Swift 6 enables strict concurrency checking by default — the compiler verifies no data races are possible at compile time. Sendable marks types safe to share across concurrency domains (actor boundaries). Value types are implicitly Sendable. Classes must be final with only immutable stored properties, or be actors. @Sendable closures cannot capture mutable state. Every cross-isolation boundary is checked for Sendable conformance. @preconcurrency eases migration. This makes data-race-free code a compile-time guarantee.' },
    { topic: 'concurrency', level: 4, question: 'How do you debug and profile concurrency issues in iOS?', hint: 'Think about Thread Sanitizer, Instruments, and actor reentrancy.', answer: 'Thread Sanitizer (TSan): enable in Xcode scheme to detect data races at runtime — it instruments memory accesses and reports concurrent access. Instruments: System Trace shows thread activity, context switches, and priority inversions. os_signpost marks critical sections for analysis. Actor reentrancy issues: an actor can suspend during await, allowing other tasks to interleave — check state assumptions after each await. Use assertIsolated() in debug builds to verify actor context. Swift concurrency instruments show task creation, suspension, and resumption.' },

    // Level 5
    { topic: 'concurrency', level: 5, question: 'How would you design a high-throughput event processing pipeline using actors, async streams, and back-pressure handling?', hint: 'Think about bounded channels, actor reentrancy, and flow control.', answer: 'Use AsyncStream with a bounded buffer as channels between pipeline stages. Back-pressure: when the buffer is full, the producer suspends via yield\'s return value. Each pipeline stage is an actor processing events serially with transformation logic. Use TaskGroup for fan-out parallelism at CPU-bound stages. Monitor throughput via async-safe metrics actors. Handle actor reentrancy: don\'t assume state is unchanged after an await. Graceful shutdown: propagate cancellation through the pipeline. Benchmark with Instruments System Trace to identify bottlenecks.' },
    { topic: 'concurrency', level: 5, question: 'How would you design a distributed actor system for a peer-to-peer iOS application?', hint: 'Think about Swift distributed actors, transport layers, and consistency models.', answer: 'Use Swift\'s distributed actor system — define distributed actor types with distributed func methods. Implement a custom DistributedActorSystem for the transport layer (MultipeerConnectivity for local P2P, WebSocket for remote). Serialize calls using Codable. Handle network partitions with eventual consistency — use CRDTs for shared state. Actor identity via ActorID maps to network addresses. Implement supervision strategies for actor failure recovery. Security: mutual TLS authentication between peers, signed actor messages to prevent spoofing.' },

    // =============================================
    // TESTING
    // =============================================
    // Level 0
    { topic: 'testing', level: 0, question: 'What is software testing and what types exist for iOS?', hint: 'Think about different levels of testing — from individual functions to full app.', answer: 'Software testing verifies that code works correctly. Types for iOS: Unit tests (test individual functions/classes in isolation), Integration tests (test how components work together), UI tests (XCUITest — simulate user interactions), Snapshot tests (compare rendered UI against reference images), and Performance tests (measure execution time). The testing pyramid suggests many unit tests, fewer integration tests, and fewer UI tests.' },
    { topic: 'testing', level: 0, question: 'What is XCTest and how do you write a basic test?', hint: 'Think about test classes, test methods, and assertions.', answer: 'XCTest is Apple\'s testing framework. Create a class inheriting from XCTestCase. Test methods start with "test" prefix: func testAddition(). Use assertions: XCTAssertEqual(2+2, 4), XCTAssertTrue(condition), XCTAssertNil(value), XCTAssertThrowsError(try riskyCall()). setUp() runs before each test, tearDown() after. Run tests with Cmd+U or via CI. Group related tests in the same test class.' },

    // Level 1
    { topic: 'testing', level: 1, question: 'What is unit testing and why is it important?', hint: 'Testing individual units of code in isolation.', answer: 'Unit testing verifies that individual functions, methods, or classes work correctly in isolation. Tests are automated, fast (milliseconds), and repeatable. Benefits: catch regressions early, serve as living documentation, enable confident refactoring, reduce debugging time. Follow the AAA pattern: Arrange (set up inputs), Act (call the method), Assert (check the result). Aim for tests that are independent, deterministic, and focused on one behavior each.' },
    { topic: 'testing', level: 1, question: 'What are mocks, stubs, and fakes? When do you use each?', hint: 'Think about test doubles for replacing real dependencies.', answer: 'Stub: provides canned responses to method calls (e.g., always returns a specific user). Mock: verifies that specific methods were called with expected arguments (behavior verification). Fake: a working implementation but simplified (e.g., in-memory database instead of SQLite). Use stubs when you need a dependency to return specific data, mocks when you need to verify interactions, and fakes when you need realistic behavior without external systems.' },

    // Level 2
    { topic: 'testing', level: 2, question: 'How do you test asynchronous code in Swift?', hint: 'XCTestExpectation and async/await support in XCTest.', answer: 'For async/await: mark test methods as async and use await directly — cleanest approach. For callback-based: use XCTestExpectation — create an expectation, fulfill() it in the callback, and wait(for:timeout:). For Combine: use expectation with sink, or collect values into an array. Always set reasonable timeouts. Test cancellation and error paths too. Swift Testing framework (iOS 18+) has built-in async support with #expect macro.' },
    { topic: 'testing', level: 2, question: 'How do you test a ViewModel in an MVVM architecture?', hint: 'Think about injecting mock dependencies and asserting state changes.', answer: 'Inject mock services via protocols in the ViewModel init. Test state transitions: (1) Arrange — create ViewModel with mocks. (2) Act — call methods or simulate user actions. (3) Assert — check @Published property values. For Combine: subscribe to publishers and collect emitted values. Test error states by making mocks throw. Test loading states by using async mocks with controlled completion. Example: mock NetworkService returns predefined data, verify ViewModel transforms it correctly for display.' },

    // Level 3
    { topic: 'testing', level: 3, question: 'What is snapshot testing and when would you use it over unit/UI tests?', hint: 'Visual regression testing.', answer: 'Snapshot testing renders a view to an image and compares it against a stored reference. It catches unintended visual changes that unit tests miss (layout shifts, color changes, font regressions). Use for: design system components, complex layouts, dark mode/RTL/accessibility variations, localized strings. Libraries: swift-snapshot-testing (Point-Free). Faster than XCUITest. First run records references; subsequent runs compare. Combine with unit tests for logic and snapshots for appearance. Review diff images in PRs.' },
    { topic: 'testing', level: 3, question: 'How do you write effective integration tests for an iOS app?', hint: 'Think about testing real component interactions without full UI.', answer: 'Integration tests verify that real components work together — unlike unit tests (isolated) or UI tests (full app). Test real ViewModel + Repository with a mock network layer. Test Core Data stack with an in-memory store. Test navigation flow with real coordinators but headless (no actual rendering). Use XCTest or Quick/Nimble. Keep them faster than UI tests by avoiding actual rendering. Test real JSON parsing with fixture files. Verify error handling across layer boundaries.' },

    // Level 4
    { topic: 'testing', level: 4, question: 'How would you achieve 90%+ test coverage in a large iOS codebase?', hint: 'Think about testing pyramid, architecture, and team processes.', answer: 'Architecture that enables testing: inject all dependencies via protocols. Testing pyramid: many unit tests (fast), moderate integration tests, few E2E tests. Test ViewModels exhaustively (every state transition, error path, edge case). Snapshot test all UI components × configurations. Contract tests for inter-module API boundaries. CI enforces minimum coverage thresholds per PR (e.g., new code must be ≥85%). Code review checklist includes test coverage. Make untestable code architecturally impossible by design. Use code generation for mock boilerplate.' },
    { topic: 'testing', level: 4, question: 'How do you design a reliable and fast CI test suite for a large iOS project?', hint: 'Think about test parallelization, flaky test management, and selective testing.', answer: 'Parallelize: run test targets on multiple simulators simultaneously (xcodebuild -parallel-testing-enabled). Selective testing: only run tests affected by changed files (use dependency graph analysis or test impact analysis). Quarantine flaky tests: track test reliability metrics, auto-quarantine tests below 99% pass rate, fix or delete quarantined tests weekly. Fast feedback: run unit tests first (minutes), integration tests second, UI tests last (or nightly). Cache derived data and simulator state. Use test result analytics to identify slow tests for optimization.' },

    // Level 5
    { topic: 'testing', level: 5, question: 'How would you implement a property-based testing framework for Swift that integrates with XCTest?', hint: 'Think about generators, shrinking, and reproducibility.', answer: 'Define Generator<T> protocol with methods to produce random values and shrink failing cases to minimal reproductions. Built-in generators for primitives, collections, optionals, and custom types (via Codable reflection or manual composition). Integration: forAll(Gen<A>, Gen<B>) { a, b in /* assertions */ } runs N random cases. On failure: shrink inputs to find the smallest failing case, then print a reproducible seed. XCTest integration via custom XCTAssert overloads. Advanced: stateful property testing for checking invariants across sequences of operations. Use deterministic seeds for CI reproducibility.' },

    // =============================================
    // DATA PERSISTENCE
    // =============================================
    // Level 0
    { topic: 'persistence', level: 0, question: 'What is data persistence and why do iOS apps need it?', hint: 'Think about keeping data between app launches.', answer: 'Data persistence means saving data so it survives app termination and device restarts. Without it, all data is lost when the app closes. iOS apps need persistence for: user preferences (UserDefaults), login tokens (Keychain), cached content (files/database), and user-created data (Core Data, SwiftData). The choice of persistence mechanism depends on data size, complexity, security requirements, and whether sync is needed.' },
    { topic: 'persistence', level: 0, question: 'What is UserDefaults and when should you use it?', hint: 'Think about small, simple key-value data.', answer: 'UserDefaults is a simple key-value store for small amounts of data — user preferences, settings flags, and simple state. It stores data as a property list (plist) on disk. Supports: String, Int, Double, Bool, Data, Date, Array, Dictionary. Not suitable for: large data, sensitive data (not encrypted), complex object graphs, or frequently changing data. Access via UserDefaults.standard.set(value, forKey:) and .object(forKey:). It\'s synchronous and cached in memory.' },

    // Level 1
    { topic: 'persistence', level: 1, question: 'What are the different ways to persist data in iOS?', hint: 'Think about UserDefaults, Keychain, Core Data, files, and more.', answer: 'UserDefaults: small key-value pairs (settings). Keychain: encrypted storage for credentials and tokens. Core Data: object graph with relationships and SQLite backing. SwiftData: modern declarative persistence (iOS 17+). FileManager: raw file storage (JSON, images, documents). SQLite directly via GRDB or similar. CloudKit: cloud sync across devices. plist files: structured configuration. Choose based on data size, structure complexity, security needs, query requirements, and sync needs.' },
    { topic: 'persistence', level: 1, question: 'What is the Keychain and why should you use it instead of UserDefaults for sensitive data?', hint: 'Think about encryption and security.', answer: 'The Keychain is Apple\'s secure, encrypted storage for sensitive data — passwords, tokens, certificates, and cryptographic keys. Data is encrypted at the hardware level and protected by the device passcode. It persists across app reinstalls (by default) and can be shared between apps via Keychain groups. UserDefaults stores data as an unencrypted plist — anyone with device access can read it. Always use Keychain for auth tokens, API keys, and user credentials.' },

    // Level 2
    { topic: 'persistence', level: 2, question: 'How does Core Data handle concurrency and what are the rules?', hint: 'Think about NSManagedObjectContext and thread confinement.', answer: 'NSManagedObjectContext is not thread-safe — each context must be accessed only on its designated queue. Use context.perform {} or performAndWait {} for thread-safe access. Use NSPersistentContainer.newBackgroundContext() for background operations. NSManagedObjects are confined to their context\'s queue — never pass managed objects across threads, pass NSManagedObjectID instead. Multiple contexts can merge changes via NSManagedObjectContextDidSave notification.' },
    { topic: 'persistence', level: 2, question: 'What is SwiftData and how does it compare to Core Data?', hint: 'Think about declarative modeling and SwiftUI integration.', answer: 'SwiftData (iOS 17+) is Apple\'s modern persistence framework built on Core Data. Models are declared with @Model macro on plain Swift classes — no .xcdatamodeld files needed. Properties are automatically persisted. Queried via @Query property wrapper in SwiftUI or ModelContext.fetch(). Compared to Core Data: much less boilerplate, native Swift types, better SwiftUI integration, automatic schema migration for simple changes. It still uses SQLite under the hood. Use Core Data for complex migration needs or Objective-C interop.' },

    // Level 3
    { topic: 'persistence', level: 3, question: 'How would you design a robust offline-first architecture for an iOS app?', hint: 'Think about local cache, sync strategy, and conflict resolution.', answer: 'Local database (Core Data/SwiftData) as the source of truth — UI always reads from local store, never directly from network. Background sync service pushes local changes to server and pulls updates. Track local changes with timestamps or change tokens. Queue pending changes when offline, sync on connectivity return. Conflict resolution: last-write-wins for simple data, three-way merge for complex data, user prompt for critical conflicts. Use URLSession background sessions for reliable sync.' },
    { topic: 'persistence', level: 3, question: 'How do you handle Core Data migrations when your data model changes?', hint: 'Think about lightweight vs heavyweight migrations.', answer: 'Lightweight migration handles simple changes automatically — adding attributes (with defaults), renaming (with renaming ID), adding/removing relationships, adding entities. Enable with NSPersistentStoreDescription shouldMigrateStoreAutomatically and shouldInferMappingModelAutomatically. Heavyweight migration (custom NSMappingModel + NSEntityMigrationPolicy) is needed for: data transformations, splitting/merging entities, or complex relationship changes. Always test migrations with production-sized data. Use versioned .xcdatamodeld with explicit model versions.' },

    // Level 4
    { topic: 'persistence', level: 4, question: 'How would you design a high-performance caching layer for an app with millions of records?', hint: 'Think about multi-tier caching, eviction strategies, and database optimization.', answer: 'Multi-tier: L1 in-memory cache (NSCache, auto-evicts under pressure) → L2 SQLite/Core Data with indexed queries. Database optimization: create indexes on frequently queried columns, use batch fetching (fetchBatchSize), prefetch relationships (relationshipKeyPathsForPrefetching). Eviction: LRU based on access timestamps with configurable size limits. Background cleanup job removes stale entries. For reads: query L1 first, fall back to L2, then network. Write-through: update both caches on write. Monitor cache hit rates to tune sizes.' },

    // Level 5
    { topic: 'persistence', level: 5, question: 'How would you design a cross-platform sync engine that handles conflict resolution, schema evolution, and eventual consistency?', hint: 'Think about CRDTs, vector clocks, and operational transforms.', answer: 'Use hybrid logical clocks (HLC) for causal ordering across devices. Schema evolution via versioned data envelope — each record includes schema version, reader upgrades on the fly. CRDTs for conflict-free types (counters, sets, text via sequence CRDTs). Operational transform for ordered operations where CRDTs don\'t fit. Sync protocol: client sends local operations since last sync token, server responds with remote operations and new token. Compact operation history periodically via snapshots. End-to-end encryption with per-record keys. Test with chaos engineering (random network delays, partitions, clock skew).' },

    // =============================================
    // NETWORKING
    // =============================================
    // Level 0
    { topic: 'networking', level: 0, question: 'What is an API and how do iOS apps communicate with servers?', hint: 'Think about HTTP requests and JSON responses.', answer: 'An API (Application Programming Interface) defines how software components communicate. iOS apps typically communicate with servers via HTTP/HTTPS REST APIs. The app sends HTTP requests (GET, POST, PUT, DELETE) to server URLs (endpoints) and receives responses, usually in JSON format. URLSession is Apple\'s built-in framework for making network requests. The process: create a URL → build a URLRequest → create a data task → parse the response.' },
    { topic: 'networking', level: 0, question: 'What is JSON and how does Swift handle it?', hint: 'Think about Codable protocol and JSONDecoder.', answer: 'JSON (JavaScript Object Notation) is a lightweight text format for data exchange: {"name": "John", "age": 30}. Swift handles JSON via the Codable protocol (Encodable + Decodable). Define a struct conforming to Codable with matching property names. Use JSONDecoder().decode(Type.self, from: data) to parse JSON into Swift types. Use JSONEncoder() for the reverse. CodingKeys enum customizes the mapping between JSON keys and Swift property names.' },

    // Level 1
    { topic: 'networking', level: 1, question: 'How does URLSession work in iOS?', hint: 'Think about tasks, configurations, and async/await.', answer: 'URLSession is the standard networking API. Create a session (URLSession.shared for defaults, custom for specific configurations). Create tasks: dataTask (in-memory response), downloadTask (saves to file), uploadTask (sends data). Modern approach: let (data, response) = try await URLSession.shared.data(for: request). Configure via URLSessionConfiguration: timeouts, caching policy, headers, cookie policy. URLSession handles cookies, HTTP/2, certificate validation, and connection pooling automatically.' },
    { topic: 'networking', level: 1, question: 'What are HTTP methods and status codes?', hint: 'Think about CRUD operations and server response categories.', answer: 'HTTP methods: GET (read), POST (create), PUT (replace), PATCH (partial update), DELETE (remove). Status code categories: 1xx (informational), 2xx (success — 200 OK, 201 Created, 204 No Content), 3xx (redirect — 301 Moved, 304 Not Modified), 4xx (client error — 400 Bad Request, 401 Unauthorized, 404 Not Found), 5xx (server error — 500 Internal, 503 Unavailable). Always check status codes in your networking layer.' },

    // Level 2
    { topic: 'networking', level: 2, question: 'How would you design a type-safe networking layer in Swift?', hint: 'Think about protocols, generics, and Codable.', answer: 'Define an Endpoint protocol: path, HTTP method, headers, body (Encodable), response type (Decodable). A generic NetworkClient takes any Endpoint and returns the decoded response: func request<E: Endpoint>(_ endpoint: E) async throws -> E.Response. URLRequest is built from endpoint properties. Handle errors via a typed NetworkError enum (connectivity, timeout, serverError(code), decodingFailed). Add interceptors for auth tokens, logging, and retry. This pattern ensures compile-time type safety for all API calls.' },
    { topic: 'networking', level: 2, question: 'What is URL caching and how does it work in iOS?', hint: 'Think about URLCache, cache policies, and HTTP cache headers.', answer: 'URLCache provides transparent HTTP caching using an in-memory and on-disk cache. It respects HTTP cache headers (Cache-Control, ETag, Last-Modified, Expires). Cache policies: .useProtocolCachePolicy (respect server headers), .returnCacheDataElseLoad (cache first), .reloadIgnoringLocalCacheData (skip cache). Configure cache size via URLSessionConfiguration. For custom caching beyond HTTP semantics, implement your own cache layer. URLCache.shared is the default with 4MB memory / 20MB disk.' },

    // Level 3
    { topic: 'networking', level: 3, question: 'How do you handle authentication token refresh in a networking layer without race conditions?', hint: 'Think about request queuing and serial access.', answer: 'Use an actor (or serial DispatchQueue) to serialize token refresh. When a 401 is received: check if a refresh is already in progress. If so, suspend the current request and queue it behind the refresh. If not, start a refresh and queue all subsequent 401 requests. Once the token refreshes, retry all queued requests with the new token. If refresh fails, fail all queued requests and force re-login. Actor isolation naturally prevents race conditions between concurrent requests hitting 401 simultaneously.' },
    { topic: 'networking', level: 3, question: 'How do you implement request retry with exponential backoff?', hint: 'Think about retry strategies, jitter, and maximum attempts.', answer: 'Exponential backoff increases the delay between retries: delay = baseDelay × 2^attempt. Add random jitter (±25%) to prevent thundering herd when many clients retry simultaneously. Implementation: wrap the request in a retry loop with max attempts (e.g., 3). Only retry on retryable errors (5xx, timeout, connectivity — not 4xx client errors). Use Task.sleep(nanoseconds:) for async delays. Respect Retry-After headers from the server. Log each retry for debugging. Cancel retries if the task is cancelled.' },

    // Level 4
    { topic: 'networking', level: 4, question: 'How would you design a networking layer that supports offline queuing and background uploads?', hint: 'Think about URLSession background sessions, operation persistence, and retry.', answer: 'Use URLSession with background configuration — the OS continues transfers even if the app is suspended/terminated. Persist pending requests to disk (Core Data or file-based queue) with all metadata (URL, method, headers, body). On connectivity change (NWPathMonitor), drain the queue. Dedup requests by idempotency key. Handle upload completion in application(_:handleEventsForBackgroundURLSession:). For non-background sessions: queue operations locally, retry on app foreground. Priority system for critical vs deferrable requests.' },

    // Level 5
    { topic: 'networking', level: 5, question: 'How would you design a GraphQL client for iOS that supports code generation, caching, and real-time subscriptions?', hint: 'Think about schema-driven development, normalized caching, and WebSocket transport.', answer: 'Code generation: compile .graphql files against the schema at build time, generating Swift types for queries, mutations, and fragments. Normalized cache: store entities by ID (like Apollo\'s cache) so updating a User anywhere updates all views showing that user. Cache policies per query: cache-first, network-first, cache-and-network. Real-time: GraphQL subscriptions over WebSocket (graphql-ws protocol). Optimistic UI: apply mutations locally before server confirmation, rollback on error. Pagination: support cursor-based and offset pagination with cache merging. Type-safe variables and response types throughout.' },

    // =============================================
    // PERFORMANCE
    // =============================================
    // Level 0
    { topic: 'performance', level: 0, question: 'What makes an iOS app feel "fast" or "slow" to users?', hint: 'Think about launch time, scrolling, and responsiveness to taps.', answer: 'Users perceive an app as fast when: it launches quickly (under 1 second), the UI responds to taps within 100ms, scrolling is smooth (60fps), animations don\'t stutter, and content loads progressively (skeleton screens, placeholders). Slowness is caused by: heavy work on the main thread, unoptimized images, excessive network calls, complex view hierarchies, and memory pressure causing the system to throttle the app.' },
    { topic: 'performance', level: 0, question: 'What is the difference between 60fps and 120fps, and why does it matter?', hint: 'Think about frame budgets and ProMotion displays.', answer: 'At 60fps, each frame has 16.67ms to render. At 120fps (ProMotion on recent iPhones/iPads), each frame has only 8.33ms. If rendering takes longer than the frame budget, frames are dropped causing visible stutter. The system dynamically adjusts between 10-120fps based on content. Animations and scrolling need to hit the target consistently. Use CADisplayLink to sync with the display refresh rate. Profile with Core Animation instrument to track dropped frames.' },

    // Level 1
    { topic: 'performance', level: 1, question: 'What are common causes of a slow app launch?', hint: 'Think about what happens before the first screen appears.', answer: 'Pre-main phase: too many dynamic frameworks (each requires loading and linking), excessive Objective-C +load methods, large binary size. Post-main phase: synchronous network calls in app delegate, heavy Core Data migrations, complex initial view hierarchy, loading large assets synchronously, unnecessary service initialization. Fix: merge frameworks (static linking), defer initialization, use lazy loading, show a lightweight launch screen immediately, and measure with Instruments App Launch template.' },

    // Level 2
    { topic: 'performance', level: 2, question: 'What tools does Apple provide for profiling iOS app performance?', hint: 'Think about Instruments and Xcode features.', answer: 'Instruments: Time Profiler (CPU bottlenecks), Allocations (memory usage over time), Leaks (retain cycles), Core Animation (rendering performance, dropped frames), Network (request timing), Energy Log (battery impact), App Launch (startup time). Xcode: Memory Graph Debugger (object relationships), View Debugger (hierarchy inspection), GPU Frame Debugger. MetricKit for production monitoring. os_signpost for custom performance markers. XCTest measure {} for benchmarks.' },
    { topic: 'performance', level: 2, question: 'How do you optimize image loading and display in an iOS app?', hint: 'Think about downsampling, caching, and asynchronous decoding.', answer: 'Downsample at load time — load images at display size, not full resolution (CGImageSourceCreateThumbnailAtIndex). Decode on background thread (UIImage is decoded lazily on first display, blocking the main thread). Use NSCache for memory caching with automatic eviction. Disk cache with size limits for downloaded images. Avoid UIImage(named:) for large images (permanently cached). Use progressive loading for large images. Consider HEIF format for smaller file sizes. Libraries like Kingfisher/Nuke handle all this automatically.' },

    // Level 3
    { topic: 'performance', level: 3, question: 'How do you optimize table/collection view scrolling performance?', hint: 'Think about cell reuse, offscreen rendering, and prefetching.', answer: 'Cell reuse via dequeueReusableCell prevents allocation overhead. Avoid offscreen rendering: shadows without shadowPath, cornerRadius with masksToBounds, complex masks — use pre-rendered images or shouldRasterize. Async image loading/decoding on background threads. Pre-calculate cell heights (self-sizing can be expensive). Minimize view hierarchy depth in cells. DiffableDataSource for efficient updates. UITableViewDataSourcePrefetching for data preloading. Profile with Core Animation instrument — green highlights offscreen rendering, aim for 0 dropped frames.' },
    { topic: 'performance', level: 3, question: 'What is off-screen rendering and how do you avoid it?', hint: 'Think about GPU composition and extra render passes.', answer: 'Off-screen rendering occurs when the GPU needs an extra rendering pass in an offscreen buffer before compositing the final frame. Caused by: cornerRadius + masksToBounds together, shadows without shadowPath, masks, group opacity, complex clipping. Each off-screen pass is expensive — the GPU switches contexts. Fix: set shadowPath explicitly for shadows, use pre-rounded images instead of cornerRadius masking, use shouldRasterize for static content (caches the rendered layer), simplify layer hierarchies. Detect with Core Animation instrument "Color Offscreen-Rendered" option.' },

    // Level 4
    { topic: 'performance', level: 4, question: 'How would you reduce app launch time from 3 seconds to under 1 second?', hint: 'Think about pre-main and post-main optimization phases.', answer: 'Pre-main: merge dynamic frameworks into static libraries (reduces dyld loading), reduce ObjC class/category count, eliminate __attribute__((constructor)) code, strip unused code. Post-main: audit didFinishLaunchingWithOptions — move non-essential init to background, use lazy service registration, avoid synchronous network/database calls, simplify initial view hierarchy (show skeleton UI immediately). Measure: DYLD_PRINT_STATISTICS for pre-main, Instruments App Launch template for post-main. Profile both cold (first launch after boot) and warm (subsequent) launches.' },
    { topic: 'performance', level: 4, question: 'How do you monitor and improve app performance in production?', hint: 'Think about MetricKit, custom metrics, and performance budgets.', answer: 'MetricKit provides system-collected metrics: launch time, hang rate, memory, battery, disk writes — delivered as daily/weekly reports. Custom instrumentation: os_signpost for critical paths, custom analytics events for user-perceived performance (time to interactive, content load time). Performance budgets: CI fails if launch time exceeds threshold, or if new code adds more than N ms to critical paths. Use hang detection (main thread checker) with stack trace collection. A/B test performance changes. Dashboard with P50/P95/P99 metrics per app version.' },

    // Level 5
    { topic: 'performance', level: 5, question: 'How would you design a performance regression detection system for a large iOS team?', hint: 'Think about automated benchmarking, statistical analysis, and CI integration.', answer: 'Automated benchmark suite: XCTest measure {} for critical paths (launch, screen transitions, data processing). Run on dedicated CI hardware (consistent results — no shared resources). Statistical analysis: require N runs, compare median/P95 against baseline with statistical significance tests (Mann-Whitney U). Alert on regressions exceeding thresholds. Store historical data for trend analysis. Binary size tracking per module with automated attribution. Memory highwater marks per screen. MetricKit data aggregation for production regressions. Performance review as part of PR process for critical paths.' },

    // =============================================
    // APP LIFECYCLE
    // =============================================
    // Level 0
    { topic: 'lifecycle', level: 0, question: 'What happens when a user taps an app icon on their iPhone?', hint: 'Think about the sequence from tap to the first screen appearing.', answer: 'The system loads the app binary into memory (dyld links dynamic libraries). The runtime initializes (Objective-C/Swift classes registered). main() is called, which calls UIApplicationMain(). The app delegate\'s application(_:didFinishLaunchingWithOptions:) fires. The initial view controller is loaded and its view hierarchy is created. The first frame is rendered and displayed, replacing the launch screen. The app enters the foreground active state and is ready for user interaction.' },
    { topic: 'lifecycle', level: 0, question: 'What is a launch screen and why is it important?', hint: 'Think about perceived performance and app store requirements.', answer: 'The launch screen (LaunchScreen.storyboard or launch screen info in Info.plist) is displayed immediately when the app starts, before any code runs. It gives the impression of instant launch. Apple requires it for App Store submission. Best practice: make it look like the app\'s initial state (with empty content areas) so the transition feels seamless. Avoid logos, loading spinners, or branding — Apple\'s HIG recommends a placeholder that matches the first screen.' },

    // Level 1
    { topic: 'lifecycle', level: 1, question: 'What are the main states of an iOS application lifecycle?', hint: 'Not Running, Inactive, Active, Background, Suspended.', answer: 'Not Running: app hasn\'t been launched or was terminated. Inactive: app is in foreground but not receiving events (e.g., during phone call overlay, notification banner, or app switcher). Active: app is in foreground and receiving events. Background: app is executing code but not visible (e.g., finishing a task, playing audio). Suspended: app is in memory but not executing code — can be terminated without notice if memory is needed.' },
    { topic: 'lifecycle', level: 1, question: 'What is the difference between applicationWillTerminate and applicationDidEnterBackground?', hint: 'Think about when each is called and what you should do in them.', answer: 'applicationDidEnterBackground: called every time the app moves to background — save user data, release shared resources, store enough state to restore the UI later. You have ~5 seconds. applicationWillTerminate: called only when the app is about to be killed (not always called — if the app is suspended and purged, this is skipped). It\'s unreliable for saving data. Always save critical data in didEnterBackground, not willTerminate.' },

    // Level 2
    { topic: 'lifecycle', level: 2, question: 'How does the SceneDelegate differ from AppDelegate and why was it introduced?', hint: 'Think about multi-window support on iPad.', answer: 'AppDelegate handles app-level events: launch, push notifications, background fetch, app termination. SceneDelegate handles per-window/scene UI lifecycle: foreground/background state, connection/disconnection. Introduced in iOS 13 for multi-window support on iPad — each window is a UIScene with its own independent lifecycle. In SwiftUI, @main App struct and WindowGroup replace both. Key: an app can have multiple scenes, each in different states simultaneously.' },
    { topic: 'lifecycle', level: 2, question: 'How does background execution work in iOS?', hint: 'Think about what apps can do when not in the foreground.', answer: 'iOS strictly limits background execution. Allowed modes: audio playback, location updates, VoIP, Bluetooth, external accessories, background fetch, remote notifications, background processing (BGTaskScheduler). After entering background, apps get ~5 seconds (extendable to ~30 with beginBackgroundTask). Background App Refresh allows periodic fetches. BGProcessingTask allows heavy work (ML training, maintenance) when device is charging and idle. All must be declared in Info.plist UIBackgroundModes. The system may delay or skip background execution based on device conditions.' },

    // Level 3
    { topic: 'lifecycle', level: 3, question: 'How do you implement state restoration so your app returns to where the user left off?', hint: 'Think about NSUserActivity, state encoding, and scene-based restoration.', answer: 'Modern approach (iOS 13+): implement stateRestorationActivity(for:) in SceneDelegate to return an NSUserActivity encoding the current state. On reconnection, read the activity from connectionOptions or session.stateRestorationActivity. Encode navigation stack, selected tab, scroll position, and unsaved form data. For SwiftUI: use @SceneStorage for automatic per-scene persistence. Legacy approach: UIKit\'s restorationIdentifier system with encodeRestorableState/decodeRestorableState. Test by killing the app via Xcode debugger (not force-quit, which deliberately discards state).' },
    { topic: 'lifecycle', level: 3, question: 'How do push notifications and background fetch interact with the app lifecycle?', hint: 'Think about silent notifications, content-available, and background modes.', answer: 'Silent push (content-available: 1): wakes the app in background to fetch new content — application(_:didReceiveRemoteNotification:fetchCompletionHandler:) is called. The app has ~30 seconds. Regular push: if app is foreground, userNotificationCenter(_:willPresent:) is called. If background/terminated: tapping the notification calls didReceive response handler. Background fetch (deprecated in favor of BGAppRefreshTask): system periodically wakes the app. All background work must call the completion handler promptly. The system throttles apps that take too long or use too much energy.' },

    // Level 4
    { topic: 'lifecycle', level: 4, question: 'How would you design an app that needs to perform long-running work reliably in the background?', hint: 'Think about BGTaskScheduler, silent push, and reliability strategies.', answer: 'Use BGProcessingTask for heavy work (data sync, ML model updates) — runs when device is idle and charging. BGAppRefreshTask for lightweight periodic updates (content refresh). Supplement with silent push notifications for server-triggered updates. For critical data sync: URLSession background sessions continue even after app termination. Combine strategies: silent push triggers an immediate lightweight sync, BGProcessingTask handles full sync nightly. Monitor task completion rates via analytics. Handle system constraints gracefully — tasks can be terminated early, so checkpoint progress.' },

    // Level 5
    { topic: 'lifecycle', level: 5, question: 'How would you architect an iOS app that seamlessly handles every lifecycle edge case including Handoff, Spotlight, widgets, and Siri intents?', hint: 'Think about unified routing, shared data layer, and extension architecture.', answer: 'Central Router accepts entry points from all sources: UIApplication delegate methods, NSUserActivity (Handoff, Spotlight, Universal Links), SceneDelegate, widget intents, and Siri intents. Each entry point is normalized into a typed Route enum. Shared data layer (App Group container with SwiftData/Core Data) enables extensions and widgets to access the same data. App intents framework (iOS 16+) provides a unified action layer for Shortcuts, Siri, and Spotlight. Widget timeline provider reads from the shared store. Test every entry point × app state combination (not running, background, foreground).' },

    // =============================================
    // SECURITY
    // =============================================
    // Level 0
    { topic: 'security', level: 0, question: 'Why is security important in iOS app development?', hint: 'Think about user data protection and trust.', answer: 'iOS apps handle sensitive user data: passwords, payment info, personal details, location, health data. Security breaches lead to: data theft, identity fraud, financial loss, and destroyed user trust. Apple requires certain security practices for App Store approval. Good security includes: encrypted storage, secure networking (HTTPS), proper authentication, input validation, and protecting against reverse engineering. Security is not optional — it\'s a core requirement.' },
    { topic: 'security', level: 0, question: 'What is HTTPS and why should all network requests use it?', hint: 'Think about encryption in transit.', answer: 'HTTPS (HTTP Secure) encrypts all data between the app and server using TLS (Transport Layer Security). Without HTTPS, anyone on the same network can read the data (passwords, tokens, personal info). iOS enforces App Transport Security (ATS) by default — all HTTP connections are blocked unless explicitly allowed. HTTPS provides: encryption (data can\'t be read), integrity (data can\'t be modified), and authentication (server identity verified via certificates).' },

    // Level 1
    { topic: 'security', level: 1, question: 'What is App Transport Security (ATS) in iOS?', hint: 'Think about enforcing secure network connections.', answer: 'ATS is an iOS security feature that requires all network connections to use HTTPS with TLS 1.2+ and strong cipher suites. Enabled by default since iOS 9. HTTP connections fail unless explicitly allowed via Info.plist exceptions (NSAllowsArbitraryLoads — discouraged). You can add per-domain exceptions for legacy servers. Apple reviews ATS exceptions during App Store review. Best practice: fix your server to support TLS 1.2+ rather than adding exceptions.' },
    { topic: 'security', level: 1, question: 'What data should never be stored in plain text on an iOS device?', hint: 'Think about what an attacker could exploit if they accessed the device.', answer: 'Never store in plain text: passwords, authentication tokens, API keys, credit card numbers, social security numbers, private keys, biometric data. Use Keychain for credentials and tokens. Use encryption (CryptoKit/CommonCrypto) for sensitive user data at rest. Never hardcode secrets in source code — they can be extracted from the binary. Use server-side validation for sensitive operations. Even UserDefaults and CoreData are unencrypted by default.' },

    // Level 2
    { topic: 'security', level: 2, question: 'How do you securely store sensitive data in iOS?', hint: 'Keychain, not UserDefaults.', answer: 'Keychain: encrypted at hardware level for tokens, passwords, and keys. Use kSecAttrAccessible to control access timing (e.g., kSecAttrAccessibleWhenUnlockedThisDeviceOnly). Secure Enclave: for cryptographic key generation — keys never leave the hardware chip. Data Protection API: file-level encryption tied to device passcode. CryptoKit: encrypt/decrypt data with AES-GCM before storing. Never use: UserDefaults (unencrypted plist), hardcoded strings in code (extractable from binary), or NSCoding archives without encryption.' },
    { topic: 'security', level: 2, question: 'How does code signing work in iOS and why is it important?', hint: 'Think about certificates, provisioning profiles, and trust.', answer: 'Code signing cryptographically verifies that an app hasn\'t been modified since it was built by the developer. Components: signing certificate (developer identity), provisioning profile (ties app ID, certificate, device IDs, and entitlements). At install, iOS verifies the signature chain back to Apple\'s root certificate. At runtime, the kernel checks code pages as they\'re loaded. This prevents: tampered apps, unauthorized sideloading, and runtime code injection. Enterprise and TestFlight have their own trust mechanisms.' },

    // Level 3
    { topic: 'security', level: 3, question: 'What is certificate pinning and how do you implement it in iOS?', hint: 'Preventing MITM attacks by validating the server\'s certificate.', answer: 'Certificate pinning validates that the server\'s TLS certificate matches a known, trusted certificate or public key bundled with the app — preventing man-in-the-middle attacks even if a CA is compromised. Implement via URLSessionDelegate urlSession(_:didReceive:completionHandler:): compare the server certificate\'s public key hash against your pinned hashes. Pin public keys (not certificates) to survive rotation. Include backup pins. Update pins before certificate expiry. Libraries like TrustKit simplify implementation and provide reporting.' },
    { topic: 'security', level: 3, question: 'How do you protect your iOS app against reverse engineering?', hint: 'Think about obfuscation, jailbreak detection, and runtime integrity.', answer: 'Obfuscation: rename symbols, encrypt string literals, insert dead code paths. Jailbreak detection: check for Cydia, writable system paths, fork() behavior, dynamic library injection (DYLD_INSERT_LIBRARIES). Runtime integrity: detect debugger attachment (sysctl), check code signature at runtime, validate framework integrity via checksums. Anti-tampering: detect method swizzling, verify Objective-C runtime integrity. Note: all client-side protections can be bypassed with enough effort — never rely solely on client security. Critical logic should be server-side.' },

    // Level 4
    { topic: 'security', level: 4, question: 'How would you design a secure authentication system for an iOS app?', hint: 'Think about OAuth, biometrics, token storage, and session management.', answer: 'Authentication flow: OAuth 2.0 + PKCE via ASWebAuthenticationSession (prevents token interception). Token storage: access token in memory only, refresh token in Keychain (kSecAttrAccessibleWhenUnlockedThisDeviceOnly). Biometric auth: LocalAuthentication framework — use as a convenience unlock, not as primary auth. Session management: short-lived access tokens (15 min), long-lived refresh tokens, server-side session revocation. Implement token rotation on each refresh. Protect against replay attacks with nonces. Rate limit login attempts server-side.' },
    { topic: 'security', level: 4, question: 'How do you handle sensitive data in app logs, crash reports, and analytics?', hint: 'Think about PII leakage through diagnostic channels.', answer: 'Sanitize all logging: never log tokens, passwords, PII, or financial data. Use OSLog with privacy: .private for sensitive values (redacted in production). Crash reports: custom NSSetUncaughtExceptionHandler that scrubs sensitive state before reporting. Analytics: hash or anonymize user identifiers, use random session IDs. Network logging interceptor: redact Authorization headers and request bodies containing credentials. Audit third-party SDKs for data collection. Implement data classification (public, internal, confidential, restricted) and enforce logging rules per classification.' },

    // Level 5
    { topic: 'security', level: 5, question: 'How would you design a zero-trust security architecture for a banking iOS app?', hint: 'Think about device attestation, mutual TLS, runtime integrity, and defense in depth.', answer: 'Device attestation: Apple DeviceCheck/App Attest to verify genuine app on non-compromised device. Mutual TLS: client certificate in Secure Enclave for server to verify device identity. Runtime integrity: continuous checks for debugger, jailbreak, hooking frameworks. Encrypted local storage with keys derived from Secure Enclave. Network: certificate pinning with multiple pins, request signing with HMAC. Session security: step-up authentication for sensitive operations (biometric re-auth). Binary protection: code obfuscation, anti-tampering checks. Incident response: remote kill switch for compromised versions, forced upgrade capability. All critical business logic validated server-side.' },

    // =============================================
    // CI/CD & TOOLS
    // =============================================
    // Level 0
    { topic: 'cicd', level: 0, question: 'What is version control and why do developers use Git?', hint: 'Think about tracking changes and collaboration.', answer: 'Version control tracks every change to code over time, enabling: history browsing (who changed what, when), reverting mistakes, parallel work via branches, and team collaboration without conflicts. Git is the most popular distributed version control system. Key concepts: repository (project), commit (snapshot), branch (parallel line of work), merge (combining branches), pull request (code review before merging). Git enables multiple developers to work on the same codebase safely.' },
    { topic: 'cicd', level: 0, question: 'What is Xcode and what tools does it include for iOS development?', hint: 'Think about the complete development environment.', answer: 'Xcode is Apple\'s IDE for iOS/macOS development. It includes: code editor (syntax highlighting, autocompletion), Interface Builder (visual UI design), Swift compiler, Simulator (test on virtual devices), Instruments (performance profiling), debugger (LLDB), asset catalog manager, Core Data model editor, and testing framework (XCTest). It also manages code signing, provisioning, and App Store submission. Xcode is required for building iOS apps.' },

    // Level 1
    { topic: 'cicd', level: 1, question: 'What is CocoaPods, SPM, and Carthage? How do they differ?', hint: 'Think about dependency management approaches.', answer: 'All three manage third-party library dependencies. CocoaPods: centralized spec repo, modifies your Xcode project, uses a Podfile. SPM (Swift Package Manager): Apple\'s built-in solution integrated into Xcode, uses Package.swift, supports binary and source dependencies. Carthage: decentralized, builds frameworks without modifying your project, uses a Cartfile. SPM is the modern standard — no extra tools needed, supports both packages and apps. CocoaPods has the largest library ecosystem but adds complexity.' },
    { topic: 'cicd', level: 1, question: 'What is a code review and why is it important?', hint: 'Think about quality, knowledge sharing, and catching issues early.', answer: 'Code review is the practice of having teammates examine code changes before merging. Benefits: catches bugs and logic errors, ensures code quality and consistency, spreads knowledge across the team (no single points of failure), mentors junior developers, and maintains architecture standards. Pull/merge requests on GitHub/GitLab facilitate reviews with inline comments, approvals, and CI check requirements. Effective reviews focus on: correctness, readability, testability, and architectural fit.' },

    // Level 2
    { topic: 'cicd', level: 2, question: 'What is a CI/CD pipeline and why is it important for iOS development?', hint: 'Continuous Integration and Continuous Delivery.', answer: 'CI automatically builds and tests code on every commit/PR, catching integration issues early. CD automates deployment to TestFlight/App Store. Typical pipeline: lint → build → unit tests → integration tests → UI tests → archive → distribute. Benefits: faster feedback loops, consistent reproducible builds, reduced manual errors, confidence to ship frequently. Tools: Xcode Cloud (Apple), Bitrise, GitHub Actions, CircleCI, Fastlane for automation. Quality gates enforce standards before merge.' },
    { topic: 'cicd', level: 2, question: 'What is Fastlane and what problems does it solve?', hint: 'Think about automating repetitive iOS development tasks.', answer: 'Fastlane automates tedious iOS tasks: code signing (match — syncs certificates via git), testing (scan), building (gym), screenshots (snapshot), App Store uploads (pilot for TestFlight, deliver for production), and metadata management. Defined in a Fastfile with lanes (workflows). Reduces manual errors in signing and distribution. Integrates with all CI systems. Key benefit: reproducible, automated releases that any team member can trigger without manual Xcode steps.' },

    // Level 3
    { topic: 'cicd', level: 3, question: 'How does Fastlane help with iOS automation and what are the key lanes you would set up?', hint: 'Think about building, testing, signing, and distributing.', answer: 'Key lanes: test (scan — run unit and UI tests), build (gym — archive the app), beta (match for signing + pilot for TestFlight upload), release (deliver — App Store submission with metadata and screenshots). Match stores certificates and provisioning profiles in a git repo for team-wide consistency. Use environment variables for secrets (never hardcode). Advanced: snapshot for automated screenshots in multiple languages, precheck for App Store review guidelines validation. Integrate Fastlane into CI with fastlane <lane_name>.' },
    { topic: 'cicd', level: 3, question: 'How do you manage code signing across a development team?', hint: 'Think about certificates, profiles, and avoiding conflicts.', answer: 'Use Fastlane Match: stores all signing certificates and provisioning profiles in a single encrypted git repository. Every developer and CI machine runs match to download the same credentials. This eliminates "works on my machine" signing issues. Never create certificates manually in the Apple Developer Portal. Use separate signing identities for development, ad hoc, and App Store. Automatic signing in Xcode works for solo developers but causes conflicts on teams. Match supports app extensions, watchOS, and multiple bundle IDs.' },

    // Level 4
    { topic: 'cicd', level: 4, question: 'How would you design a CI/CD pipeline for a large iOS project with 50+ developers and multiple build targets?', hint: 'Think about build times, parallelization, caching, and release management.', answer: 'Pipeline stages: PR validation (lint + compile + unit tests — fast, <10 min) → merge to main (full test suite + integration tests) → nightly (UI tests, performance benchmarks) → release (archive, sign, distribute). Optimization: Bazel or tuist-based builds with remote caching, test parallelization across multiple simulators, selective testing (only affected modules). Branching: trunk-based development with short-lived feature branches. Release trains: weekly cuts with automated changelog generation. Separate pipelines per build target (dev, staging, production). Monitor: build time tracking, flaky test quarantine, code coverage trends.' },
    { topic: 'cicd', level: 4, question: 'How do you implement automated App Store releases with phased rollouts and rollback capability?', hint: 'Think about Fastlane deliver, phased release API, and monitoring.', answer: 'Automated release lane: bump version → generate changelog from git commits → build and archive → upload with Fastlane pilot/deliver → submit for review. Phased rollout: App Store Connect API to configure phased release (1% → 2% → 5% → 10% → 20% → 50% → 100% over 7 days). Monitor crash rate and user feedback at each phase. Rollback: pause phased rollout via API, expedite review for a fix build, or revert to previous version. Feature flags allow disabling problematic features without a new binary. Automated alerts on crash rate spikes trigger rollout pause.' },

    // Level 5
    { topic: 'cicd', level: 5, question: 'How would you design a build system for a monorepo iOS project that achieves sub-5-minute PR builds despite 2M+ lines of code?', hint: 'Think about Bazel, remote caching, affected target analysis, and distributed execution.', answer: 'Use Bazel (or Buck2) with fine-grained build targets per module. Remote cache (shared across all developers and CI) stores compiled artifacts keyed by content hash — only rebuild what changed. Affected target analysis: compare PR diff against dependency graph, only build and test affected targets. Distributed execution: spread compilation across multiple CI machines. Pre-built release artifacts: cache framework builds for stable dependencies. Virtual file system for source: only materialize files needed for the current build. Result: most PR builds only compile the changed module + run its tests. Infrastructure: dedicated build cache servers, build time analytics dashboard, cache hit rate monitoring.' },

    // =============================================
    // SYSTEM DESIGN
    // =============================================
    // Level 0
    { topic: 'system-design', level: 0, question: 'What is system design and why should iOS developers understand it?', hint: 'Think about designing the architecture of a complete feature or app.', answer: 'System design is the process of defining the architecture, components, data flow, and interfaces of a system to satisfy requirements. iOS developers need it because: apps don\'t exist in isolation — they interact with backends, caches, databases, and other services. Understanding system design helps you: make better API decisions, design efficient data flows, handle edge cases (offline, scale, failure), and communicate effectively with backend teams during feature planning.' },
    { topic: 'system-design', level: 0, question: 'What is client-server architecture and how does it apply to iOS apps?', hint: 'Think about how your app communicates with a backend.', answer: 'Client-server architecture: the iOS app (client) sends requests to a remote server, which processes them and returns responses. The server manages data, business logic, and authentication. The client handles UI and local state. Communication typically uses REST APIs over HTTPS with JSON. Benefits of this separation: multiple clients (iOS, Android, web) share one backend, server logic can be updated without app releases, and sensitive operations stay server-side.' },

    // Level 1
    { topic: 'system-design', level: 1, question: 'What is REST and how do RESTful APIs work?', hint: 'Think about resources, HTTP methods, and statelessness.', answer: 'REST (Representational State Transfer) is an architectural style for APIs. Principles: resources identified by URLs (/users/123), standard HTTP methods for operations (GET read, POST create, PUT update, DELETE remove), stateless requests (each contains all needed info), and responses typically in JSON. RESTful APIs are the most common way iOS apps communicate with servers. Good REST design uses: meaningful URLs, proper status codes, pagination for lists, and versioning (/api/v1/).' },
    { topic: 'system-design', level: 1, question: 'What is pagination and why is it important for mobile apps?', hint: 'Think about loading large lists efficiently.', answer: 'Pagination loads data in small chunks (pages) rather than all at once. Important because: mobile devices have limited memory and bandwidth, loading thousands of items wastes resources, and users only see a screenful at a time. Types: offset-based (page=2&limit=20 — simple but inconsistent with live data), cursor-based (after=abc123 — stable with real-time inserts/deletes). Implement in iOS with: scroll-to-bottom detection, prefetching (UITableViewDataSourcePrefetching), and loading indicators.' },

    // Level 2
    { topic: 'system-design', level: 2, question: 'How would you design the data flow for a social media feed on iOS?', hint: 'Think about caching, pagination, and real-time updates.', answer: 'Data flow: app loads cached feed from local database → displays immediately → fetches new posts from API in background → merges with local cache → updates UI. Pagination: cursor-based infinite scroll with prefetching. Caching: SQLite/Core Data for post data, NSCache + disk cache for images. Real-time: WebSocket or polling for new posts, pull-to-refresh for manual update. Optimistic UI: likes/comments update locally before server confirmation. Handle edge cases: offline mode (show cached), empty state, error state with retry.' },
    { topic: 'system-design', level: 2, question: 'What is the difference between REST, GraphQL, and gRPC? When would you use each?', hint: 'Think about query flexibility, performance, and mobile constraints.', answer: 'REST: simple, cacheable, one endpoint per resource — good for standard CRUD. GraphQL: client specifies exact data needed, reducing over-fetching (important on mobile) — good for complex data relationships and multiple client types. gRPC: binary protocol (Protocol Buffers), very fast, bidirectional streaming — good for internal microservices and real-time communication. For most iOS apps: REST for simplicity, GraphQL when data needs vary per screen, gRPC for high-performance real-time features. Consider mobile constraints: battery, bandwidth, latency.' },

    // Level 3
    { topic: 'system-design', level: 3, question: 'How would you design an image loading and caching system for a social media feed?', hint: 'Think about multi-level cache, memory/disk, and concurrent loading.', answer: 'Multi-level cache: L1 NSCache (memory, auto-evicts under pressure) → L2 disk cache (FileManager with content-hash filenames). Download via URLSession with concurrent queue, limited to ~4 simultaneous downloads. Cancel requests for cells that scroll off-screen. Decode/downsample on background thread to display size. Use ETag/Last-Modified for cache revalidation. LRU eviction for disk cache with configurable size limit. Progressive JPEG for large images. Key optimizations: prefetching for upcoming cells, thumbnail variants from CDN, and WebP/AVIF format support.' },
    { topic: 'system-design', level: 3, question: 'Design a chat messaging feature for an iOS app.', hint: 'Think about real-time delivery, offline support, and message ordering.', answer: 'Transport: WebSocket for real-time message delivery, HTTP fallback for reliability. Local storage: Core Data/SwiftData with messages table, indexed by conversation and timestamp. Message ordering: server-assigned monotonic IDs prevent clock skew issues. Offline support: queue outgoing messages locally, send on reconnect, show pending state in UI. Read receipts: track last-read message ID per conversation. Media messages: upload to CDN first, send message with media URL. Pagination: load recent messages first, fetch history on scroll-up. Push notifications for messages when app is backgrounded.' },

    // Level 4
    { topic: 'system-design', level: 4, question: 'Design an analytics SDK that other teams integrate into their iOS apps.', hint: 'Think about API simplicity, batching, persistence, privacy, and reliability.', answer: 'Simple API: Analytics.track(event, properties). Queue events in memory, flush periodically (every 30s) or on threshold (20 events). Persist unsent events to disk (SQLite) for crash resilience. Batch uploads to reduce network overhead and battery usage. Retry with exponential backoff. Privacy: consent management, data anonymization, GDPR/CCPA compliance, no PII in events. Thread-safe via actor isolation. Minimal binary size (<500KB) and zero third-party dependencies. Debug mode with console logging. Versioned event schema for backward compatibility. Automatic events: app launch, screen view, crash.' },
    { topic: 'system-design', level: 4, question: 'Design a payment processing feature for an iOS e-commerce app.', hint: 'Think about StoreKit, PCI compliance, and transaction reliability.', answer: 'For in-app purchases: StoreKit 2 with server-side receipt validation. For physical goods: PCI-compliant payment SDK (Stripe, Adyen) — never handle raw card data in the app. Transaction flow: create order on server → present payment sheet → process payment → confirm order → show receipt. Reliability: idempotency keys prevent duplicate charges, local transaction log for recovery, server-side webhook for payment confirmation. Security: tokenized card data, 3D Secure for SCA compliance. Handle edge cases: interrupted purchase (app killed during payment), network failure after charge, refunds and disputes.' },

    // Level 5
    { topic: 'system-design', level: 5, question: 'Design a real-time collaborative document editing feature for an iOS app (like Google Docs).', hint: 'Think about CRDTs or OT, conflict resolution, offline support, and sync protocol.', answer: 'Use CRDTs (Conflict-free Replicated Data Types) — specifically a sequence CRDT like RGA or Yjs for text. Local changes apply immediately for responsiveness (optimistic UI). Sync via WebSocket for real-time, HTTP for reconnection. Offline: queue operations locally, merge on reconnect using CRDT merge semantics (guaranteed convergence). Cursor/selection presence via lightweight presence channel (broadcast position, display remote cursors). Undo/redo per user via operation inversion. Compress operation history periodically via snapshots. Use TextKit 2 / custom TextLayoutManager for editor performance. Test with simulated network partitions and concurrent edits.' },
    { topic: 'system-design', level: 5, question: 'Design the architecture for a super-app that hosts mini-programs from third-party developers (like WeChat).', hint: 'Think about sandboxing, runtime isolation, capability-based permissions, and performance.', answer: 'Mini-programs run in WKWebView sandboxes with a native JavaScript bridge for controlled access to device capabilities. Capability-based permission model: each mini-program declares required APIs (camera, location, payment) — user approves on first use. Native bridge validates every call against granted permissions. Resource limits: memory cap (150MB), CPU throttling, network quota. Distribution: mini-programs are downloaded on-demand, cached locally, with server-side review process. Host provides shared UI components (navigation, tab bar, payment sheet) via bridge API. Version compatibility: bridge API is versioned, mini-programs declare minimum host version. Analytics and crash reporting aggregated per mini-program for developer console.' },
];
